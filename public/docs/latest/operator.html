<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Operators &mdash; Nextflow 23.10.0 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/theme.css" type="text/css" />
    <link rel="shortcut icon" href="_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Workflows" href="workflow.html" />
    <link rel="prev" title="Channels" href="channel.html" />
     
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-TNCXSWG');</script>
    <!-- End Google Tag Manager -->

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html">
            <img src="_static/nextflow-logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div>
    <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="getstarted.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="basic.html">Basic concepts</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Language</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="script.html">Scripts</a></li>
<li class="toctree-l1"><a class="reference internal" href="process.html">Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="channel.html">Channels</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Operators</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#branch">branch</a></li>
<li class="toctree-l2"><a class="reference internal" href="#buffer">buffer</a></li>
<li class="toctree-l2"><a class="reference internal" href="#collate">collate</a></li>
<li class="toctree-l2"><a class="reference internal" href="#collect">collect</a></li>
<li class="toctree-l2"><a class="reference internal" href="#collectfile">collectFile</a></li>
<li class="toctree-l2"><a class="reference internal" href="#combine">combine</a></li>
<li class="toctree-l2"><a class="reference internal" href="#concat">concat</a></li>
<li class="toctree-l2"><a class="reference internal" href="#count">count</a></li>
<li class="toctree-l2"><a class="reference internal" href="#countfasta">countFasta</a></li>
<li class="toctree-l2"><a class="reference internal" href="#countfastq">countFastq</a></li>
<li class="toctree-l2"><a class="reference internal" href="#countjson">countJson</a></li>
<li class="toctree-l2"><a class="reference internal" href="#countlines">countLines</a></li>
<li class="toctree-l2"><a class="reference internal" href="#cross">cross</a></li>
<li class="toctree-l2"><a class="reference internal" href="#distinct">distinct</a></li>
<li class="toctree-l2"><a class="reference internal" href="#dump">dump</a></li>
<li class="toctree-l2"><a class="reference internal" href="#filter">filter</a></li>
<li class="toctree-l2"><a class="reference internal" href="#first">first</a></li>
<li class="toctree-l2"><a class="reference internal" href="#flatmap">flatMap</a></li>
<li class="toctree-l2"><a class="reference internal" href="#flatten">flatten</a></li>
<li class="toctree-l2"><a class="reference internal" href="#grouptuple">groupTuple</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ifempty">ifEmpty</a></li>
<li class="toctree-l2"><a class="reference internal" href="#join">join</a></li>
<li class="toctree-l2"><a class="reference internal" href="#last">last</a></li>
<li class="toctree-l2"><a class="reference internal" href="#map">map</a></li>
<li class="toctree-l2"><a class="reference internal" href="#max">max</a></li>
<li class="toctree-l2"><a class="reference internal" href="#merge">merge</a></li>
<li class="toctree-l2"><a class="reference internal" href="#min">min</a></li>
<li class="toctree-l2"><a class="reference internal" href="#mix">mix</a></li>
<li class="toctree-l2"><a class="reference internal" href="#multimap">multiMap</a></li>
<li class="toctree-l2"><a class="reference internal" href="#randomsample">randomSample</a></li>
<li class="toctree-l2"><a class="reference internal" href="#reduce">reduce</a></li>
<li class="toctree-l2"><a class="reference internal" href="#set">set</a></li>
<li class="toctree-l2"><a class="reference internal" href="#splitcsv">splitCsv</a></li>
<li class="toctree-l2"><a class="reference internal" href="#splitfasta">splitFasta</a></li>
<li class="toctree-l2"><a class="reference internal" href="#splitfastq">splitFastq</a></li>
<li class="toctree-l2"><a class="reference internal" href="#splitjson">splitJson</a></li>
<li class="toctree-l2"><a class="reference internal" href="#splittext">splitText</a></li>
<li class="toctree-l2"><a class="reference internal" href="#subscribe">subscribe</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sum">sum</a></li>
<li class="toctree-l2"><a class="reference internal" href="#take">take</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tap">tap</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tointeger">toInteger</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tolist">toList</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tosortedlist">toSortedList</a></li>
<li class="toctree-l2"><a class="reference internal" href="#transpose">transpose</a></li>
<li class="toctree-l2"><a class="reference internal" href="#unique">unique</a></li>
<li class="toctree-l2"><a class="reference internal" href="#until">until</a></li>
<li class="toctree-l2"><a class="reference internal" href="#view">view</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="workflow.html">Workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="module.html">Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="config.html">Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="dsl1.html">Migrating from DSL 1</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Execution</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="cli.html">Command line interface (CLI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="executor.html">Executors</a></li>
<li class="toctree-l1"><a class="reference internal" href="cache-and-resume.html">Caching and resuming</a></li>
<li class="toctree-l1"><a class="reference internal" href="tracing.html">Tracing &amp; visualisation</a></li>
<li class="toctree-l1"><a class="reference internal" href="metrics.html">Metrics</a></li>
<li class="toctree-l1"><a class="reference internal" href="sharing.html">Pipeline sharing</a></li>
<li class="toctree-l1"><a class="reference internal" href="metadata.html">Workflow introspection</a></li>
<li class="toctree-l1"><a class="reference internal" href="mail.html">Mail &amp; Notifications</a></li>
<li class="toctree-l1"><a class="reference internal" href="plugins.html">Plugins</a></li>
<li class="toctree-l1"><a class="reference internal" href="secrets.html">Secrets</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Software dependencies</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="container.html">Containers</a></li>
<li class="toctree-l1"><a class="reference internal" href="conda.html">Conda environments</a></li>
<li class="toctree-l1"><a class="reference internal" href="spack.html">Spack environments</a></li>
<li class="toctree-l1"><a class="reference internal" href="wave.html">Wave containers</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Compute &amp; storage platforms</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="aws.html">Amazon Web Services</a></li>
<li class="toctree-l1"><a class="reference internal" href="amazons3.html">Amazon S3 storage</a></li>
<li class="toctree-l1"><a class="reference internal" href="azure.html">Azure Cloud</a></li>
<li class="toctree-l1"><a class="reference internal" href="fusion.html">Fusion file system</a></li>
<li class="toctree-l1"><a class="reference internal" href="google.html">Google Cloud</a></li>
<li class="toctree-l1"><a class="reference internal" href="kubernetes.html">Kubernetes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Additional integrations</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="flux.html">Flux Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="ignite.html">Apache Ignite</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Contributing</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="developer/index.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="developer/packages.html">Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="developer/plugins.html">Core plugins</a></li>
</ul>

        </div>
    <div class="nav-footer-logo">
        <a href="https://seqera.io/" target="_blank" title="Developed by Seqera Labs">
            Nextflow is developed by:<br>
            <img src="_static/seqera-logo.svg" alt="Seqera Labs">
        </a>
    </div>

      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Nextflow</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a></li>
      <li class="breadcrumb-item active">Operators</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/nextflow-io/nextflow/blob/master/docs/operator.md" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="operators">
<span id="operator-page"></span><h1>Operators<a class="headerlink" href="#operators" title="Permalink to this heading"></a></h1>
<p>Nextflow <strong>operators</strong> are methods that allow you to manipulate channels. Every operator, with the exception of <a class="reference internal" href="#set"><span class="std std-doc">set</span></a> and <a class="reference internal" href="#subscribe"><span class="std std-doc">subscribe</span></a>, produces one or more new channels, allowing you to chain operators to fit your needs.</p>
<p>This page is a comprehensive reference for all Nextflow operators. However, if you are new to Nextflow, here are some suggested operators to learn for common use cases:</p>
<ul class="simple">
<li><p>Filtering: <a class="reference internal" href="#filter"><span class="std std-doc">filter</span></a>, <a class="reference internal" href="#randomsample"><span class="std std-doc">randomSample</span></a>, <a class="reference internal" href="#take"><span class="std std-doc">take</span></a>, <a class="reference internal" href="#unique"><span class="std std-doc">unique</span></a></p></li>
<li><p>Reduction: <a class="reference internal" href="#collect"><span class="std std-doc">collect</span></a>, <a class="reference internal" href="#grouptuple"><span class="std std-doc">groupTuple</span></a>, <a class="reference internal" href="#reduce"><span class="std std-doc">reduce</span></a></p></li>
<li><p>Parsing text data: <a class="reference internal" href="#splitcsv"><span class="std std-doc">splitCsv</span></a>, <a class="reference internal" href="#splitjson"><span class="std std-doc">splitJson</span></a>, <a class="reference internal" href="#splittext"><span class="std std-doc">splitText</span></a></p></li>
<li><p>Combining channels: <a class="reference internal" href="#combine"><span class="std std-doc">combine</span></a>, <a class="reference internal" href="#concat"><span class="std std-doc">concat</span></a>, <a class="reference internal" href="#join"><span class="std std-doc">join</span></a>, <a class="reference internal" href="#mix"><span class="std std-doc">mix</span></a></p></li>
<li><p>Forking channels: <a class="reference internal" href="#branch"><span class="std std-doc">branch</span></a>, <a class="reference internal" href="#multimap"><span class="std std-doc">multiMap</span></a></p></li>
<li><p>Maths: <a class="reference internal" href="#count"><span class="std std-doc">count</span></a>, <a class="reference internal" href="#max"><span class="std std-doc">max</span></a>, <a class="reference internal" href="#min"><span class="std std-doc">min</span></a>, <a class="reference internal" href="#sum"><span class="std std-doc">sum</span></a></p></li>
<li><p>Other: <a class="reference internal" href="#ifempty"><span class="std std-doc">ifEmpty</span></a>, <a class="reference internal" href="#map"><span class="std std-doc">map</span></a>, <a class="reference internal" href="#set"><span class="std std-doc">set</span></a>, <a class="reference internal" href="#view"><span class="std std-doc">view</span></a></p></li>
</ul>
<section id="branch">
<span id="operator-branch"></span><h2>branch<a class="headerlink" href="#branch" title="Permalink to this heading"></a></h2>
<div class="versionadded">
<p><span class="versionmodified added">New in version 19.08.0-edge.</span></p>
</div>
<p><em>Returns: map of queue channels</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">branch</span></code> operator allows you to forward the items emitted by a source channel to one or more output channels, choosing one out of them at a time.</p>
<p>The selection criteria is defined by specifying a <a class="reference internal" href="script.html#script-closure"><span class="std std-ref">closure</span></a> that provides one or more boolean expression, each of which is identified by a unique label. On the first expression that evaluates to a <em>true</em> value, the current item is bound to a named channel as the label identifier. For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mi">40</span><span class="o">,</span><span class="w"> </span><span class="mi">50</span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">branch</span><span class="w"> </span><span class="o">{</span>
<span class="w">        </span><span class="nl">small:</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span>
<span class="w">        </span><span class="nl">large:</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">10</span>
<span class="w">    </span><span class="o">}</span>
<span class="w">    </span><span class="o">.</span><span class="na">set</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">}</span>

<span class="w"> </span><span class="n">result</span><span class="o">.</span><span class="na">small</span><span class="o">.</span><span class="na">view</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="s2">&quot;$it is small&quot;</span><span class="w"> </span><span class="o">}</span>
<span class="w"> </span><span class="n">result</span><span class="o">.</span><span class="na">large</span><span class="o">.</span><span class="na">view</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="s2">&quot;$it is large&quot;</span><span class="w"> </span><span class="o">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span> <span class="ow">is</span> <span class="n">small</span>
<span class="mi">2</span> <span class="ow">is</span> <span class="n">small</span>
<span class="mi">3</span> <span class="ow">is</span> <span class="n">small</span>
<span class="mi">40</span> <span class="ow">is</span> <span class="n">large</span>
<span class="mi">50</span> <span class="ow">is</span> <span class="n">large</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The above <em>small</em> and <em>large</em> strings may be printed in any order due to the asynchronous execution of the <code class="docutils literal notranslate"><span class="pre">view</span></code> operator.</p>
</div>
<p>A default fallback condition can be specified using <code class="docutils literal notranslate"><span class="pre">true</span></code> as the last branch condition:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mi">40</span><span class="o">,</span><span class="w"> </span><span class="mi">50</span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">branch</span><span class="w"> </span><span class="o">{</span>
<span class="w">        </span><span class="nl">small:</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span>
<span class="w">        </span><span class="nl">large:</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">50</span>
<span class="w">        </span><span class="nl">other:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">    </span><span class="o">}</span>
</pre></div>
</div>
<p>The value returned by each branch condition can be customised by specifying an optional expression statement(s) just after the condition expression. For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mi">40</span><span class="o">,</span><span class="w"> </span><span class="mi">50</span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">branch</span><span class="w"> </span><span class="o">{</span>
<span class="w">        </span><span class="nl">foo:</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">it</span><span class="o">+</span><span class="mi">2</span>

<span class="w">        </span><span class="nl">bar:</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">50</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">it</span><span class="o">-</span><span class="mi">2</span>

<span class="w">        </span><span class="nl">other:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span>
<span class="w">    </span><span class="o">}</span>
</pre></div>
</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>When the <code class="docutils literal notranslate"><span class="pre">return</span></code> keyword is omitted, the value of the last expression statement is implicitly returned.</p>
</div>
<p>To create a branch criteria as variable that can be passed as an argument to more than one <code class="docutils literal notranslate"><span class="pre">branch</span></code> operator use the <code class="docutils literal notranslate"><span class="pre">branchCriteria</span></code> built-in method as shown below:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="kt">def</span><span class="w"> </span><span class="n">criteria</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">branchCriteria</span><span class="w"> </span><span class="o">{</span>
<span class="w">    </span><span class="nl">small:</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span>
<span class="w">    </span><span class="nl">large:</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">10</span>
<span class="o">}</span>

<span class="n">Channel</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">30</span><span class="o">).</span><span class="na">branch</span><span class="o">(</span><span class="n">criteria</span><span class="o">).</span><span class="na">set</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">ch1</span><span class="w"> </span><span class="o">}</span>
<span class="n">Channel</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span><span class="w"> </span><span class="mi">20</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">).</span><span class="na">branch</span><span class="o">(</span><span class="n">criteria</span><span class="o">).</span><span class="na">set</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">ch2</span><span class="w"> </span><span class="o">}</span>
</pre></div>
</div>
</section>
<section id="buffer">
<h2>buffer<a class="headerlink" href="#buffer" title="Permalink to this heading"></a></h2>
<p><em>Returns: queue channel</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">buffer</span></code> operator gathers the items emitted by the source channel into subsets and emits these subsets separately.</p>
<p>There are a number of ways you can regulate how <code class="docutils literal notranslate"><span class="pre">buffer</span></code> gathers the items from the source channel into subsets:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">buffer(</span> <span class="pre">closingCondition</span> <span class="pre">)</span></code>: starts to collect the items emitted by the channel into a subset until the <code class="docutils literal notranslate"><span class="pre">closingCondition</span></code> is verified. After that the subset is emitted to the resulting channel and new items are gathered into a new subset. The process is repeated until the last value in the source channel is sent. The <code class="docutils literal notranslate"><span class="pre">closingCondition</span></code> can be specified either as a <a class="reference internal" href="script.html#script-regexp"><span class="std std-ref">regular expression</span></a>, a Java class, a literal value, or a boolean predicate that has to be satisfied. For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">buffer</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>

<span class="c1">// emitted values</span>
<span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span>
<span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">buffer(</span> <span class="pre">openingCondition,</span> <span class="pre">closingCondition</span> <span class="pre">)</span></code>: starts to gather the items emitted by the channel as soon as one of the them verify the <code class="docutils literal notranslate"><span class="pre">openingCondition</span></code> and it continues until there is one item which verify the <code class="docutils literal notranslate"><span class="pre">closingCondition</span></code>. After that the subset is emitted and it continues applying the described logic until the last channel item is emitted. Both conditions can be defined either as a <a class="reference internal" href="script.html#script-regexp"><span class="std std-ref">regular expression</span></a>, a literal value, a Java class, or a boolean predicate that need to be satisfied. For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mi">4</span><span class="o">,</span><span class="w"> </span><span class="mi">5</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mi">4</span><span class="o">,</span><span class="w"> </span><span class="mi">5</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">buffer</span><span class="o">(</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>

<span class="c1">// emits bundles starting with &#39;2&#39; and ending with&#39;4&#39;</span>
<span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span>
<span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">buffer(</span> <span class="pre">size:</span> <span class="pre">n</span> <span class="pre">)</span></code>: transform the source channel in such a way that it emits tuples made up of <code class="docutils literal notranslate"><span class="pre">n</span></code> elements. An incomplete tuple is discarded. For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">buffer</span><span class="o">(</span><span class="w"> </span><span class="nl">size:</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>

<span class="c1">// emitted values</span>
<span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">]</span>
<span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">]</span>
<span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">]</span>
</pre></div>
</div>
<p>If you want to emit the last items in a tuple containing less than <code class="docutils literal notranslate"><span class="pre">n</span></code> elements, simply add the parameter <code class="docutils literal notranslate"><span class="pre">remainder</span></code> specifying <code class="docutils literal notranslate"><span class="pre">true</span></code>, for example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">buffer</span><span class="o">(</span><span class="w"> </span><span class="nl">size:</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="nl">remainder:</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>

<span class="c1">// emitted values</span>
<span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">]</span>
<span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">]</span>
<span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">]</span>
<span class="o">[</span><span class="mi">1</span><span class="o">]</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">buffer(</span> <span class="pre">size:</span> <span class="pre">n,</span> <span class="pre">skip:</span> <span class="pre">m</span> <span class="pre">)</span></code>: as in the previous example, it emits tuples containing <code class="docutils literal notranslate"><span class="pre">n</span></code> elements, but skips <code class="docutils literal notranslate"><span class="pre">m</span></code> values before starting to collect the values for the next tuple (including the first emission). For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mi">4</span><span class="o">,</span><span class="w"> </span><span class="mi">5</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mi">4</span><span class="o">,</span><span class="w"> </span><span class="mi">5</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">buffer</span><span class="o">(</span><span class="w"> </span><span class="nl">size:</span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="nl">skip:</span><span class="mi">2</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>

<span class="c1">// emitted values</span>
<span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mi">4</span><span class="o">,</span><span class="w"> </span><span class="mi">5</span><span class="o">]</span>
<span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mi">4</span><span class="o">,</span><span class="w"> </span><span class="mi">5</span><span class="o">]</span>
</pre></div>
</div>
<p>If you want to emit the remaining items in a tuple containing less than <code class="docutils literal notranslate"><span class="pre">n</span></code> elements, simply add the parameter <code class="docutils literal notranslate"><span class="pre">remainder</span></code> specifying <code class="docutils literal notranslate"><span class="pre">true</span></code>, as shown in the previous example.</p>
</li>
</ul>
<p>See also: <a class="reference internal" href="#collate"><span class="std std-doc">collate</span></a> operator.</p>
</section>
<section id="collate">
<h2>collate<a class="headerlink" href="#collate" title="Permalink to this heading"></a></h2>
<p><em>Returns: queue channel</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">collate</span></code> operator transforms a channel in such a way that the emitted values are grouped in tuples containing <code class="docutils literal notranslate"><span class="pre">n</span></code> items. For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">collate</span><span class="o">(</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>As shown in the above example the last tuple may be incomplete e.g. contain fewer elements than the specified size. If you want to avoid this, specify <code class="docutils literal notranslate"><span class="pre">false</span></code> as the second parameter. For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">collate</span><span class="o">(</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
<p>A second version of the <code class="docutils literal notranslate"><span class="pre">collate</span></code> operator allows you to specify, after the <code class="docutils literal notranslate"><span class="pre">size</span></code>, the <code class="docutils literal notranslate"><span class="pre">step</span></code> by which elements are collected in tuples. For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">collate</span><span class="o">(</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="p">[</span><span class="mi">4</span><span class="p">]</span>
</pre></div>
</div>
<p>As before, if you don’t want to emit the last items which do not complete a tuple, specify <code class="docutils literal notranslate"><span class="pre">false</span></code> as the third parameter.</p>
<p>See also: <a class="reference internal" href="#buffer"><span class="std std-doc">buffer</span></a> operator.</p>
</section>
<section id="collect">
<span id="operator-collect"></span><h2>collect<a class="headerlink" href="#collect" title="Permalink to this heading"></a></h2>
<p><em>Returns: value channel</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">collect</span></code> operator collects all the items emitted by a channel to a <code class="docutils literal notranslate"><span class="pre">List</span></code> and return the resulting object as a sole emission. For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">collect</span><span class="o">()</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
</pre></div>
</div>
<p>An optional <a class="reference internal" href="script.html#script-closure"><span class="std std-ref">closure</span></a> can be specified to transform each item before adding it to the resulting list. For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="w"> </span><span class="s1">&#39;hello&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;ciao&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;bonjour&#39;</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">collect</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">it</span><span class="o">.</span><span class="na">length</span><span class="o">()</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
</pre></div>
</div>
<p>Available options:</p>
<dl class="simple myst">
<dt><code class="docutils literal notranslate"><span class="pre">flat</span></code></dt><dd><p>When <code class="docutils literal notranslate"><span class="pre">true</span></code> nested list structures are normalised and their items are added to the resulting list object (default: <code class="docutils literal notranslate"><span class="pre">true</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sort</span></code></dt><dd><p>When <code class="docutils literal notranslate"><span class="pre">true</span></code> the items in the resulting list are sorted by their natural ordering. It is possible to provide a custom ordering criteria by using either a <a class="reference internal" href="script.html#script-closure"><span class="std std-ref">closure</span></a> or a <a class="reference external" href="https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html">Comparator</a> object (default: <code class="docutils literal notranslate"><span class="pre">false</span></code>).</p>
</dd>
</dl>
<p>See also: <a class="reference internal" href="#tolist"><span class="std std-doc">toList</span></a> and <a class="reference internal" href="#tosortedlist"><span class="std std-doc">toSortedList</span></a> operator.</p>
</section>
<section id="collectfile">
<h2>collectFile<a class="headerlink" href="#collectfile" title="Permalink to this heading"></a></h2>
<p><em>Returns: queue channel</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">collectFile</span></code> operator allows you to gather the items emitted by a channel and save them to one or more files. The operator returns a new channel that emits the collected file(s).</p>
<p>In the simplest case, just specify the name of a file where the entries have to be stored. For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s1">&#39;alpha&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;beta&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;gamma&#39;</span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">collectFile</span><span class="o">(</span><span class="nl">name:</span><span class="w"> </span><span class="s1">&#39;sample.txt&#39;</span><span class="o">,</span><span class="w"> </span><span class="nl">newLine:</span><span class="w"> </span><span class="kc">true</span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">subscribe</span><span class="w"> </span><span class="o">{</span>
<span class="w">        </span><span class="n">println</span><span class="w"> </span><span class="s2">&quot;Entries are saved to file: $it&quot;</span>
<span class="w">        </span><span class="n">println</span><span class="w"> </span><span class="s2">&quot;File content is: ${it.text}&quot;</span>
<span class="w">    </span><span class="o">}</span>
</pre></div>
</div>
<p>A second version of the <code class="docutils literal notranslate"><span class="pre">collectFile</span></code> operator allows you to gather the items emitted by a channel and group them together into files whose name can be defined by a dynamic criteria. The grouping criteria is specified by a <a class="reference internal" href="script.html#script-closure"><span class="std std-ref">closure</span></a> that must return a pair in which the first element defines the file name for the group and the second element the actual value to be appended to that file. For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s1">&#39;Hola&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;Ciao&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;Hello&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;Bonjour&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;Halo&#39;</span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">collectFile</span><span class="o">()</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">        </span><span class="o">[</span><span class="w"> </span><span class="s2">&quot;${item[0]}.txt&quot;</span><span class="o">,</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s1">&#39;\n&#39;</span><span class="w"> </span><span class="o">]</span>
<span class="w">    </span><span class="o">}</span>
<span class="w">    </span><span class="o">.</span><span class="na">subscribe</span><span class="w"> </span><span class="o">{</span>
<span class="w">        </span><span class="n">println</span><span class="w"> </span><span class="s2">&quot;File ${it.name} contains:&quot;</span>
<span class="w">        </span><span class="n">println</span><span class="w"> </span><span class="n">it</span><span class="o">.</span><span class="na">text</span>
<span class="w">    </span><span class="o">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">File</span> <span class="s1">&#39;B.txt&#39;</span> <span class="n">contains</span><span class="p">:</span>
<span class="n">Bonjour</span>

<span class="n">File</span> <span class="s1">&#39;C.txt&#39;</span> <span class="n">contains</span><span class="p">:</span>
<span class="n">Ciao</span>

<span class="n">File</span> <span class="s1">&#39;H.txt&#39;</span> <span class="n">contains</span><span class="p">:</span>
<span class="n">Halo</span>
<span class="n">Hola</span>
<span class="n">Hello</span>
</pre></div>
</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>When the items emitted by the source channel are files, the grouping criteria can be omitted. In this case the items content will be grouped into file(s) having the same name as the source items.</p>
</div>
<p>Available options:</p>
<dl class="simple myst">
<dt><code class="docutils literal notranslate"><span class="pre">cache</span></code></dt><dd><p>Controls the caching ability of the <code class="docutils literal notranslate"><span class="pre">collectFile</span></code> operator when using the <em>resume</em> feature. It follows the same semantic of the <a class="reference internal" href="process.html#process-cache"><span class="std std-ref">cache</span></a> directive (default: <code class="docutils literal notranslate"><span class="pre">true</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">keepHeader</span></code></dt><dd><p>Prepend the resulting file with the header fetched in the first collected file. The header size (ie. lines) can be specified by using the <code class="docutils literal notranslate"><span class="pre">skip</span></code> parameter (default: <code class="docutils literal notranslate"><span class="pre">false</span></code>), to determine how many lines to remove from all collected files except for the first (where no lines will be removed).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>Name of the file where all received values are stored.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">newLine</span></code></dt><dd><p>Appends a <code class="docutils literal notranslate"><span class="pre">newline</span></code> character automatically after each entry (default: <code class="docutils literal notranslate"><span class="pre">false</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">seed</span></code></dt><dd><p>A value or a map of values used to initialise the files content.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skip</span></code></dt><dd><p>Skip the first <code class="docutils literal notranslate"><span class="pre">n</span></code> lines e.g. <code class="docutils literal notranslate"><span class="pre">skip:</span> <span class="pre">1</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sort</span></code></dt><dd><p>Defines sorting criteria of content in resulting file(s). Can be one of the following values:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">false</span></code>: Disable content sorting. Entries are appended as they are produced.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">true</span></code>: Order the content by the entry’s natural ordering i.e. numerical for number, lexicographic for string, etc. See the <a class="reference external" href="http://docs.oracle.com/javase/tutorial/collections/interfaces/order.html">Java documentation</a> for more information.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'index'</span></code>: Order the content by the incremental index number assigned to each entry while they are collected.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'hash'</span></code>: (default) Order the content by the hash number associated to each entry</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'deep'</span></code>: Similar to the previous, but the hash number is created on actual entries content e.g. when the entry is a file the hash is created on the actual file content.</p></li>
<li><p>A custom sorting criteria can be specified by using either a <a class="reference internal" href="script.html#script-closure"><span class="std std-ref">Closure</span></a> or a <a class="reference external" href="http://docs.oracle.com/javase/7/docs/api/java/util/Comparator.html">Comparator</a> object.</p></li>
</ul>
<p>The file content is sorted in such a way that it does not depend on the order in which entries were added to it, which guarantees that it is consistent (i.e. does not change) across different executions with the same data.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">storeDir</span></code></dt><dd><p>Folder where the resulting file(s) are be stored.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tempDir</span></code></dt><dd><p>Folder where temporary files, used by the collecting process, are stored.</p>
</dd>
</dl>
<p>The following snippet shows how sort the content of the result file alphabetically:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s1">&#39;Z&#39;</span><span class="o">..</span><span class="s1">&#39;A&#39;</span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">collectFile</span><span class="o">(</span><span class="nl">name:</span><span class="s1">&#39;result&#39;</span><span class="o">,</span><span class="w"> </span><span class="nl">sort:</span><span class="w"> </span><span class="kc">true</span><span class="o">,</span><span class="w"> </span><span class="nl">newLine:</span><span class="w"> </span><span class="kc">true</span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">it</span><span class="o">.</span><span class="na">text</span><span class="w"> </span><span class="o">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span>
<span class="n">B</span>
<span class="n">C</span>
<span class="p">:</span>
<span class="n">Z</span>
</pre></div>
</div>
<p>The following example shows how use a <code class="docutils literal notranslate"><span class="pre">closure</span></code> to collect and sort all sequences in a FASTA file from shortest to longest:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">fromPath</span><span class="o">(</span><span class="s1">&#39;/data/sequences.fa&#39;</span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">splitFasta</span><span class="o">(</span><span class="w"> </span><span class="nl">record:</span><span class="w"> </span><span class="o">[</span><span class="nl">id:</span><span class="w"> </span><span class="kc">true</span><span class="o">,</span><span class="w"> </span><span class="nl">sequence:</span><span class="w"> </span><span class="kc">true</span><span class="o">]</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">collectFile</span><span class="o">(</span><span class="w"> </span><span class="nl">name:</span><span class="s1">&#39;result.fa&#39;</span><span class="o">,</span><span class="w"> </span><span class="nl">sort:</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">it</span><span class="o">.</span><span class="na">size</span><span class="o">()</span><span class="w"> </span><span class="o">}</span><span class="w"> </span><span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">        </span><span class="n">it</span><span class="o">.</span><span class="na">sequence</span>
<span class="w">    </span><span class="o">}</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">it</span><span class="o">.</span><span class="na">text</span><span class="w"> </span><span class="o">}</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The <code class="docutils literal notranslate"><span class="pre">collectFile</span></code> operator needs to store files in a temporary folder that is automatically deleted on workflow completion. For performance reasons this folder is located in the machine’s local storage, and it will require as much free space as the data that is being collected. Optionally, a different temporary data folder can be specified by using the <code class="docutils literal notranslate"><span class="pre">tempDir</span></code> parameter.</p>
</div>
</section>
<section id="combine">
<span id="operator-combine"></span><h2>combine<a class="headerlink" href="#combine" title="Permalink to this heading"></a></h2>
<p><em>Returns: queue channel</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">combine</span></code> operator combines (cartesian product) the items emitted by two channels or by a channel and a <code class="docutils literal notranslate"><span class="pre">Collection</span></code> object (as right operand). For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">numbers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Channel</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">)</span>
<span class="n">words</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Channel</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s1">&#39;hello&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;ciao&#39;</span><span class="o">)</span>
<span class="n">numbers</span>
<span class="w">    </span><span class="o">.</span><span class="na">combine</span><span class="o">(</span><span class="n">words</span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">hello</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">hello</span><span class="p">]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="n">hello</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">ciao</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">ciao</span><span class="p">]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="n">ciao</span><span class="p">]</span>
</pre></div>
</div>
<p>A second version of the <code class="docutils literal notranslate"><span class="pre">combine</span></code> operator allows you to combine items that share a common matching key. The index of the key element is specified by using the <code class="docutils literal notranslate"><span class="pre">by</span></code> parameter (zero-based index, multiple indices can be specified as a list of integers). For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Channel</span><span class="o">.</span><span class="na">of</span><span class="o">([</span><span class="s1">&#39;A&#39;</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">],</span><span class="w"> </span><span class="o">[</span><span class="s1">&#39;B&#39;</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">],</span><span class="w"> </span><span class="o">[</span><span class="s1">&#39;A&#39;</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">])</span>
<span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Channel</span><span class="o">.</span><span class="na">of</span><span class="o">([</span><span class="s1">&#39;B&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;x&#39;</span><span class="o">],</span><span class="w"> </span><span class="o">[</span><span class="s1">&#39;B&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;y&#39;</span><span class="o">],</span><span class="w"> </span><span class="o">[</span><span class="s1">&#39;A&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;z&#39;</span><span class="o">],</span><span class="w"> </span><span class="o">[</span><span class="s1">&#39;A&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;w&#39;</span><span class="o">])</span>

<span class="n">left</span>
<span class="w">    </span><span class="o">.</span><span class="na">combine</span><span class="o">(</span><span class="n">right</span><span class="o">,</span><span class="w"> </span><span class="nl">by:</span><span class="w"> </span><span class="mi">0</span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">z</span><span class="p">]</span>
<span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">z</span><span class="p">]</span>
<span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">w</span><span class="p">]</span>
<span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">w</span><span class="p">]</span>
<span class="p">[</span><span class="n">B</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span>
<span class="p">[</span><span class="n">B</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span>
</pre></div>
</div>
<p>See also <a class="reference internal" href="#join"><span class="std std-doc">join</span></a> and <a class="reference internal" href="#cross"><span class="std std-doc">cross</span></a>.</p>
</section>
<section id="concat">
<span id="operator-concat"></span><h2>concat<a class="headerlink" href="#concat" title="Permalink to this heading"></a></h2>
<p><em>Returns: queue channel</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">concat</span></code> operator allows you to <em>concatenate</em> the items emitted by two or more channels to a new channel. The items emitted by the resulting channel are in the same order as specified in the operator arguments.</p>
<p>In other words, given <em>N</em> channels, the items from the <em>i+1 th</em> channel are emitted only after all of the items from the <em>i th</em> channel have been emitted.</p>
<p>For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Channel</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s1">&#39;a&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;b&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;c&#39;</span><span class="o">)</span>
<span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Channel</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">)</span>
<span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Channel</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s1">&#39;p&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;q&#39;</span><span class="o">)</span>

<span class="n">c</span><span class="o">.</span><span class="na">concat</span><span class="o">(</span><span class="w"> </span><span class="n">b</span><span class="o">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">).</span><span class="na">view</span><span class="o">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p</span>
<span class="n">q</span>
<span class="mi">1</span>
<span class="mi">2</span>
<span class="mi">3</span>
<span class="n">a</span>
<span class="n">b</span>
<span class="n">c</span>
</pre></div>
</div>
</section>
<section id="count">
<span id="operator-count"></span><h2>count<a class="headerlink" href="#count" title="Permalink to this heading"></a></h2>
<p><em>Returns: value channel</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">count</span></code> operator creates a channel that emits a single item: a number that represents the total number of items emitted by the source channel. For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">9</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">5</span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">count</span><span class="o">()</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>
<span class="c1">// -&gt; 4</span>
</pre></div>
</div>
<p>An optional parameter can be provided to select which items are to be counted. The selection criteria can be specified either as a <a class="reference internal" href="script.html#script-regexp"><span class="std std-ref">regular expression</span></a>, a literal value, a Java class, or a boolean predicate that needs to be satisfied. For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">count</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>
<span class="c1">// -&gt; 3</span>

<span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s1">&#39;a&#39;</span><span class="o">,</span><span class="s1">&#39;c&#39;</span><span class="o">,</span><span class="s1">&#39;c&#39;</span><span class="o">,</span><span class="s1">&#39;q&#39;</span><span class="o">,</span><span class="s1">&#39;b&#39;</span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">count</span><span class="w"> </span><span class="o">(</span><span class="w"> </span><span class="o">~</span><span class="s">/c/</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>
<span class="c1">// -&gt; 2</span>

<span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s1">&#39;a&#39;</span><span class="o">,</span><span class="s1">&#39;c&#39;</span><span class="o">,</span><span class="s1">&#39;c&#39;</span><span class="o">,</span><span class="s1">&#39;q&#39;</span><span class="o">,</span><span class="s1">&#39;b&#39;</span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">count</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="s1">&#39;c&#39;</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>
<span class="c1">// -&gt; 4</span>
</pre></div>
</div>
</section>
<section id="countfasta">
<span id="operator-countfasta"></span><h2>countFasta<a class="headerlink" href="#countfasta" title="Permalink to this heading"></a></h2>
<p><em>Returns: value channel</em></p>
<p>Counts the total number of records in a channel of FASTA files, equivalent to <code class="docutils literal notranslate"><span class="pre">splitFasta</span> <span class="pre">|</span> <span class="pre">count</span></code>. See <a class="reference internal" href="#splitfasta"><span class="std std-doc">splitFasta</span></a> for the list of available options.</p>
</section>
<section id="countfastq">
<span id="operator-countfastq"></span><h2>countFastq<a class="headerlink" href="#countfastq" title="Permalink to this heading"></a></h2>
<p><em>Returns: value channel</em></p>
<p>Counts the total number of records in a channel of FASTQ files, equivalent to <code class="docutils literal notranslate"><span class="pre">splitFastq</span> <span class="pre">|</span> <span class="pre">count</span></code>. See <a class="reference internal" href="#splitfastq"><span class="std std-doc">splitFastq</span></a> for the list of available options.</p>
</section>
<section id="countjson">
<span id="operator-countjson"></span><h2>countJson<a class="headerlink" href="#countjson" title="Permalink to this heading"></a></h2>
<p><em>Returns: value channel</em></p>
<p>Counts the total number of records in a channel of JSON files, equivalent to <code class="docutils literal notranslate"><span class="pre">splitJson</span> <span class="pre">|</span> <span class="pre">count</span></code>. See <a class="reference internal" href="#splitjson"><span class="std std-doc">splitJson</span></a> for the list of available options.</p>
</section>
<section id="countlines">
<span id="operator-countlines"></span><h2>countLines<a class="headerlink" href="#countlines" title="Permalink to this heading"></a></h2>
<p><em>Returns: value channel</em></p>
<p>Counts the total number of lines in a channel of text files, equivalent to <code class="docutils literal notranslate"><span class="pre">splitText</span> <span class="pre">|</span> <span class="pre">count</span></code>. See <a class="reference internal" href="#splittext"><span class="std std-doc">splitLines</span></a> for the list of available options.</p>
</section>
<section id="cross">
<span id="operator-cross"></span><h2>cross<a class="headerlink" href="#cross" title="Permalink to this heading"></a></h2>
<p><em>Returns: queue channel</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">cross</span></code> operator allows you to combine the items of two channels in such a way that the items of the source channel are emitted along with the items emitted by the target channel for which they have a matching key.</p>
<p>The key is defined, by default, as the first entry in an array, a list or map object, or the value itself for any other data type. For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">source</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Channel</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="w"> </span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;alpha&#39;</span><span class="o">],</span><span class="w"> </span><span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;beta&#39;</span><span class="o">]</span><span class="w"> </span><span class="o">)</span>
<span class="n">target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Channel</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="w"> </span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;x&#39;</span><span class="o">],</span><span class="w"> </span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;y&#39;</span><span class="o">],</span><span class="w"> </span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;z&#39;</span><span class="o">],</span><span class="w"> </span><span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;p&#39;</span><span class="o">],</span><span class="w"> </span><span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;q&#39;</span><span class="o">],</span><span class="w"> </span><span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;t&#39;</span><span class="o">]</span><span class="w"> </span><span class="o">)</span>

<span class="n">source</span><span class="o">.</span><span class="na">cross</span><span class="o">(</span><span class="n">target</span><span class="o">).</span><span class="na">view</span><span class="o">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">alpha</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="p">]</span>
<span class="p">[</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">alpha</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="p">]</span>
<span class="p">[</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">alpha</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">z</span><span class="p">]</span> <span class="p">]</span>
<span class="p">[</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">beta</span><span class="p">],</span>  <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span> <span class="p">]</span>
<span class="p">[</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">beta</span><span class="p">],</span>  <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span> <span class="p">]</span>
<span class="p">[</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">beta</span><span class="p">],</span>  <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="p">]</span>
</pre></div>
</div>
<p>The above example shows how the items emitted by the source channels are associated to the ones emitted by the target channel (on the right) having the same key.</p>
<p>There are two important caveats when using the <code class="docutils literal notranslate"><span class="pre">cross</span></code> operator:</p>
<ol class="arabic simple">
<li><p>The operator is not <code class="docutils literal notranslate"><span class="pre">commutative</span></code>, i.e. the result of <code class="docutils literal notranslate"><span class="pre">a.cross(b)</span></code> is different from <code class="docutils literal notranslate"><span class="pre">b.cross(a)</span></code></p></li>
<li><p>The source channel should emits items for which there’s no key repetition i.e. the emitted items have an unique key identifier.</p></li>
</ol>
<p>Optionally, a mapping function can be specified in order to provide a custom rule to associate an item to a key.</p>
</section>
<section id="distinct">
<h2>distinct<a class="headerlink" href="#distinct" title="Permalink to this heading"></a></h2>
<p><em>Returns: queue channel</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">distinct</span></code> operator allows you to remove <em>consecutive</em> duplicated items from a channel, so that each emitted item is different from the preceding one. For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">distinct</span><span class="o">()</span>
<span class="w">    </span><span class="o">.</span><span class="na">subscribe</span><span class="w"> </span><span class="nl">onNext:</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">println</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">},</span><span class="w"> </span><span class="nl">onComplete:</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">println</span><span class="w"> </span><span class="s1">&#39;Done&#39;</span><span class="w"> </span><span class="o">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span>
<span class="mi">2</span>
<span class="mi">3</span>
<span class="mi">1</span>
<span class="mi">2</span>
<span class="mi">3</span>
<span class="n">Done</span>
</pre></div>
</div>
<p>You can also specify an optional <a class="reference internal" href="script.html#script-closure"><span class="std std-ref">closure</span></a> that customizes the way it distinguishes between distinct items. For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">6</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">distinct</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="o">.</span><span class="na">subscribe</span><span class="w"> </span><span class="nl">onNext:</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">println</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">},</span><span class="w"> </span><span class="nl">onComplete:</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">println</span><span class="w"> </span><span class="s1">&#39;Done&#39;</span><span class="w"> </span><span class="o">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span>
<span class="mi">2</span>
<span class="mi">3</span>
<span class="mi">2</span>
<span class="n">Done</span>
</pre></div>
</div>
</section>
<section id="dump">
<span id="operator-dump"></span><h2>dump<a class="headerlink" href="#dump" title="Permalink to this heading"></a></h2>
<p><em>Returns: queue channel or value channel, depending on the input</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">dump</span></code> operator prints the items emitted by the channel to which is applied only when the option <code class="docutils literal notranslate"><span class="pre">-dump-channels</span></code> is specified on the <code class="docutils literal notranslate"><span class="pre">run</span></code> command line, otherwise it is ignored.</p>
<p>This is useful to enable the debugging of one or more channel content on-demand by using a command line option instead of modifying your script code.</p>
<p>An optional <code class="docutils literal notranslate"><span class="pre">tag</span></code> parameter allows you to select which channel to dump. For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">map</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">it</span><span class="o">+</span><span class="mi">1</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="o">.</span><span class="na">dump</span><span class="o">(</span><span class="nl">tag:</span><span class="w"> </span><span class="s1">&#39;foo&#39;</span><span class="o">)</span>

<span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">map</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">it</span><span class="o">^</span><span class="mi">2</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="o">.</span><span class="na">dump</span><span class="o">(</span><span class="nl">tag:</span><span class="w"> </span><span class="s1">&#39;bar&#39;</span><span class="o">)</span>
</pre></div>
</div>
<p>Then you will be able to specify the tag <code class="docutils literal notranslate"><span class="pre">foo</span></code> or <code class="docutils literal notranslate"><span class="pre">bar</span></code> as an argument of the <code class="docutils literal notranslate"><span class="pre">-dump-channels</span></code> option to print either the content of the first or the second channel. Multiple tag names can be specified separating them with a <code class="docutils literal notranslate"><span class="pre">,</span></code> character.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 22.10.0: </span>The output can be formatted by enabling the <code class="docutils literal notranslate"><span class="pre">pretty</span></code> option:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">fromSRA</span><span class="o">(</span><span class="s1">&#39;SRP043510&#39;</span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">dump</span><span class="o">(</span><span class="nl">tag:</span><span class="w"> </span><span class="s1">&#39;foo&#39;</span><span class="o">,</span><span class="w"> </span><span class="nl">pretty:</span><span class="w"> </span><span class="kc">true</span><span class="o">)</span>
</pre></div>
</div>
</div>
</section>
<section id="filter">
<h2>filter<a class="headerlink" href="#filter" title="Permalink to this heading"></a></h2>
<p><em>Returns: queue channel</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">filter</span></code> operator allows you to get only the items emitted by a channel that satisfy a condition and discarding all the others. The filtering condition can be specified by using either a <a class="reference internal" href="script.html#script-regexp"><span class="std std-ref">regular expression</span></a>, a literal value, a type qualifier (i.e. a Java class) or any boolean predicate.</p>
<p>The following example shows how to filter a channel by using a regular expression that returns only strings that begin with <code class="docutils literal notranslate"><span class="pre">a</span></code>:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="w"> </span><span class="s1">&#39;a&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;b&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;aa&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;bc&#39;</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mf">4.5</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="w"> </span><span class="o">~</span><span class="s">/^a.*/</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span>
<span class="n">aa</span>
</pre></div>
</div>
<p>The following example shows how to filter a channel by specifying the type qualifier <code class="docutils literal notranslate"><span class="pre">Number</span></code> so that only numbers are returned:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="w"> </span><span class="s1">&#39;a&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;b&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;aa&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;bc&#39;</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mf">4.5</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="w"> </span><span class="n">Number</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">3</span>
<span class="mf">4.5</span>
</pre></div>
</div>
<p>Finally, a filtering condition can be defined by using any a boolean predicate. A predicate is expressed by a <a class="reference internal" href="script.html#script-closure"><span class="std std-ref">closure</span></a> returning a boolean value. For example the following fragment shows how filter a channel emitting numbers so that the odd values are returned:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mi">4</span><span class="o">,</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">filter</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span>
<span class="mi">3</span>
<span class="mi">5</span>
</pre></div>
</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>In the above example the filter condition is wrapped in curly brackets, instead of parentheses, because it specifies a <a class="reference internal" href="script.html#script-closure"><span class="std std-ref">closure</span></a> as the operator’s argument. In reality it is just syntactic sugar for <code class="docutils literal notranslate"><span class="pre">filter({</span> <span class="pre">it</span> <span class="pre">%</span> <span class="pre">2</span> <span class="pre">==</span> <span class="pre">1</span> <span class="pre">})</span></code></p>
</div>
</section>
<section id="first">
<span id="operator-first"></span><h2>first<a class="headerlink" href="#first" title="Permalink to this heading"></a></h2>
<p><em>Returns: value channel</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">first</span></code> operator creates a channel that returns the first item emitted by the source channel, or eventually the first item that matches an optional condition. The condition can be specified by using a <a class="reference internal" href="script.html#script-regexp"><span class="std std-ref">regular expression</span></a>, a Java <code class="docutils literal notranslate"><span class="pre">class</span></code> type or any boolean predicate. For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="c1">// no condition is specified, emits the very first item: 1</span>
<span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">first</span><span class="o">()</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>

<span class="c1">// emits the first String value: &#39;a&#39;</span>
<span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;a&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;b&#39;</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">first</span><span class="o">(</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>

<span class="c1">// emits the first item matching the regular expression: &#39;aa&#39;</span>
<span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="w"> </span><span class="s1">&#39;a&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;aa&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;aaa&#39;</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">first</span><span class="o">(</span><span class="w"> </span><span class="o">~</span><span class="s">/aa.*/</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>

<span class="c1">// emits the first item for which the predicate evaluates to true: 4</span>
<span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">first</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>
</pre></div>
</div>
</section>
<section id="flatmap">
<span id="operator-flatmap"></span><h2>flatMap<a class="headerlink" href="#flatmap" title="Permalink to this heading"></a></h2>
<p><em>Returns: queue channel</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">flatMap</span></code> operator applies a function of your choosing to every item emitted by a channel, and returns the items so obtained as a new channel. Whereas the mapping function returns a list of items, this list is flattened so that each single item is emitted on its own.</p>
<p>For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="c1">// create a channel of numbers</span>
<span class="n">numbers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Channel</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">)</span>

<span class="c1">// map each number to a tuple (array), which items are emitted separately</span>
<span class="n">results</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">numbers</span><span class="o">.</span><span class="na">flatMap</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">[</span><span class="w"> </span><span class="n">n</span><span class="o">*</span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="n">n</span><span class="o">*</span><span class="mi">3</span><span class="w"> </span><span class="o">]</span><span class="w"> </span><span class="o">}</span>

<span class="c1">// print the final results</span>
<span class="n">results</span><span class="o">.</span><span class="na">subscribe</span><span class="w"> </span><span class="nl">onNext:</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">println</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">},</span><span class="w"> </span><span class="nl">onComplete:</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">println</span><span class="w"> </span><span class="s1">&#39;Done&#39;</span><span class="w"> </span><span class="o">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">2</span>
<span class="mi">3</span>
<span class="mi">4</span>
<span class="mi">6</span>
<span class="mi">6</span>
<span class="mi">9</span>
<span class="n">Done</span>
</pre></div>
</div>
<p>Associative arrays are handled in the same way, so that each array entry is emitted as a single key-value pair. For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="w"> </span><span class="o">(</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">flatMap</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">[</span><span class="w"> </span><span class="nl">number:</span><span class="w"> </span><span class="n">it</span><span class="o">,</span><span class="w"> </span><span class="nl">square:</span><span class="w"> </span><span class="n">it</span><span class="o">*</span><span class="n">it</span><span class="w"> </span><span class="o">]</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">it</span><span class="o">.</span><span class="na">key</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s1">&#39;: &#39;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">it</span><span class="o">.</span><span class="na">value</span><span class="w"> </span><span class="o">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">number</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">square</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">number</span><span class="p">:</span> <span class="mi">2</span>
<span class="n">square</span><span class="p">:</span> <span class="mi">4</span>
<span class="n">number</span><span class="p">:</span> <span class="mi">3</span>
<span class="n">square</span><span class="p">:</span> <span class="mi">9</span>
</pre></div>
</div>
</section>
<section id="flatten">
<span id="operator-flatten"></span><h2>flatten<a class="headerlink" href="#flatten" title="Permalink to this heading"></a></h2>
<p><em>Returns: queue channel</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">flatten</span></code> operator transforms a channel in such a way that every item of type <code class="docutils literal notranslate"><span class="pre">Collection</span></code> or <code class="docutils literal notranslate"><span class="pre">Array</span></code> is flattened so that each single entry is emitted separately by the resulting channel. For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="w"> </span><span class="o">[</span><span class="mi">1</span><span class="o">,[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]],</span><span class="w"> </span><span class="mi">4</span><span class="o">,</span><span class="w"> </span><span class="o">[</span><span class="mi">5</span><span class="o">,[</span><span class="mi">6</span><span class="o">]]</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">flatten</span><span class="o">()</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span>
<span class="mi">2</span>
<span class="mi">3</span>
<span class="mi">4</span>
<span class="mi">5</span>
<span class="mi">6</span>
</pre></div>
</div>
<p>See also: <a class="reference internal" href="#flatmap"><span class="std std-doc">flatMap</span></a> operator.</p>
</section>
<section id="grouptuple">
<span id="operator-grouptuple"></span><h2>groupTuple<a class="headerlink" href="#grouptuple" title="Permalink to this heading"></a></h2>
<p><em>Returns: queue channel</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">groupTuple</span></code> operator collects tuples (or lists) of values emitted by the source channel grouping together the elements that share the same key. Finally it emits a new tuple object for each distinct key collected.</p>
<p>In other words, the operator transforms a sequence of tuple like <em>(K, V, W, ..)</em> into a new channel emitting a sequence of <em>(K, list(V), list(W), ..)</em></p>
<p>For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="w"> </span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;A&#39;</span><span class="o">],</span><span class="w"> </span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;B&#39;</span><span class="o">],</span><span class="w"> </span><span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;C&#39;</span><span class="o">],</span><span class="w"> </span><span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;B&#39;</span><span class="o">],</span><span class="w"> </span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;C&#39;</span><span class="o">],</span><span class="w"> </span><span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;A&#39;</span><span class="o">],</span><span class="w"> </span><span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;D&#39;</span><span class="o">]</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">groupTuple</span><span class="o">()</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">]]</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="n">C</span><span class="p">,</span> <span class="n">A</span><span class="p">]]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="n">B</span><span class="p">,</span> <span class="n">D</span><span class="p">]]</span>
</pre></div>
</div>
<p>By default the first entry in the tuple is used as grouping key. A different key can be chosen by using the <code class="docutils literal notranslate"><span class="pre">by</span></code> parameter and specifying the index of the entry to be used as key (the index is zero-based). For example, grouping by the second value in each tuple:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="w"> </span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;A&#39;</span><span class="o">],</span><span class="w"> </span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;B&#39;</span><span class="o">],</span><span class="w"> </span><span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;C&#39;</span><span class="o">],</span><span class="w"> </span><span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;B&#39;</span><span class="o">],</span><span class="w"> </span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;C&#39;</span><span class="o">],</span><span class="w"> </span><span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;A&#39;</span><span class="o">],</span><span class="w"> </span><span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;D&#39;</span><span class="o">]</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">groupTuple</span><span class="o">(</span><span class="nl">by:</span><span class="w"> </span><span class="mi">1</span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">A</span><span class="p">]</span>
<span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">B</span><span class="p">]</span>
<span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">C</span><span class="p">]</span>
<span class="p">[[</span><span class="mi">3</span><span class="p">],</span> <span class="n">D</span><span class="p">]</span>
</pre></div>
</div>
<p>By default, if you don’t specify a size, the <code class="docutils literal notranslate"><span class="pre">groupTuple</span></code> operator will not emit any groups until <em>all</em> inputs have been received. If possible, you should always try to specify the number of expected elements in each group using the <code class="docutils literal notranslate"><span class="pre">size</span></code> option, so that each group can be emitted as soon as it’s ready. In cases where the size of each group varies based on the grouping key, you can use the built-in <code class="docutils literal notranslate"><span class="pre">groupKey</span></code> function, which allows you to create a special grouping key with an associated size:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">chr_frequency</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="w"> </span><span class="s2">&quot;chr1&quot;</span><span class="o">:</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="s2">&quot;chr2&quot;</span><span class="o">:</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">]</span>

<span class="n">Channel</span><span class="o">.</span><span class="na">of</span><span class="o">(</span>
<span class="w">        </span><span class="o">[</span><span class="w"> </span><span class="s1">&#39;region1&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;chr1&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;/path/to/region1_chr1.vcf&#39;</span><span class="w"> </span><span class="o">],</span>
<span class="w">        </span><span class="o">[</span><span class="w"> </span><span class="s1">&#39;region2&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;chr1&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;/path/to/region2_chr1.vcf&#39;</span><span class="w"> </span><span class="o">],</span>
<span class="w">        </span><span class="o">[</span><span class="w"> </span><span class="s1">&#39;region1&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;chr2&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;/path/to/region1_chr2.vcf&#39;</span><span class="w"> </span><span class="o">],</span>
<span class="w">        </span><span class="o">[</span><span class="w"> </span><span class="s1">&#39;region2&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;chr2&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;/path/to/region2_chr2.vcf&#39;</span><span class="w"> </span><span class="o">],</span>
<span class="w">        </span><span class="o">[</span><span class="w"> </span><span class="s1">&#39;region3&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;chr2&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;/path/to/region3_chr2.vcf&#39;</span><span class="w"> </span><span class="o">]</span>
<span class="w">    </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">map</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">region</span><span class="o">,</span><span class="w"> </span><span class="n">chr</span><span class="o">,</span><span class="w"> </span><span class="n">vcf</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">tuple</span><span class="o">(</span><span class="w"> </span><span class="n">groupKey</span><span class="o">(</span><span class="n">chr</span><span class="o">,</span><span class="w"> </span><span class="n">chr_frequency</span><span class="o">[</span><span class="n">chr</span><span class="o">]),</span><span class="w"> </span><span class="n">vcf</span><span class="w"> </span><span class="o">)</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="o">.</span><span class="na">groupTuple</span><span class="o">()</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">chr1</span><span class="p">,</span> <span class="p">[</span><span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">region1_chr1</span><span class="o">.</span><span class="n">vcf</span><span class="p">,</span> <span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">region2_chr1</span><span class="o">.</span><span class="n">vcf</span><span class="p">]]</span>
<span class="p">[</span><span class="n">chr2</span><span class="p">,</span> <span class="p">[</span><span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">region1_chr2</span><span class="o">.</span><span class="n">vcf</span><span class="p">,</span> <span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">region2_chr2</span><span class="o">.</span><span class="n">vcf</span><span class="p">,</span> <span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">region3_chr2</span><span class="o">.</span><span class="n">vcf</span><span class="p">]]</span>
</pre></div>
</div>
<p>Available options:</p>
<dl class="simple myst">
<dt><code class="docutils literal notranslate"><span class="pre">by</span></code></dt><dd><p>The index (zero based) of the element to be used as grouping key. A key composed by multiple elements can be defined specifying a list of indices e.g. <code class="docutils literal notranslate"><span class="pre">by:</span> <span class="pre">[0,2]</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">remainder</span></code></dt><dd><p>When <code class="docutils literal notranslate"><span class="pre">false</span></code> incomplete tuples (i.e. with less than <code class="docutils literal notranslate"><span class="pre">size</span></code> grouped items) are discarded (default). When <code class="docutils literal notranslate"><span class="pre">true</span></code> incomplete tuples are emitted as the ending emission. Only valid when a <code class="docutils literal notranslate"><span class="pre">size</span></code> parameter is specified.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>The number of items the grouped list(s) has to contain. When the specified size is reached, the tuple is emitted.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sort</span></code></dt><dd><p>Defines the sorting criteria for the grouped items. Can be one of the following values:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">false</span></code>: No sorting is applied (default).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">true</span></code>: Order the grouped items by the item’s natural ordering i.e. numerical for number, lexicographic for string, etc. See the <a class="reference external" href="http://docs.oracle.com/javase/tutorial/collections/interfaces/order.html">Java documentation</a> for more information.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hash</span></code>: Order the grouped items by the hash number associated to each entry.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">deep</span></code>: Similar to the previous, but the hash number is created on actual entries content e.g. when the item is a file, the hash is created on the actual file content.</p></li>
<li><p>A custom sorting criteria used to order the tuples element holding list of values. It can be specified by using either a <a class="reference internal" href="script.html#script-closure"><span class="std std-ref">Closure</span></a> or a <a class="reference external" href="http://docs.oracle.com/javase/7/docs/api/java/util/Comparator.html">Comparator</a> object.</p></li>
</ul>
</dd>
</dl>
</section>
<section id="ifempty">
<span id="operator-ifempty"></span><h2>ifEmpty<a class="headerlink" href="#ifempty" title="Permalink to this heading"></a></h2>
<p><em>Returns: value channel</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">ifEmpty</span></code> operator creates a channel which emits a default value, specified as the operator parameter, when the channel to which is applied is <em>empty</em> i.e. doesn’t emit any value. Otherwise it will emit the same sequence of entries as the original channel.</p>
<p>Thus, the following example prints:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span><span class="w"> </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">)</span><span class="w"> </span><span class="o">.</span><span class="na">ifEmpty</span><span class="o">(</span><span class="s1">&#39;Hello&#39;</span><span class="o">)</span><span class="w"> </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span>
<span class="mi">2</span>
<span class="mi">3</span>
</pre></div>
</div>
<p>Instead, this one prints:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span><span class="w"> </span><span class="o">.</span><span class="na">empty</span><span class="o">()</span><span class="w"> </span><span class="o">.</span><span class="na">ifEmpty</span><span class="o">(</span><span class="s1">&#39;Hello&#39;</span><span class="o">)</span><span class="w"> </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Hello</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">ifEmpty</span></code> value parameter can be defined with a <a class="reference internal" href="script.html#script-closure"><span class="std std-ref">closure</span></a>. In this case the result value of the closure evaluation will be emitted when the empty condition is satisfied.</p>
<p>See also: <a class="reference internal" href="channel.html#channel-empty"><span class="std std-ref">empty</span></a> method.</p>
</section>
<section id="join">
<span id="operator-join"></span><h2>join<a class="headerlink" href="#join" title="Permalink to this heading"></a></h2>
<p><em>Returns: queue channel</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">join</span></code> operator creates a channel that joins together the items emitted by two channels for which exists a matching key. The key is defined, by default, as the first element in each item emitted.</p>
<p>For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">left</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">Channel</span><span class="o">.</span><span class="na">of</span><span class="o">([</span><span class="s1">&#39;X&#39;</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">],</span><span class="w"> </span><span class="o">[</span><span class="s1">&#39;Y&#39;</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">],</span><span class="w"> </span><span class="o">[</span><span class="s1">&#39;Z&#39;</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">],</span><span class="w"> </span><span class="o">[</span><span class="s1">&#39;P&#39;</span><span class="o">,</span><span class="w"> </span><span class="mi">7</span><span class="o">])</span>
<span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Channel</span><span class="o">.</span><span class="na">of</span><span class="o">([</span><span class="s1">&#39;Z&#39;</span><span class="o">,</span><span class="w"> </span><span class="mi">6</span><span class="o">],</span><span class="w"> </span><span class="o">[</span><span class="s1">&#39;Y&#39;</span><span class="o">,</span><span class="w"> </span><span class="mi">5</span><span class="o">],</span><span class="w"> </span><span class="o">[</span><span class="s1">&#39;X&#39;</span><span class="o">,</span><span class="w"> </span><span class="mi">4</span><span class="o">])</span>
<span class="n">left</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="n">right</span><span class="o">).</span><span class="na">view</span><span class="o">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">Z</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="p">[</span><span class="n">Y</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">index</span></code> of a different matching element can be specified by using the <code class="docutils literal notranslate"><span class="pre">by</span></code> parameter.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">join</span></code> operator can emit all the pairs that are incomplete, i.e. the items for which a matching element is missing, by specifying the optional parameter <code class="docutils literal notranslate"><span class="pre">remainder</span></code> as shown below:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">left</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">Channel</span><span class="o">.</span><span class="na">of</span><span class="o">([</span><span class="s1">&#39;X&#39;</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">],</span><span class="w"> </span><span class="o">[</span><span class="s1">&#39;Y&#39;</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">],</span><span class="w"> </span><span class="o">[</span><span class="s1">&#39;Z&#39;</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">],</span><span class="w"> </span><span class="o">[</span><span class="s1">&#39;P&#39;</span><span class="o">,</span><span class="w"> </span><span class="mi">7</span><span class="o">])</span>
<span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Channel</span><span class="o">.</span><span class="na">of</span><span class="o">([</span><span class="s1">&#39;Z&#39;</span><span class="o">,</span><span class="w"> </span><span class="mi">6</span><span class="o">],</span><span class="w"> </span><span class="o">[</span><span class="s1">&#39;Y&#39;</span><span class="o">,</span><span class="w"> </span><span class="mi">5</span><span class="o">],</span><span class="w"> </span><span class="o">[</span><span class="s1">&#39;X&#39;</span><span class="o">,</span><span class="w"> </span><span class="mi">4</span><span class="o">])</span>
<span class="n">left</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="n">right</span><span class="o">,</span><span class="w"> </span><span class="nl">remainder:</span><span class="w"> </span><span class="kc">true</span><span class="o">).</span><span class="na">view</span><span class="o">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">Y</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="p">[</span><span class="n">Z</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="p">[</span><span class="n">P</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="n">null</span><span class="p">]</span>
</pre></div>
</div>
<p>Available options:</p>
<dl class="simple myst">
<dt><code class="docutils literal notranslate"><span class="pre">by</span></code></dt><dd><p>The index (zero based) of the element to be used as grouping key. A key composed by multiple elements can be defined specifying a list of indices e.g. <code class="docutils literal notranslate"><span class="pre">by:</span> <span class="pre">[0,2]</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">failOnDuplicate</span></code></dt><dd><p>An error is reported when the same key is found more than once.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">failOnMismatch</span></code></dt><dd><p>An error is reported when a channel emits a value for which there isn’t a corresponding element in the joining channel. This option cannot be used with <code class="docutils literal notranslate"><span class="pre">remainder</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">remainder</span></code></dt><dd><p>When <code class="docutils literal notranslate"><span class="pre">false</span></code> incomplete tuples (i.e. with less than <code class="docutils literal notranslate"><span class="pre">size</span></code> grouped items) are discarded (default). When <code class="docutils literal notranslate"><span class="pre">true</span></code> incomplete tuples are emitted as the ending emission.</p>
</dd>
</dl>
</section>
<section id="last">
<span id="operator-last"></span><h2>last<a class="headerlink" href="#last" title="Permalink to this heading"></a></h2>
<p><em>Returns: value channel</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">last</span></code> operator creates a channel that only returns the last item emitted by the source channel. For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">last</span><span class="o">()</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">6</span>
</pre></div>
</div>
</section>
<section id="map">
<span id="operator-map"></span><h2>map<a class="headerlink" href="#map" title="Permalink to this heading"></a></h2>
<p><em>Returns: queue channel</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">map</span></code> operator applies a function of your choosing to every item emitted by a channel, and returns the items so obtained as a new channel. The function applied is called the mapping function and is expressed with a <a class="reference internal" href="script.html#script-closure"><span class="std std-ref">closure</span></a> as shown in the example below:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mi">4</span><span class="o">,</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">map</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="o">.</span><span class="na">subscribe</span><span class="w"> </span><span class="nl">onNext:</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">println</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">},</span><span class="w"> </span><span class="nl">onComplete:</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">println</span><span class="w"> </span><span class="s1">&#39;Done&#39;</span><span class="w"> </span><span class="o">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span>
<span class="mi">4</span>
<span class="mi">9</span>
<span class="mi">16</span>
<span class="mi">25</span>
<span class="n">Done</span>
</pre></div>
</div>
</section>
<section id="max">
<span id="operator-max"></span><h2>max<a class="headerlink" href="#max" title="Permalink to this heading"></a></h2>
<p><em>Returns: value channel</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">max</span></code> operator waits until the source channel completes, and then emits the item that has the greatest value. For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="w"> </span><span class="mi">8</span><span class="o">,</span><span class="w"> </span><span class="mi">6</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">max</span><span class="o">()</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="s2">&quot;Max value is $it&quot;</span><span class="w"> </span><span class="o">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Max</span> <span class="n">value</span> <span class="ow">is</span> <span class="mi">8</span>
</pre></div>
</div>
<p>An optional <a class="reference internal" href="script.html#script-closure"><span class="std std-ref">closure</span></a> parameter can be specified in order to provide a function that returns the value to be compared. The example below shows how to find the string item that has the maximum length:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s2">&quot;hello&quot;</span><span class="o">,</span><span class="s2">&quot;hi&quot;</span><span class="o">,</span><span class="s2">&quot;hey&quot;</span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">max</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">it</span><span class="o">.</span><span class="na">size</span><span class="o">()</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;hello&quot;</span>
</pre></div>
</div>
<p>Alternatively it is possible to specify a comparator function i.e. a <a class="reference internal" href="script.html#script-closure"><span class="std std-ref">closure</span></a> taking two parameters that represent two emitted items to be compared. For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s2">&quot;hello&quot;</span><span class="o">,</span><span class="s2">&quot;hi&quot;</span><span class="o">,</span><span class="s2">&quot;hey&quot;</span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">max</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="o">.</span><span class="na">size</span><span class="o">()</span><span class="w"> </span><span class="o">&lt;=&gt;</span><span class="w"> </span><span class="n">b</span><span class="o">.</span><span class="na">size</span><span class="o">()</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>
</pre></div>
</div>
</section>
<section id="merge">
<span id="operator-merge"></span><h2>merge<a class="headerlink" href="#merge" title="Permalink to this heading"></a></h2>
<p><em>Returns: queue channel</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">merge</span></code> operator lets you join items emitted by two (or more) channels into a new channel.</p>
<p>For example, the following code merges two channels together: one which emits a series of odd integers and the other which emits a series of even integers:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">odds</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">Channel</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mi">5</span><span class="o">,</span><span class="w"> </span><span class="mi">7</span><span class="o">,</span><span class="w"> </span><span class="mi">9</span><span class="o">)</span>
<span class="n">evens</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Channel</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">4</span><span class="o">,</span><span class="w"> </span><span class="mi">6</span><span class="o">)</span>

<span class="n">odds</span>
<span class="w">    </span><span class="o">.</span><span class="na">merge</span><span class="o">(</span><span class="w"> </span><span class="n">evens</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
</pre></div>
</div>
<p>An optional closure can be provided to customise the items emitted by the resulting merged channel. For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">odds</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">Channel</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mi">5</span><span class="o">,</span><span class="w"> </span><span class="mi">7</span><span class="o">,</span><span class="w"> </span><span class="mi">9</span><span class="o">)</span>
<span class="n">evens</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Channel</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">4</span><span class="o">,</span><span class="w"> </span><span class="mi">6</span><span class="o">)</span>

<span class="n">odds</span>
<span class="w">    </span><span class="o">.</span><span class="na">merge</span><span class="o">(</span><span class="w"> </span><span class="n">evens</span><span class="w"> </span><span class="o">)</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">a</span><span class="o">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">tuple</span><span class="o">(</span><span class="n">b</span><span class="o">*</span><span class="n">b</span><span class="o">,</span><span class="w"> </span><span class="n">a</span><span class="o">)</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>
</pre></div>
</div>
<div class="admonition danger">
<p class="admonition-title">Danger</p>
<p>In general, the use of the <code class="docutils literal notranslate"><span class="pre">merge</span></code> operator is discouraged. Processes and channel operators are not guaranteed to emit items in the order that they were received, as they are executed concurrently. Therefore, if you try to merge output channels from different processes, the resulting channel may be different on each run, which will cause resumed runs to <a class="reference internal" href="cache-and-resume.html#cache-nondeterministic-inputs"><span class="std std-ref">not work properly</span></a>.</p>
<p>You should always use a matching key (e.g. sample ID) to merge multiple channels, so that they are combined in a deterministic way. For this purpose, you can use the <a class="reference internal" href="#join"><span class="std std-doc">join</span></a> operator.</p>
</div>
</section>
<section id="min">
<span id="operator-min"></span><h2>min<a class="headerlink" href="#min" title="Permalink to this heading"></a></h2>
<p><em>Returns: value channel</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">min</span></code> operator waits until the source channel completes, and then emits the item that has the lowest value. For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="w"> </span><span class="mi">8</span><span class="o">,</span><span class="w"> </span><span class="mi">6</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">min</span><span class="o">()</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="s2">&quot;Min value is $it&quot;</span><span class="w"> </span><span class="o">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Min</span> <span class="n">value</span> <span class="ow">is</span> <span class="mi">2</span>
</pre></div>
</div>
<p>An optional <a class="reference internal" href="script.html#script-closure"><span class="std std-ref">closure</span></a> parameter can be specified in order to provide a function that returns the value to be compared. The example below shows how to find the string item that has the minimum length:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s2">&quot;hello&quot;</span><span class="o">,</span><span class="s2">&quot;hi&quot;</span><span class="o">,</span><span class="s2">&quot;hey&quot;</span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">min</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">it</span><span class="o">.</span><span class="na">size</span><span class="o">()</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;hi&quot;</span>
</pre></div>
</div>
<p>Alternatively it is possible to specify a comparator function i.e. a <a class="reference internal" href="script.html#script-closure"><span class="std std-ref">closure</span></a> taking two parameters that represent two emitted items to be compared. For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s2">&quot;hello&quot;</span><span class="o">,</span><span class="s2">&quot;hi&quot;</span><span class="o">,</span><span class="s2">&quot;hey&quot;</span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">min</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="o">.</span><span class="na">size</span><span class="o">()</span><span class="w"> </span><span class="o">&lt;=&gt;</span><span class="w"> </span><span class="n">b</span><span class="o">.</span><span class="na">size</span><span class="o">()</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>
</pre></div>
</div>
</section>
<section id="mix">
<span id="operator-mix"></span><h2>mix<a class="headerlink" href="#mix" title="Permalink to this heading"></a></h2>
<p><em>Returns: queue channel</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">mix</span></code> operator combines the items emitted by two (or more) channels into a single channel.</p>
<p>For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">c1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Channel</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">)</span>
<span class="n">c2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Channel</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="w"> </span><span class="s1">&#39;a&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;b&#39;</span><span class="w"> </span><span class="o">)</span>
<span class="n">c3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Channel</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="w"> </span><span class="s1">&#39;z&#39;</span><span class="w"> </span><span class="o">)</span>

<span class="n">c1</span><span class="o">.</span><span class="na">mix</span><span class="o">(</span><span class="n">c2</span><span class="o">,</span><span class="n">c3</span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">subscribe</span><span class="w"> </span><span class="nl">onNext:</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">println</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">},</span><span class="w"> </span><span class="nl">onComplete:</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">println</span><span class="w"> </span><span class="s1">&#39;Done&#39;</span><span class="w"> </span><span class="o">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span>
<span class="mi">2</span>
<span class="mi">3</span>
<span class="s1">&#39;a&#39;</span>
<span class="s1">&#39;b&#39;</span>
<span class="s1">&#39;z&#39;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The items emitted by the resulting mixed channel may appear in any order, regardless of which source channel they came from. Thus, the following example could also be a possible result of the above example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s1">&#39;z&#39;</span>
<span class="mi">1</span>
<span class="s1">&#39;a&#39;</span>
<span class="mi">2</span>
<span class="s1">&#39;b&#39;</span>
<span class="mi">3</span>
</pre></div>
</div>
</div>
</section>
<section id="multimap">
<span id="operator-multimap"></span><h2>multiMap<a class="headerlink" href="#multimap" title="Permalink to this heading"></a></h2>
<div class="versionadded">
<p><span class="versionmodified added">New in version 19.11.0-edge.</span></p>
</div>
<p><em>Returns: map of queue channels</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">multiMap</span></code> operator allows you to forward the items emitted by a source channel to two or more output channels, mapping each input value as a separate element.</p>
<p>The mapping criteria is defined with a <a class="reference internal" href="script.html#script-closure"><span class="std std-ref">closure</span></a> that specifies the target channels (labelled with a unique identifier) followed by an expression that maps each item from the input channel to the target channel.</p>
<p>For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mi">4</span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">multiMap</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">        </span><span class="nl">foo:</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="w">        </span><span class="nl">bar:</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">it</span>
<span class="w">    </span><span class="o">}</span>
<span class="w">    </span><span class="o">.</span><span class="na">set</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">}</span>

<span class="n">result</span><span class="o">.</span><span class="na">foo</span><span class="o">.</span><span class="na">view</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="s2">&quot;foo $it&quot;</span><span class="w"> </span><span class="o">}</span>
<span class="n">result</span><span class="o">.</span><span class="na">bar</span><span class="o">.</span><span class="na">view</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="s2">&quot;bar $it&quot;</span><span class="w"> </span><span class="o">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">foo</span> <span class="mi">2</span>
<span class="n">foo</span> <span class="mi">3</span>
<span class="n">foo</span> <span class="mi">4</span>
<span class="n">foo</span> <span class="mi">5</span>
<span class="n">bar</span> <span class="mi">1</span>
<span class="n">bar</span> <span class="mi">4</span>
<span class="n">bar</span> <span class="mi">9</span>
<span class="n">bar</span> <span class="mi">16</span>
</pre></div>
</div>
<p>The mapping expression can be omitted when the value to be emitted is the same as the following one. If you just need to forward the same value to multiple channels, you can use the following shorthand:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">multiMap</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nl">foo:</span><span class="w"> </span><span class="nl">bar:</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="o">.</span><span class="na">set</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">}</span>
</pre></div>
</div>
<p>As before, this creates two channels, but now both of them receive the same source items.</p>
<p>You can use the <code class="docutils literal notranslate"><span class="pre">multiMapCriteria</span></code> method to create a multi-map criteria as a variable that can be passed as an argument to one or more <code class="docutils literal notranslate"><span class="pre">multiMap</span></code> operations, as shown below:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="kt">def</span><span class="w"> </span><span class="n">criteria</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">multiMapCriteria</span><span class="w"> </span><span class="o">{</span>
<span class="w">    </span><span class="nl">small:</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span>
<span class="w">    </span><span class="nl">large:</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">10</span>
<span class="o">}</span>

<span class="n">Channel</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">30</span><span class="o">).</span><span class="na">multiMap</span><span class="o">(</span><span class="n">criteria</span><span class="o">).</span><span class="na">set</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">ch1</span><span class="w"> </span><span class="o">}</span>
<span class="n">Channel</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span><span class="w"> </span><span class="mi">20</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">).</span><span class="na">multiMap</span><span class="o">(</span><span class="n">criteria</span><span class="o">).</span><span class="na">set</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">ch2</span><span class="w"> </span><span class="o">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you use <code class="docutils literal notranslate"><span class="pre">multiMap</span></code> to split a tuple or map into multiple channels, it is recommended that you retain a matching key (e.g. sample ID) with <em>each</em> new channel, so that you can re-combine these channels later on if needed. In general, you should not expect to be able to merge channels correctly without a matching key, due to the parallel and asynchronous nature of Nextflow pipelines.</p>
</div>
</section>
<section id="randomsample">
<span id="operator-randomsample"></span><h2>randomSample<a class="headerlink" href="#randomsample" title="Permalink to this heading"></a></h2>
<p><em>Returns: queue channel</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">randomSample</span></code> operator allows you to create a channel emitting the specified number of items randomly taken from the channel to which is applied. For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">randomSample</span><span class="o">(</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>
</pre></div>
</div>
<p>The above snippet will print 10 numbers in the range from 1 to 100.</p>
<p>The operator supports a second parameter that allows you to set the initial <code class="docutils literal notranslate"><span class="pre">seed</span></code> for the random number generator. By setting it, the <code class="docutils literal notranslate"><span class="pre">randomSample</span></code> operator will always return the same pseudo-random sequence. For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">randomSample</span><span class="o">(</span><span class="w"> </span><span class="mi">10</span><span class="o">,</span><span class="w"> </span><span class="mi">234</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>
</pre></div>
</div>
<p>The above example will print 10 random numbers in the range between 1 and 100. At each run of the script, the same sequence will be returned.</p>
</section>
<section id="reduce">
<span id="operator-reduce"></span><h2>reduce<a class="headerlink" href="#reduce" title="Permalink to this heading"></a></h2>
<p><em>Returns: value channel</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">reduce</span></code> operator applies a function of your choosing to every item emitted by a channel. Each time this function is invoked it takes two parameters: the accumulated value and the <em>i-th</em> emitted item. The result is passed as the accumulated value to the next function call, along with the <em>i+1 th</em> item, until all the items are processed.</p>
<p>Finally, the <code class="docutils literal notranslate"><span class="pre">reduce</span></code> operator emits the result of the last invocation of your function as the sole output.</p>
<p>For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mi">4</span><span class="o">,</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">reduce</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">a</span><span class="o">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">println</span><span class="w"> </span><span class="s2">&quot;a: $a b: $b&quot;</span><span class="o">;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="s2">&quot;result = $it&quot;</span><span class="w"> </span><span class="o">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">:</span> <span class="mi">1</span> <span class="n">b</span><span class="p">:</span> <span class="mi">2</span>
<span class="n">a</span><span class="p">:</span> <span class="mi">3</span> <span class="n">b</span><span class="p">:</span> <span class="mi">3</span>
<span class="n">a</span><span class="p">:</span> <span class="mi">6</span> <span class="n">b</span><span class="p">:</span> <span class="mi">4</span>
<span class="n">a</span><span class="p">:</span> <span class="mi">10</span> <span class="n">b</span><span class="p">:</span> <span class="mi">5</span>
<span class="n">result</span> <span class="o">=</span> <span class="mi">15</span>
</pre></div>
</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>A common use case for this operator is to use the first parameter as an accumulator and the second parameter as the <code class="docutils literal notranslate"><span class="pre">i-th</span></code> item to be processed.</p>
</div>
<p>Optionally you can specify an initial value for the accumulator as shown below:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">myChannel</span><span class="o">.</span><span class="na">reduce</span><span class="o">(</span><span class="w"> </span><span class="n">initialValue</span><span class="w"> </span><span class="o">)</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">a</span><span class="o">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="o">}</span>
</pre></div>
</div>
</section>
<section id="set">
<span id="operator-set"></span><h2>set<a class="headerlink" href="#set" title="Permalink to this heading"></a></h2>
<p><em>Returns: nothing</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">set</span></code> operator assigns the channel to a variable whose name is specified as a closure parameter. For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span><span class="w"> </span><span class="mi">20</span><span class="o">,</span><span class="w"> </span><span class="mi">30</span><span class="o">).</span><span class="na">set</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">my_channel</span><span class="w"> </span><span class="o">}</span>
</pre></div>
</div>
<p>This is semantically equivalent to the following assignment:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">my_channel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Channel</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span><span class="w"> </span><span class="mi">20</span><span class="o">,</span><span class="w"> </span><span class="mi">30</span><span class="o">)</span>
</pre></div>
</div>
<p>However the <code class="docutils literal notranslate"><span class="pre">set</span></code> operator is more idiomatic in Nextflow scripting, since it can be used at the end of a chain of operator transformations, thus resulting in a more fluent and readable operation.</p>
</section>
<section id="splitcsv">
<span id="operator-splitcsv"></span><h2>splitCsv<a class="headerlink" href="#splitcsv" title="Permalink to this heading"></a></h2>
<p><em>Returns: queue channel</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">splitCsv</span></code> operator allows you to parse text items emitted by a channel, that are formatted using the <a class="reference external" href="http://en.wikipedia.org/wiki/Comma-separated_values">CSV format</a>, and split them into records or group them into list of records with a specified length.</p>
<p>In the simplest case just apply the <code class="docutils literal notranslate"><span class="pre">splitCsv</span></code> operator to a channel emitting a CSV formatted text files or text entries. For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="w"> </span><span class="s1">&#39;alpha,beta,gamma\n10,20,30\n70,80,90&#39;</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">splitCsv</span><span class="o">()</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s2">&quot;${row[0]} - ${row[1]} - ${row[2]}&quot;</span><span class="w"> </span><span class="o">}</span>
</pre></div>
</div>
<p>The above example shows hows CSV text is parsed and is split into single rows. Values can be accessed by its column index in the row object.</p>
<p>When the CSV begins with a header line defining the column names, you can specify the parameter <code class="docutils literal notranslate"><span class="pre">header:</span> <span class="pre">true</span></code> which allows you to reference each value by its name, as shown in the following example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="w"> </span><span class="s1">&#39;alpha,beta,gamma\n10,20,30\n70,80,90&#39;</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">splitCsv</span><span class="o">(</span><span class="nl">header:</span><span class="w"> </span><span class="kc">true</span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s2">&quot;${row.alpha} - ${row.beta} - ${row.gamma}&quot;</span><span class="w"> </span><span class="o">}</span>
</pre></div>
</div>
<p>It will print</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">10</span> <span class="o">-</span> <span class="mi">20</span> <span class="o">-</span> <span class="mi">30</span>
<span class="mi">70</span> <span class="o">-</span> <span class="mi">80</span> <span class="o">-</span> <span class="mi">90</span>
</pre></div>
</div>
<p>Alternatively you can provide custom header names by specifying a the list of strings in the <code class="docutils literal notranslate"><span class="pre">header</span></code> parameter as shown below:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="w"> </span><span class="s1">&#39;alpha,beta,gamma\n10,20,30\n70,80,90&#39;</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">splitCsv</span><span class="o">(</span><span class="nl">header:</span><span class="w"> </span><span class="o">[</span><span class="s1">&#39;col1&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;col2&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;col3&#39;</span><span class="o">],</span><span class="w"> </span><span class="nl">skip:</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s2">&quot;${row.col1} - ${row.col2} - ${row.col3}&quot;</span><span class="w"> </span><span class="o">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>By default, the <code class="docutils literal notranslate"><span class="pre">splitCsv</span></code> operator returns each row as a <em>list</em> object. Items are accessed by using the 0-based column index.</p></li>
<li><p>When the <code class="docutils literal notranslate"><span class="pre">header</span></code> is specified each row is returned as a <em>map</em> object (also known as dictionary). Items are accessed via the corresponding column name.</p></li>
</ul>
</div>
<p>Available options:</p>
<dl class="simple myst">
<dt><code class="docutils literal notranslate"><span class="pre">by</span></code></dt><dd><p>The number of rows in each <code class="docutils literal notranslate"><span class="pre">chunk</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">charset</span></code></dt><dd><p>Parse the content by using the specified charset e.g. <code class="docutils literal notranslate"><span class="pre">UTF-8</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">decompress</span></code></dt><dd><p>When <code class="docutils literal notranslate"><span class="pre">true</span></code> decompress the content using the GZIP format before processing it (note: files whose name ends with <code class="docutils literal notranslate"><span class="pre">.gz</span></code> extension are decompressed automatically)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">elem</span></code></dt><dd><p>The index of the element to split when the operator is applied to a channel emitting list/tuple objects (default: first file object or first element)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">header</span></code></dt><dd><p>When <code class="docutils literal notranslate"><span class="pre">true</span></code> the first line is used as columns names. Alternatively it can be used to provide the list of columns names.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">limit</span></code></dt><dd><p>Limits the number of retrieved records for each file to the specified value.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">quote</span></code></dt><dd><p>Values may be quoted by single or double quote characters.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sep</span></code></dt><dd><p>The character used to separate the values (default: <code class="docutils literal notranslate"><span class="pre">,</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skip</span></code></dt><dd><p>Number of lines since the file beginning to ignore when parsing the CSV content.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">strip</span></code></dt><dd><p>Removes leading and trailing blanks from values (default: <code class="docutils literal notranslate"><span class="pre">false</span></code>)</p>
</dd>
</dl>
</section>
<section id="splitfasta">
<span id="operator-splitfasta"></span><h2>splitFasta<a class="headerlink" href="#splitfasta" title="Permalink to this heading"></a></h2>
<p><em>Returns: queue channel</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">splitFasta</span></code> operator allows you to split the entries emitted by a channel, that are formatted using the <a class="reference external" href="http://en.wikipedia.org/wiki/FASTA_format">FASTA format</a>. It returns a channel which emits text item for each sequence in the received FASTA content.</p>
<p>The number of sequences in each text chunk produced by the <code class="docutils literal notranslate"><span class="pre">splitFasta</span></code> operator can be set by using the <code class="docutils literal notranslate"><span class="pre">by</span></code> parameter. The following example shows how to read a FASTA file and split it into chunks containing 10 sequences each:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">     </span><span class="o">.</span><span class="na">fromPath</span><span class="o">(</span><span class="s1">&#39;misc/sample.fa&#39;</span><span class="o">)</span>
<span class="w">     </span><span class="o">.</span><span class="na">splitFasta</span><span class="o">(</span><span class="w"> </span><span class="nl">by:</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="o">)</span>
<span class="w">     </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Chunks are stored in memory by default. When splitting large files, specify the parameter <code class="docutils literal notranslate"><span class="pre">file:</span> <span class="pre">true</span></code> to save the chunks into files in order to avoid an <code class="docutils literal notranslate"><span class="pre">OutOfMemoryException</span></code>. See the parameter table below for details.</p>
</div>
<p>A second version of the <code class="docutils literal notranslate"><span class="pre">splitFasta</span></code> operator allows you to split a FASTA content into record objects, instead of text chunks. A record object contains a set of fields that let you access and manipulate the FASTA sequence information with ease.</p>
<p>In order to split a FASTA content into record objects, simply use the <code class="docutils literal notranslate"><span class="pre">record</span></code> parameter specifying the map of required the fields, as shown in the example below:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">     </span><span class="o">.</span><span class="na">fromPath</span><span class="o">(</span><span class="s1">&#39;misc/sample.fa&#39;</span><span class="o">)</span>
<span class="w">     </span><span class="o">.</span><span class="na">splitFasta</span><span class="o">(</span><span class="w"> </span><span class="nl">record:</span><span class="w"> </span><span class="o">[</span><span class="nl">id:</span><span class="w"> </span><span class="kc">true</span><span class="o">,</span><span class="w"> </span><span class="nl">seqString:</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="o">])</span>
<span class="w">     </span><span class="o">.</span><span class="na">filter</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">record</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">record</span><span class="o">.</span><span class="na">id</span><span class="w"> </span><span class="o">=~</span><span class="w"> </span><span class="s">/^ENST0.*/</span><span class="w"> </span><span class="o">}</span>
<span class="w">     </span><span class="o">.</span><span class="na">view</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">record</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">record</span><span class="o">.</span><span class="na">seqString</span><span class="w"> </span><span class="o">}</span>
</pre></div>
</div>
<p>In this example, the file <code class="docutils literal notranslate"><span class="pre">misc/sample.fa</span></code> is split into records containing the <code class="docutils literal notranslate"><span class="pre">id</span></code> and the <code class="docutils literal notranslate"><span class="pre">seqString</span></code> fields (i.e. the sequence id and the sequence data). The following <code class="docutils literal notranslate"><span class="pre">filter</span></code> operator only keeps the sequences whose ID starts with the <code class="docutils literal notranslate"><span class="pre">ENST0</span></code> prefix, finally the sequence content is printed by using the <code class="docutils literal notranslate"><span class="pre">subscribe</span></code> operator.</p>
<p>Available options:</p>
<dl class="simple myst">
<dt><code class="docutils literal notranslate"><span class="pre">by</span></code></dt><dd><p>Defines the number of sequences in each <code class="docutils literal notranslate"><span class="pre">chunk</span></code> (default: <code class="docutils literal notranslate"><span class="pre">1</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">charset</span></code></dt><dd><p>Parse the content by using the specified charset e.g. <code class="docutils literal notranslate"><span class="pre">UTF-8</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">compress</span></code></dt><dd><p>When <code class="docutils literal notranslate"><span class="pre">true</span></code> resulting file chunks are GZIP compressed. The <code class="docutils literal notranslate"><span class="pre">.gz</span></code> suffix is automatically added to chunk file names.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">decompress</span></code></dt><dd><p>When <code class="docutils literal notranslate"><span class="pre">true</span></code>, decompress the content using the GZIP format before processing it (note: files whose name ends with <code class="docutils literal notranslate"><span class="pre">.gz</span></code> extension are decompressed automatically).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">elem</span></code></dt><dd><p>The index of the element to split when the operator is applied to a channel emitting list/tuple objects (default: first file object or first element).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">file</span></code></dt><dd><p>When <code class="docutils literal notranslate"><span class="pre">true</span></code> saves each split to a file. Use a string instead of <code class="docutils literal notranslate"><span class="pre">true</span></code> value to create split files with a specific name (split index number is automatically added). Finally, set this attribute to an existing directory, in order to save the split files into the specified folder.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">limit</span></code></dt><dd><p>Limits the number of retrieved sequences for each file to the specified value.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">record</span></code></dt><dd><p>Parse each entry in the FASTA file as record objects. The following fields are available:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">id</span></code>: The FASTA sequence identifier i.e. the word following the <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> symbol up to the first <code class="docutils literal notranslate"><span class="pre">blank</span></code> or <code class="docutils literal notranslate"><span class="pre">newline</span></code> character</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">header</span></code>: The first line in a FASTA sequence without the <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> character</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">desc</span></code>: The text in the FASTA header following the ID value</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">text</span></code>: The complete FASTA sequence including the header</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">seqString</span></code>: The sequence data as a single line string i.e. containing no <code class="docutils literal notranslate"><span class="pre">newline</span></code> characters</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sequence</span></code>: The sequence data as a multi-line string (always ending with a <code class="docutils literal notranslate"><span class="pre">newline</span></code> character)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">width</span></code>: Define the length of a single line when the <code class="docutils literal notranslate"><span class="pre">sequence</span></code> field is used, after that the sequence data continues on a new line.</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>Defines the size in memory units of the expected chunks e.g. <code class="docutils literal notranslate"><span class="pre">1.MB</span></code>.</p>
</dd>
</dl>
<p>See also: <a class="reference internal" href="#countfasta"><span class="std std-doc">countFasta</span></a></p>
</section>
<section id="splitfastq">
<span id="operator-splitfastq"></span><h2>splitFastq<a class="headerlink" href="#splitfastq" title="Permalink to this heading"></a></h2>
<p><em>Returns: queue channel</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">splitFastq</span></code> operator allows you to split the entries emitted by a channel, that are formatted using the <a class="reference external" href="http://en.wikipedia.org/wiki/FASTQ_format">FASTQ format</a>. It returns a channel which emits a text chunk for each sequence in the received item.</p>
<p>The number of sequences in each text chunk produced by the <code class="docutils literal notranslate"><span class="pre">splitFastq</span></code> operator is defined by the parameter <code class="docutils literal notranslate"><span class="pre">by</span></code>. The following example shows you how to read a FASTQ file and split it into chunks containing 10 sequences each:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">fromPath</span><span class="o">(</span><span class="s1">&#39;misc/sample.fastq&#39;</span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">splitFastq</span><span class="o">(</span><span class="w"> </span><span class="nl">by:</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Chunks are stored in memory by default. When splitting large files, specify the parameter <code class="docutils literal notranslate"><span class="pre">file:</span> <span class="pre">true</span></code> to save the chunks into files in order to avoid an <code class="docutils literal notranslate"><span class="pre">OutOfMemoryException</span></code>. See the parameter table below for details.</p>
</div>
<p>A second version of the <code class="docutils literal notranslate"><span class="pre">splitFastq</span></code> operator allows you to split a FASTQ formatted content into record objects, instead of text chunks. A record object contains a set of fields that let you access and manipulate the FASTQ sequence data with ease.</p>
<p>In order to split FASTQ sequences into record objects simply use the <code class="docutils literal notranslate"><span class="pre">record</span></code> parameter specifying the map of the required fields, or just specify <code class="docutils literal notranslate"><span class="pre">record:</span> <span class="pre">true</span></code> as in the example shown below:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">fromPath</span><span class="o">(</span><span class="s1">&#39;misc/sample.fastq&#39;</span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">splitFastq</span><span class="o">(</span><span class="w"> </span><span class="nl">record:</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">record</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">record</span><span class="o">.</span><span class="na">readHeader</span><span class="w"> </span><span class="o">}</span>
</pre></div>
</div>
<p>Finally the <code class="docutils literal notranslate"><span class="pre">splitFastq</span></code> operator is able to split paired-end read pair FASTQ files. It must be applied to a channel which emits tuples containing at least two elements that are the files to be split. For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">fromFilePairs</span><span class="o">(</span><span class="s1">&#39;/my/data/SRR*_{1,2}.fastq&#39;</span><span class="o">,</span><span class="w"> </span><span class="nl">flat:</span><span class="w"> </span><span class="kc">true</span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">splitFastq</span><span class="o">(</span><span class="nl">by:</span><span class="w"> </span><span class="mi">100</span><span class="n">_000</span><span class="o">,</span><span class="w"> </span><span class="nl">pe:</span><span class="w"> </span><span class="kc">true</span><span class="o">,</span><span class="w"> </span><span class="nl">file:</span><span class="w"> </span><span class="kc">true</span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">fromFilePairs</span></code> requires the <code class="docutils literal notranslate"><span class="pre">flat:</span> <span class="pre">true</span></code> option in order to emit the file pairs as separate elements in the produced tuples.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This operator assumes that the order of the paired-end reads correspond with each other and both files contain the same number of reads.</p>
</div>
<p>Available options:</p>
<dl class="simple myst">
<dt><code class="docutils literal notranslate"><span class="pre">by</span></code></dt><dd><p>Defines the number of <em>reads</em> in each <code class="docutils literal notranslate"><span class="pre">chunk</span></code> (default: <code class="docutils literal notranslate"><span class="pre">1</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">charset</span></code></dt><dd><p>Parse the content by using the specified charset e.g. <code class="docutils literal notranslate"><span class="pre">UTF-8</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">compress</span></code></dt><dd><p>When <code class="docutils literal notranslate"><span class="pre">true</span></code> resulting file chunks are GZIP compressed. The <code class="docutils literal notranslate"><span class="pre">.gz</span></code> suffix is automatically added to chunk file names.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">decompress</span></code></dt><dd><p>When <code class="docutils literal notranslate"><span class="pre">true</span></code> decompress the content using the GZIP format before processing it (note: files whose name ends with <code class="docutils literal notranslate"><span class="pre">.gz</span></code> extension are decompressed automatically)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">elem</span></code></dt><dd><p>The index of the element to split when the operator is applied to a channel emitting list/tuple objects (default: first file object or first element)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">file</span></code></dt><dd><p>When <code class="docutils literal notranslate"><span class="pre">true</span></code> saves each split to a file. Use a string instead of <code class="docutils literal notranslate"><span class="pre">true</span></code> value to create split files with a specific name (split index number is automatically added). Finally, set this attribute to an existing directory, in order to save the split files into the specified folder.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">limit</span></code></dt><dd><p>Limits the number of retrieved <em>reads</em> for each file to the specified value.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pe</span></code></dt><dd><p>When <code class="docutils literal notranslate"><span class="pre">true</span></code> splits paired-end read files, therefore items emitted by the source channel must be tuples in which at least two elements are the read-pair files to be split.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">record</span></code></dt><dd><p>Parse each entry in the FASTQ file as record objects. The following fields are available:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">readHeader</span></code>: Sequence header (without the <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> prefix)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">readString</span></code>: The raw sequence data</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">qualityHeader</span></code>: Base quality header (it may be empty)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">qualityString</span></code>: Quality values for the sequence</p></li>
</ul>
</dd>
</dl>
<p>See also: <a class="reference internal" href="#countfastq"><span class="std std-doc">countFastq</span></a></p>
</section>
<section id="splitjson">
<span id="operator-splitjson"></span><h2>splitJson<a class="headerlink" href="#splitjson" title="Permalink to this heading"></a></h2>
<p><em>Returns: queue channel</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">splitJson</span></code> operator allows you to split a JSON document from a source channel into individual records. If the document is a JSON array, each element of the array will be emitted. If the document is a JSON object, each key-value pair will be emitted as a map with the properties <code class="docutils literal notranslate"><span class="pre">key</span></code>  and <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p>
<p>An example with a JSON array:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s1">&#39;[1,null,[&quot;A&quot;,{}],true]&#39;</span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">splitJson</span><span class="o">()</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">{</span><span class="s2">&quot;Item: ${it}&quot;</span><span class="o">}</span>
</pre></div>
</div>
<p>Produces the following output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Item</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">Item</span><span class="p">:</span> <span class="n">null</span>
<span class="n">Item</span><span class="p">:</span> <span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="p">[:]]</span>
<span class="n">Item</span><span class="p">:</span> <span class="n">true</span>
</pre></div>
</div>
<p>An example with a JSON object:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s1">&#39;{&quot;A&quot;:1,&quot;B&quot;:[1,2,3],&quot;C&quot;:{&quot;D&quot;:null}}&#39;</span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">splitJson</span><span class="o">()</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">{</span><span class="s2">&quot;Item: ${it}&quot;</span><span class="o">}</span>
</pre></div>
</div>
<p>Produces the following output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Item</span><span class="p">:</span> <span class="p">[</span><span class="n">value</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span><span class="n">A</span><span class="p">]</span>
<span class="n">Item</span><span class="p">:</span> <span class="p">[</span><span class="n">value</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">key</span><span class="p">:</span><span class="n">B</span><span class="p">]</span>
<span class="n">Item</span><span class="p">:</span> <span class="p">[</span><span class="n">value</span><span class="p">:[</span><span class="n">D</span><span class="p">:</span><span class="n">null</span><span class="p">],</span> <span class="n">key</span><span class="p">:</span><span class="n">C</span><span class="p">]</span>
</pre></div>
</div>
<p>You can optionally query a section of the JSON document to parse and split, using the <code class="docutils literal notranslate"><span class="pre">path</span></code> option:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s1">&#39;{&quot;A&quot;:1,&quot;B&quot;:[2,3,{&quot;C&quot;:{&quot;D&quot;:null,&quot;E&quot;:4,&quot;F&quot;:5}}]}&#39;</span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">splitJson</span><span class="o">(</span><span class="nl">path:</span><span class="w"> </span><span class="s2">&quot;B[2].C&quot;</span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">{</span><span class="s2">&quot;Item: ${it}&quot;</span><span class="o">}</span>
</pre></div>
</div>
<p>Produces the following output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Item</span><span class="p">:</span> <span class="p">[</span><span class="n">value</span><span class="p">:</span><span class="n">null</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span><span class="n">D</span><span class="p">]</span>
<span class="n">Item</span><span class="p">:</span> <span class="p">[</span><span class="n">value</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span><span class="n">E</span><span class="p">]</span>
<span class="n">Item</span><span class="p">:</span> <span class="p">[</span><span class="n">value</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span><span class="n">F</span><span class="p">]</span>
</pre></div>
</div>
<p>Available options:</p>
<dl class="simple myst">
<dt><code class="docutils literal notranslate"><span class="pre">limit</span></code></dt><dd><p>Limits the number of retrieved lines for each file to the specified value.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">path</span></code></dt><dd><p>Define the section of the JSON document that you want to extract. The expression is a set of paths separated by a dot, similar to <a class="reference external" href="https://goessner.net/articles/JsonPath/">JSONPath</a>. The empty string is the document root (default). An integer in brackets is the 0-based index in a JSON array. A string preceded by a dot <code class="docutils literal notranslate"><span class="pre">.</span></code> is the key in a JSON object.</p>
</dd>
</dl>
<p>See also: <a class="reference internal" href="#countjson"><span class="std std-doc">countJson</span></a></p>
</section>
<section id="splittext">
<span id="operator-splittext"></span><h2>splitText<a class="headerlink" href="#splittext" title="Permalink to this heading"></a></h2>
<p><em>Returns: queue channel</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">splitText</span></code> operator allows you to split multi-line strings or text file items, emitted by a source channel into chunks containing <code class="docutils literal notranslate"><span class="pre">n</span></code> lines, which will be emitted by the resulting channel.</p>
<p>For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">fromPath</span><span class="o">(</span><span class="s1">&#39;/some/path/*.txt&#39;</span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">splitText</span><span class="o">()</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>
</pre></div>
</div>
<p>It splits the content of the files with suffix <code class="docutils literal notranslate"><span class="pre">.txt</span></code>, and prints it line by line.</p>
<p>By default the <code class="docutils literal notranslate"><span class="pre">splitText</span></code> operator splits each item into chunks of one line. You can define the number of lines in each chunk by using the parameter <code class="docutils literal notranslate"><span class="pre">by</span></code>, as shown in the following example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">fromPath</span><span class="o">(</span><span class="s1">&#39;/some/path/*.txt&#39;</span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">splitText</span><span class="o">(</span><span class="w"> </span><span class="nl">by:</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">subscribe</span><span class="w"> </span><span class="o">{</span>
<span class="w">        </span><span class="n">print</span><span class="w"> </span><span class="n">it</span><span class="o">;</span>
<span class="w">        </span><span class="n">print</span><span class="w"> </span><span class="s2">&quot;--- end of the chunk ---\n&quot;</span>
<span class="w">    </span><span class="o">}</span>
</pre></div>
</div>
<p>An optional <a class="reference internal" href="script.html#script-closure"><span class="std std-ref">closure</span></a> can be specified in order to transform the text chunks produced by the operator. The following example shows how to split text files into chunks of 10 lines and transform them to capital letters:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">fromPath</span><span class="o">(</span><span class="s1">&#39;/some/path/*.txt&#39;</span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">splitText</span><span class="o">(</span><span class="w"> </span><span class="nl">by:</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="o">)</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">it</span><span class="o">.</span><span class="na">toUpperCase</span><span class="o">()</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Text chunks returned by the <code class="docutils literal notranslate"><span class="pre">splitText</span></code> operator are always terminated by a <code class="docutils literal notranslate"><span class="pre">\n</span></code> newline character.</p>
</div>
<p>Available options:</p>
<dl class="simple myst">
<dt><code class="docutils literal notranslate"><span class="pre">by</span></code></dt><dd><p>Defines the number of lines in each <code class="docutils literal notranslate"><span class="pre">chunk</span></code> (default: <code class="docutils literal notranslate"><span class="pre">1</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">charset</span></code></dt><dd><p>Parse the content by using the specified charset e.g. <code class="docutils literal notranslate"><span class="pre">UTF-8</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">compress</span></code></dt><dd><p>When <code class="docutils literal notranslate"><span class="pre">true</span></code> resulting file chunks are GZIP compressed. The <code class="docutils literal notranslate"><span class="pre">.gz</span></code> suffix is automatically added to chunk file names.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">decompress</span></code></dt><dd><p>When <code class="docutils literal notranslate"><span class="pre">true</span></code>, decompress the content using the GZIP format before processing it (note: files whose name ends with <code class="docutils literal notranslate"><span class="pre">.gz</span></code> extension are decompressed automatically).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">elem</span></code></dt><dd><p>The index of the element to split when the operator is applied to a channel emitting list/tuple objects (default: first file object or first element).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">file</span></code></dt><dd><p>When <code class="docutils literal notranslate"><span class="pre">true</span></code> saves each split to a file. Use a string instead of <code class="docutils literal notranslate"><span class="pre">true</span></code> value to create split files with a specific name (split index number is automatically added). Finally, set this attribute to an existing directory, in order to save the split files into the specified folder.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">keepHeader</span></code></dt><dd><p>Parses the first line as header and prepends it to each emitted chunk.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">limit</span></code></dt><dd><p>Limits the number of retrieved lines for each file to the specified value.</p>
</dd>
</dl>
<p>See also: <a class="reference internal" href="#countlines"><span class="std std-doc">countLines</span></a></p>
</section>
<section id="subscribe">
<span id="operator-subscribe"></span><h2>subscribe<a class="headerlink" href="#subscribe" title="Permalink to this heading"></a></h2>
<p><em>Returns: nothing</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">subscribe</span></code> operator allows you to execute a user defined function each time a new value is emitted by the source channel.</p>
<p>The emitted value is passed implicitly to the specified function. For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="c1">// define a channel emitting three values</span>
<span class="n">source</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Channel</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="w"> </span><span class="s1">&#39;alpha&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;beta&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;delta&#39;</span><span class="w"> </span><span class="o">)</span>

<span class="c1">// subscribe a function to the channel printing the emitted values</span>
<span class="n">source</span><span class="o">.</span><span class="na">subscribe</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">println</span><span class="w"> </span><span class="s2">&quot;Got: $it&quot;</span><span class="w"> </span><span class="o">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Got</span><span class="p">:</span> <span class="n">alpha</span>
<span class="n">Got</span><span class="p">:</span> <span class="n">beta</span>
<span class="n">Got</span><span class="p">:</span> <span class="n">delta</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In Groovy, the language on which Nextflow is based, the user defined function is called a <strong>closure</strong>. Read the <a class="reference internal" href="script.html#script-closure"><span class="std std-ref">Closures</span></a> section to learn more about closures.</p>
</div>
<p>If needed the closure parameter can be defined explicitly, using a name other than <code class="docutils literal notranslate"><span class="pre">it</span></code> and, optionally, specifying the expected value type, as shown in the following example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="w"> </span><span class="s1">&#39;alpha&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;beta&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;lambda&#39;</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">subscribe</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">str</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">        </span><span class="n">println</span><span class="w"> </span><span class="s2">&quot;Got: ${str}; len: ${str.size()}&quot;</span>
<span class="w">    </span><span class="o">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Got</span><span class="p">:</span> <span class="n">alpha</span><span class="p">;</span> <span class="nb">len</span><span class="p">:</span> <span class="mi">5</span>
<span class="n">Got</span><span class="p">:</span> <span class="n">beta</span><span class="p">;</span> <span class="nb">len</span><span class="p">:</span> <span class="mi">4</span>
<span class="n">Got</span><span class="p">:</span> <span class="k">lambda</span><span class="p">;</span> <span class="nb">len</span><span class="p">:</span> <span class="mi">6</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">subscribe</span></code> operator may accept one or more of the following event handlers:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">onNext</span></code>: function that is invoked whenever the channel emits a value. Equivalent to using the <code class="docutils literal notranslate"><span class="pre">subscribe</span></code> with a plain closure as described in the examples above.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">onComplete</span></code>: function that is invoked after the last value is emitted by the channel.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">onError</span></code>: function that it is invoked when an exception is raised while handling the <code class="docutils literal notranslate"><span class="pre">onNext</span></code> event. It will not make further calls to <code class="docutils literal notranslate"><span class="pre">onNext</span></code> or <code class="docutils literal notranslate"><span class="pre">onComplete</span></code>. The <code class="docutils literal notranslate"><span class="pre">onError</span></code> method takes as its parameter the <code class="docutils literal notranslate"><span class="pre">Throwable</span></code> that caused the error.</p></li>
</ul>
<p>For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">subscribe</span><span class="w"> </span><span class="nl">onNext:</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">println</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">},</span><span class="w"> </span><span class="nl">onComplete:</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">println</span><span class="w"> </span><span class="s1">&#39;Done&#39;</span><span class="w"> </span><span class="o">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span>
<span class="mi">2</span>
<span class="mi">3</span>
<span class="n">Done</span>
</pre></div>
</div>
</section>
<section id="sum">
<span id="operator-sum"></span><h2>sum<a class="headerlink" href="#sum" title="Permalink to this heading"></a></h2>
<p><em>Returns: value channel</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">sum</span></code> operator creates a channel that emits the sum of all the items emitted by the channel itself. For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="w"> </span><span class="mi">8</span><span class="o">,</span><span class="w"> </span><span class="mi">6</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">sum</span><span class="o">()</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="s2">&quot;The sum is $it&quot;</span><span class="w"> </span><span class="o">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">The</span> <span class="nb">sum</span> <span class="ow">is</span> <span class="mi">21</span>
</pre></div>
</div>
<p>An optional <a class="reference internal" href="script.html#script-closure"><span class="std std-ref">closure</span></a> parameter can be specified in order to provide a function that, given an item, returns the value to be summed. For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="w"> </span><span class="mi">4</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">7</span><span class="o">,</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">sum</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="s2">&quot;Square: $it&quot;</span><span class="w"> </span><span class="o">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Square</span><span class="p">:</span> <span class="mi">91</span>
</pre></div>
</div>
</section>
<section id="take">
<h2>take<a class="headerlink" href="#take" title="Permalink to this heading"></a></h2>
<p><em>Returns: queue channel</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">take</span></code> operator allows you to filter only the first <code class="docutils literal notranslate"><span class="pre">n</span></code> items emitted by a channel. For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mi">4</span><span class="o">,</span><span class="w"> </span><span class="mi">5</span><span class="o">,</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">take</span><span class="o">(</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">subscribe</span><span class="w"> </span><span class="nl">onNext:</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">println</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">},</span><span class="w"> </span><span class="nl">onComplete:</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">println</span><span class="w"> </span><span class="s1">&#39;Done&#39;</span><span class="w"> </span><span class="o">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span>
<span class="mi">2</span>
<span class="mi">3</span>
<span class="n">Done</span>
</pre></div>
</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Specifying a size of <code class="docutils literal notranslate"><span class="pre">-1</span></code> causes the operator to take all values.</p>
</div>
<p>See also <a class="reference internal" href="#until"><span class="std std-doc">until</span></a>.</p>
</section>
<section id="tap">
<h2>tap<a class="headerlink" href="#tap" title="Permalink to this heading"></a></h2>
<p><em>Returns: queue channel</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">tap</span></code> operator is like the <a class="reference internal" href="#set"><span class="std std-doc">set</span></a> operator in that it assigns a source channel to a new target channel.
but it also emits the source channel for downstream use. This operator is a useful way to extract intermediate
output channels from a chain of operators. For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="w"> </span><span class="o">(</span><span class="w"> </span><span class="s1">&#39;a&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;b&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;c&#39;</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">tap</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">log1</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="o">.</span><span class="na">map</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="o">.</span><span class="na">tap</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">log2</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="o">.</span><span class="na">map</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">it</span><span class="o">.</span><span class="na">toUpperCase</span><span class="o">()</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="s2">&quot;Result: $it&quot;</span><span class="w"> </span><span class="o">}</span>

<span class="n">log1</span><span class="o">.</span><span class="na">view</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="s2">&quot;Log 1: $it&quot;</span><span class="w"> </span><span class="o">}</span>
<span class="n">log2</span><span class="o">.</span><span class="na">view</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="s2">&quot;Log 2: $it&quot;</span><span class="w"> </span><span class="o">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Result</span><span class="p">:</span> <span class="n">AA</span>
<span class="n">Result</span><span class="p">:</span> <span class="n">BB</span>
<span class="n">Result</span><span class="p">:</span> <span class="n">CC</span>

<span class="n">Log</span> <span class="mi">1</span><span class="p">:</span> <span class="n">a</span>
<span class="n">Log</span> <span class="mi">1</span><span class="p">:</span> <span class="n">b</span>
<span class="n">Log</span> <span class="mi">1</span><span class="p">:</span> <span class="n">c</span>

<span class="n">Log</span> <span class="mi">2</span><span class="p">:</span> <span class="n">aa</span>
<span class="n">Log</span> <span class="mi">2</span><span class="p">:</span> <span class="n">bb</span>
<span class="n">Log</span> <span class="mi">2</span><span class="p">:</span> <span class="n">cc</span>
</pre></div>
</div>
</section>
<section id="tointeger">
<h2>toInteger<a class="headerlink" href="#tointeger" title="Permalink to this heading"></a></h2>
<p><em>Returns: queue channel</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">toInteger</span></code> operator allows you to convert the string values emitted by a channel to <code class="docutils literal notranslate"><span class="pre">Integer</span></code> values. For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="w"> </span><span class="s1">&#39;1&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;7&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;12&#39;</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">toInteger</span><span class="o">()</span>
<span class="w">    </span><span class="o">.</span><span class="na">sum</span><span class="o">()</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>
</pre></div>
</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>You can also use <code class="docutils literal notranslate"><span class="pre">toLong</span></code>, <code class="docutils literal notranslate"><span class="pre">toFloat</span></code>, and <code class="docutils literal notranslate"><span class="pre">toDouble</span></code> to convert to other numerical types.</p>
</div>
</section>
<section id="tolist">
<h2>toList<a class="headerlink" href="#tolist" title="Permalink to this heading"></a></h2>
<p><em>Returns: value channel</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">toList</span></code> operator collects all the items emitted by a channel to a <code class="docutils literal notranslate"><span class="pre">List</span></code> object and emits the resulting collection as a single item. For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">toList</span><span class="o">()</span>
<span class="w">    </span><span class="o">.</span><span class="na">subscribe</span><span class="w"> </span><span class="nl">onNext:</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">println</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">},</span><span class="w"> </span><span class="nl">onComplete:</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">println</span><span class="w"> </span><span class="s1">&#39;Done&#39;</span><span class="w"> </span><span class="o">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="n">Done</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There are two differences between <code class="docutils literal notranslate"><span class="pre">toList</span></code> and <code class="docutils literal notranslate"><span class="pre">collect</span></code>:</p>
<ul class="simple">
<li><p>When there is no input, <code class="docutils literal notranslate"><span class="pre">toList</span></code> emits an empty list whereas <code class="docutils literal notranslate"><span class="pre">collect</span></code> emits nothing.</p></li>
<li><p>By default, <code class="docutils literal notranslate"><span class="pre">collect</span></code> flattens list items by one level.</p></li>
</ul>
<p>In other words, <code class="docutils literal notranslate"><span class="pre">toList</span></code> is equivalent to:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">collect</span><span class="o">(</span><span class="nl">flat:</span><span class="w"> </span><span class="kc">false</span><span class="o">).</span><span class="na">ifEmpty</span><span class="o">([])</span>
</pre></div>
</div>
</div>
<p>See also: <a class="reference internal" href="#collect"><span class="std std-doc">collect</span></a> operator.</p>
</section>
<section id="tosortedlist">
<h2>toSortedList<a class="headerlink" href="#tosortedlist" title="Permalink to this heading"></a></h2>
<p><em>Returns: value channel</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">toSortedList</span></code> operator collects all the items emitted by a channel to a <code class="docutils literal notranslate"><span class="pre">List</span></code> object where they are sorted and emits the resulting collection as a single item. For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">toSortedList</span><span class="o">()</span>
<span class="w">    </span><span class="o">.</span><span class="na">subscribe</span><span class="w"> </span><span class="nl">onNext:</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">println</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">},</span><span class="w"> </span><span class="nl">onComplete:</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">println</span><span class="w"> </span><span class="s1">&#39;Done&#39;</span><span class="w"> </span><span class="o">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="n">Done</span>
</pre></div>
</div>
<p>You may also pass a comparator closure as an argument to the <code class="docutils literal notranslate"><span class="pre">toSortedList</span></code> operator to customize the sorting criteria. For example, to sort by the second element of a tuple in descending order:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="w"> </span><span class="o">[</span><span class="s2">&quot;homer&quot;</span><span class="o">,</span><span class="w"> </span><span class="mi">5</span><span class="o">],</span><span class="w"> </span><span class="o">[</span><span class="s2">&quot;bart&quot;</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">],</span><span class="w"> </span><span class="o">[</span><span class="s2">&quot;lisa&quot;</span><span class="o">,</span><span class="w"> </span><span class="mi">10</span><span class="o">],</span><span class="w"> </span><span class="o">[</span><span class="s2">&quot;marge&quot;</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">],</span><span class="w"> </span><span class="o">[</span><span class="s2">&quot;maggie&quot;</span><span class="o">,</span><span class="w"> </span><span class="mi">7</span><span class="o">]</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">toSortedList</span><span class="o">(</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">a</span><span class="o">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="w"> </span><span class="o">&lt;=&gt;</span><span class="w"> </span><span class="n">a</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="w"> </span><span class="o">}</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="n">lisa</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="n">maggie</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="n">homer</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="n">marge</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="n">bart</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
</pre></div>
</div>
<p>See also: <a class="reference internal" href="#collect"><span class="std std-doc">collect</span></a> operator.</p>
</section>
<section id="transpose">
<h2>transpose<a class="headerlink" href="#transpose" title="Permalink to this heading"></a></h2>
<p><em>Returns: queue channel</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">transpose</span></code> operator transforms a channel in such a way that the emitted items are the result of a transposition of all tuple elements in each item. For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span><span class="o">.</span><span class="na">of</span><span class="o">(</span>
<span class="w">        </span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="o">[</span><span class="s1">&#39;A&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;B&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;C&#39;</span><span class="o">]],</span>
<span class="w">        </span><span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="o">[</span><span class="s1">&#39;C&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;A&#39;</span><span class="o">]],</span>
<span class="w">        </span><span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="o">[</span><span class="s1">&#39;B&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;D&#39;</span><span class="o">]]</span>
<span class="w">    </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">transpose</span><span class="o">()</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>
</pre></div>
</div>
<p>The above snippet prints:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">A</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">B</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">C</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">C</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">A</span><span class="p">]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="n">B</span><span class="p">]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="n">D</span><span class="p">]</span>
</pre></div>
</div>
<p>If each element of the channel has more than 2 items, these will be flattened by the first item in the element and only emit an element when the element is complete:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span><span class="o">.</span><span class="na">of</span><span class="o">(</span>
<span class="w">        </span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="o">[</span><span class="mi">1</span><span class="o">],</span><span class="w"> </span><span class="o">[</span><span class="s1">&#39;A&#39;</span><span class="o">]],</span>
<span class="w">        </span><span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">],</span><span class="w"> </span><span class="o">[</span><span class="s1">&#39;B&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;C&#39;</span><span class="o">]],</span>
<span class="w">        </span><span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">],</span><span class="w"> </span><span class="o">[</span><span class="s1">&#39;D&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;E&#39;</span><span class="o">]]</span>
<span class="w">    </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">transpose</span><span class="o">()</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">A</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">B</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">C</span><span class="p">]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">D</span><span class="p">]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">E</span><span class="p">]</span>
</pre></div>
</div>
<p>To emit all elements, use <code class="docutils literal notranslate"><span class="pre">remainder:</span> <span class="pre">true</span></code>:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span><span class="o">.</span><span class="na">of</span><span class="o">(</span>
<span class="w">        </span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="o">[</span><span class="mi">1</span><span class="o">],</span><span class="w"> </span><span class="o">[</span><span class="s1">&#39;A&#39;</span><span class="o">]],</span>
<span class="w">        </span><span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">],</span><span class="w"> </span><span class="o">[</span><span class="s1">&#39;B&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;C&#39;</span><span class="o">]],</span>
<span class="w">        </span><span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">],</span><span class="w"> </span><span class="o">[</span><span class="s1">&#39;D&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;E&#39;</span><span class="o">]]</span>
<span class="w">    </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">transpose</span><span class="o">(</span><span class="nl">remainder:</span><span class="w"> </span><span class="kc">true</span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">A</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">B</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">C</span><span class="p">]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">D</span><span class="p">]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">E</span><span class="p">]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">null</span><span class="p">]</span>
</pre></div>
</div>
<p>Available options:</p>
<dl class="simple myst">
<dt><code class="docutils literal notranslate"> <span class="pre">by</span></code></dt><dd><p>The index (zero based) of the element to be transposed. Multiple elements can be defined specifying as list of indices e.g. <code class="docutils literal notranslate"><span class="pre">by:</span> <span class="pre">[0,2]</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"> <span class="pre">remainder</span></code></dt><dd><p>When <code class="docutils literal notranslate"><span class="pre">false</span></code> incomplete tuples are discarded (default). When <code class="docutils literal notranslate"><span class="pre">true</span></code> incomplete tuples are emitted containing a <code class="docutils literal notranslate"><span class="pre">null</span></code> in place of a missing element.</p>
</dd>
</dl>
</section>
<section id="unique">
<h2>unique<a class="headerlink" href="#unique" title="Permalink to this heading"></a></h2>
<p><em>Returns: queue channel</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">unique</span></code> operator allows you to remove duplicate items from a channel and only emit single items with no repetition.</p>
<p>For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">5</span><span class="o">,</span><span class="w"> </span><span class="mi">7</span><span class="o">,</span><span class="w"> </span><span class="mi">7</span><span class="o">,</span><span class="w"> </span><span class="mi">7</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">unique</span><span class="o">()</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span>
<span class="mi">5</span>
<span class="mi">7</span>
<span class="mi">3</span>
</pre></div>
</div>
<p>You can also specify an optional <a class="reference internal" href="script.html#script-closure"><span class="std std-ref">closure</span></a> that customizes the way it distinguishes between unique items. For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mi">4</span><span class="o">,</span><span class="w"> </span><span class="mi">5</span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">unique</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span>
<span class="mi">4</span>
</pre></div>
</div>
</section>
<section id="until">
<h2>until<a class="headerlink" href="#until" title="Permalink to this heading"></a></h2>
<p><em>Returns: queue channel</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">until</span></code> operator creates a channel that returns the items emitted by the source channel and stop when the condition specified is verified. For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span>
<span class="w">    </span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">5</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">until</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="o">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">3</span>
<span class="mi">2</span>
<span class="mi">1</span>
</pre></div>
</div>
<p>See also <a class="reference internal" href="#take"><span class="std std-doc">take</span></a>.</p>
</section>
<section id="view">
<span id="operator-view"></span><h2>view<a class="headerlink" href="#view" title="Permalink to this heading"></a></h2>
<p><em>Returns: queue channel</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">view</span></code> operator prints the items emitted by a channel to the console standard output. For example:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">).</span><span class="na">view</span><span class="o">()</span>

<span class="mi">1</span>
<span class="mi">2</span>
<span class="mi">3</span>
</pre></div>
</div>
<p>Each item is printed on a separate line unless otherwise specified by using the <code class="docutils literal notranslate"><span class="pre">newLine:</span> <span class="pre">false</span></code> optional parameter.</p>
<p>How the channel items are printed can be controlled by using an optional closure parameter. The closure must return the actual value of the item to be printed:</p>
<div class="highlight-groovy notranslate"><div class="highlight"><pre><span></span><span class="n">Channel</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">)</span>
<span class="w">    </span><span class="o">.</span><span class="na">map</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">[</span><span class="n">it</span><span class="o">,</span><span class="w"> </span><span class="n">it</span><span class="o">*</span><span class="n">it</span><span class="o">]</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="o">.</span><span class="na">view</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">num</span><span class="o">,</span><span class="w"> </span><span class="n">sqr</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s2">&quot;Square of: $num is $sqr&quot;</span><span class="w"> </span><span class="o">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Square</span> <span class="n">of</span><span class="p">:</span> <span class="mi">1</span> <span class="ow">is</span> <span class="mi">1</span>
<span class="n">Square</span> <span class="n">of</span><span class="p">:</span> <span class="mi">2</span> <span class="ow">is</span> <span class="mi">4</span>
<span class="n">Square</span> <span class="n">of</span><span class="p">:</span> <span class="mi">3</span> <span class="ow">is</span> <span class="mi">9</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">view</span></code> operator also emits every item that it receives, allowing it to be chained with other operators.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="channel.html" class="btn btn-neutral float-left" title="Channels" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="workflow.html" class="btn btn-neutral float-right" title="Workflows" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Seqera Labs, S.L.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
     
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-TNCXSWG"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->


</body>
</html>