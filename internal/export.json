[
  {
    "slug": "2014/nextflow-meets-docker",
    "title": "Reproducibility in Science - Nextflow meets Docker",
    "date": "2014-09-09T00:00:00.000Z",
    "content": "The scientific world nowadays operates on the basis of published articles.\nThese are used to report novel discoveries to the rest of the scientific community.\n\nBut have you ever wondered what a scientific article is? It is a:\n\n1. defeasible argument for claims, supported by\n2. exhibited, reproducible data and methods, and\n3. explicit references to other work in that domain;\n4. described using domain-agreed technical terminology,\n5. which exists within a complex ecosystem of technologies, people and activities.\n\nHence the very essence of Science relies on the ability of scientists to reproduce and\nbuild upon each other’s published results.\n\nSo how much can we rely on published data? In a recent report in Nature, researchers at the\nAmgen corporation found that only 11% of the academic research in the literature was\nreproducible by their groups [[1](http://www.nature.com/nature/journal/v483/n7391/full/483531a.html)].\n\nWhile many factors are likely at play here, perhaps the most basic requirement for\nreproducibility holds that the materials reported in a study can be uniquely identified\nand obtained, such that experiments can be reproduced as faithfully as possible.\nThis information is meant to be documented in the \"materials and methods\" of journal articles,\nbut as many can attest, the information provided there is often not adequate for this task.\n\n### Promoting Computational Research Reproducibility\n\nEncouragingly scientific reproducibility has been at the forefront of many news stories\nand there exist numerous initiatives to help address this problem. Particularly, when it\ncomes to producing reproducible computational analyses, some publications are starting\nto publish the code and data used for analysing and generating figures.\n\nFor example, many articles in Nature and in the new Elife journal (and others) provide a\n\"source data\" download link next to figures. Sometimes Elife might even have an option\nto download the source code for figures.\n\nAs pointed out by Melissa Gymrek [in a recent post](http://melissagymrek.com/science/2014/08/29/docker-reproducible-research.html)\nthis is a great start, but there are still lots of problems. She wrote that, for example, if one wants\nto re-execute a data analyses from these papers, he/she will have to download the\nscripts and the data, to only realize that he/she has not all the required libraries,\nor that it only runs on, for example, an Ubuntu version he/she doesn't have, or some\npaths are hard-coded to match the authors' machine.\n\nIf it's not easy to run and doesn't run out of the box the chances that a researcher\nwill actually ever run most of these scripts is close to zero, especially if they lack\nthe time or expertise to manage the required installation of third-party libraries,\ntools or implement from scratch state-of-the-art data processing algorithms.\n\n### Here comes Docker\n\n[Docker](http://www.docker.com) containers technology is a solution to many of the computational\nresearch reproducibility problems. Basically, it is a kind of a lightweight virtual machine\nwhere you can set up a computing environment including all the libraries, code and data that you need,\nwithin a single _image_.\n\nThis image can be distributed publicly and can seamlessly run on any major Linux operating system.\nNo need for the user to mess with installation, paths, etc.\n\nThey just run the Docker image you provided, and everything is set up to work out of the box.\nResearchers have already started discussing this (e.g. [here](http://www.bioinformaticszen.com/post/reproducible-assembler-benchmarks/),\nand [here](https://bcbio.wordpress.com/2014/03/06/improving-reproducibility-and-installation-of-genomic-analysis-pipelines-with-docker/)).\n\n### Docker and Nextflow: a perfect match\n\nOne big advantage Docker has compared to _traditional_ machine virtualisation technology\nis that it doesn't need a complete copy of the operating system, thus it has a minimal\nstartup time. This makes it possible to virtualise single applications or launch the execution\nof multiple containers, that can run in parallel, in order to speedup a large computation.\n\nNextflow is a data-driven toolkit for computational pipelines, which aims to simplify the deployment of\ndistributed and highly parallelised pipelines for scientific applications.\n\nThe latest version integrates the support for Docker containers that enables the deployment\nof self-contained and truly reproducible pipelines.\n\n### How they work together\n\nA Nextflow pipeline is made up by putting together several processes. Each process\ncan be written in any scripting language that can be executed by the Linux platform\n(BASH, Perl, Ruby, Python, etc). Parallelisation is automatically managed\nby the framework and it is implicitly defined by the processes input and\noutput declarations.\n\nBy integrating Docker with Nextflow, every pipeline process can be executed independently\nin its own container, this guarantees that each of them run in a predictable\nmanner without worrying about the configuration of the target execution platform. Moreover the\nminimal overhead added by Docker allows us to spawn multiple container executions in a parallel\nmanner with a negligible performance loss when compared to a platform _native_ execution.\n\n### An example\n\nAs a proof of concept of the Docker integration with Nextflow you can try out the\npipeline example at this [link](https://github.com/nextflow-io/examples/blob/master/blast-parallel.nf).\n\nIt splits a protein sequences multi FASTA file into chunks of _n_ entries, executes a BLAST query\nfor each of them, then extracts the top 10 matching sequences and\nfinally aligns the results with the T-Coffee multiple sequence aligner.\n\nIn a common scenario you generally need to install and configure the tools required by this\nscript: BLAST and T-Coffee. Moreover you should provide a formatted protein database in order\nto execute the BLAST search.\n\nBy using Docker with Nextflow you only need to have the Docker engine installed in your\ncomputer and a Java VM. In order to try this example out, follow these steps:\n\nInstall the latest version of Nextflow by entering the following command in your shell terminal:\n\n     curl -fsSL get.nextflow.io | bash\n\nThen download the required Docker image with this command:\n\n     docker pull nextflow/examples\n\nYou can check the content of the image looking at the [Dockerfile](https://github.com/nextflow-io/examples/blob/master/Dockerfile)\nused to create it.\n\nNow you are ready to run the demo by launching the pipeline execution as shown below:\n\n    nextflow run examples/blast-parallel.nf -with-docker\n\nThis will run the pipeline printing the final alignment out on the terminal screen.\nYou can also provide your own protein sequences multi FASTA file by adding, in the above command line,\nthe option `--query <file>` and change the splitting chunk size with `--chunk n` option.\n\nNote: the result doesn't have a real biological meaning since it uses a very small protein database.\n\n### Conclusion\n\nThe mix of Docker, GitHub and Nextflow technologies make it possible to deploy\nself-contained and truly replicable pipelines. It requires zero configuration and\nenables the reproducibility of data analysis pipelines in any system in which a Java VM and\nthe Docker engine are available.\n\n### Learn how to do it!\n\nFollow our documentation for a quick start using Docker with Nextflow at\nthe following link https://www.nextflow.io/docs/latest/docker.html\n</file>",
    "images": [],
    "author": "Maria Chatzou",
    "tags": "docker,github,reproducibility,data-analysis"
  },
  {
    "slug": "2014/share-nextflow-pipelines-with-github",
    "title": "Share Nextflow pipelines with GitHub",
    "date": "2014-08-07T00:00:00.000Z",
    "content": "The [GitHub](https://github.com) code repository and collaboration platform is widely\nused between researchers to publish their work and to collaborate on projects source code.\n\nEven more interestingly a few months ago [GitHub announced improved support for researchers](https://github.com/blog/1840-improving-github-for-science)\nmaking it possible to get a Digital Object Identifier (DOI) for any GitHub repository archive.\n\nWith a DOI for your GitHub repository archive your code becomes formally citable\nin scientific publications.\n\n### Why use GitHub with Nextflow?\n\nThe latest Nextflow release (0.9.0) seamlessly integrates with GitHub.\nThis feature allows you to manage your code in a more consistent manner, or use other\npeople's Nextflow pipelines, published through GitHub, in a quick and transparent manner.\n\n### How it works\n\nThe idea is very simple, when you launch a script execution with Nextflow, it will look for\na file with the pipeline name you've specified. If that file does not exist,\nit will look for a public repository with the same name on GitHub. If it is found, the\nrepository is automatically downloaded to your computer and the code executed. This repository\nis stored in the Nextflow home directory, by default `$HOME/.nextflow`, thus it will be reused\nfor any further execution.\n\nYou can try this feature out, having Nextflow (version 0.9.0 or higher) installed in your computer,\nby simply entering the following command in your shell terminal:\n\n    nextflow run nextflow-io/hello\n\nThe first time you execute this command Nextflow will download the pipeline\nat the following GitHub repository `https://github.com/nextflow-io/hello`,\nas you don't already have it in your computer. It will then execute it producing the expected output.\n\nIn order for a GitHub repository to be used as a Nextflow project, it must\ncontain at least one file named `main.nf` that defines your Nextflow pipeline script.\n\n### Run a specific revision\n\nAny Git branch, tag or commit ID in the GitHub repository can be used to specify a revision,\nthat you want to execute, when running your pipeline by adding the `-r` option to the run command line.\nSo for example you could enter:\n\n    nextflow run nextflow-io/hello -r mybranch\n\nor\n\n    nextflow run nextflow-io/hello -r v1.1\n\nThis can be very useful when comparing different versions of your project.\nIt also guarantees consistent results in your pipeline as your source code evolves.\n\n### Commands to manage pipelines\n\nThe following commands allows you to perform some basic operations that can be used to manage your pipelines.\nAnyway Nextflow is not meant to replace functionalities provided by the [Git](http://git-scm.com/) tool,\nyou may still need it to create new repositories or commit changes, etc.\n\n#### List available pipelines\n\nThe `ls` command allows you to list all the pipelines you have downloaded in\nyour computer. For example:\n\n    nextflow ls\n\nThis prints a list similar to the following one:\n\n    cbcrg/piper-nf\n    nextflow-io/hello\n\n#### Show pipeline information\n\nBy using the `info` command you can show information from a downloaded pipeline. For example:\n\n    $ nextflow info hello\n\nThis command prints:\n\n     repo name  : nextflow-io/hello\n     home page  : http://github.com/nextflow-io/hello\n     local path : $HOME/.nextflow/assets/nextflow-io/hello\n     main script: main.nf\n     revisions  :\n     * master (default)\n       mybranch\n       v1.1 [t]\n       v1.2 [t]\n\nStarting from the top it shows: 1) the repository name; 2) the project home page; 3) the local folder where the pipeline has been downloaded; 4) the script that is executed\nwhen launched; 5) the list of available revisions i.e. branches + tags. Tags are marked with\na `[t]` on the right, the current checked-out revision is marked with a `*` on the left.\n\n#### Pull or update a pipeline\n\nThe `pull` command allows you to download a pipeline from a GitHub repository or to update\nit if that repository has already been downloaded. For example:\n\n    nextflow pull nextflow-io/examples\n\nDownloaded pipelines are stored in the folder `$HOME/.nextflow/assets` in your computer.\n\n#### Clone a pipeline into a folder\n\nThe `clone` command allows you to copy a Nextflow pipeline project to a directory of your choice. For example:\n\n    nextflow clone nextflow-io/hello target-dir\n\nIf the destination directory is omitted the specified pipeline is cloned to a directory\nwith the same name as the pipeline _base_ name (e.g. `hello`) in the current folder.\n\nThe clone command can be used to inspect or modify the source code of a pipeline. You can\neventually commit and push back your changes by using the usual Git/GitHub workflow.\n\n#### Drop an installed pipeline\n\nDownloaded pipelines can be deleted by using the `drop` command, as shown below:\n\n    nextflow drop nextflow-io/hello\n\n### Limitations and known problems\n\n- ~~GitHub private repositories currently are not supported~~ Support for private GitHub repositories has been introduced with version 0.10.0.\n- ~~Symlinks committed in a Git repository are not resolved correctly\n  when downloaded/cloned by Nextflow~~ Symlinks are resolved correctly when using Nextflow version 0.11.0 (or higher).",
    "images": [],
    "author": "Paolo Di Tommaso",
    "tags": "git,github,reproducibility"
  },
  {
    "slug": "2014/using-docker-in-hpc-cluster",
    "title": "Using Docker for scientific data analysis in an HPC cluster",
    "date": "2014-11-06T00:00:00.000Z",
    "content": "Scientific data analysis pipelines are rarely composed by a single piece of software.\nIn a real world scenario, computational pipelines are made up of multiple stages, each of which\ncan execute many different scripts, system commands and external tools deployed in a hosting computing\nenvironment, usually an HPC cluster.\n\nAs I work as a research engineer in a bioinformatics lab I experience on a daily basis the\ndifficulties related on keeping such a piece of software consistent.\n\nComputing environments can change frequently in order to test new pieces of software or\nmaybe because system libraries need to be updated. For this reason replicating the results\nof a data analysis over time can be a challenging task.\n\n[Docker](http://www.docker.com) has emerged recently as a new type of virtualisation technology that allows one\nto create a self-contained runtime environment. There are plenty of examples\nshowing the benefits of using it to run application services, like web servers\nor databases.\n\nHowever it seems that few people have considered using Docker for the deployment of scientific\ndata analysis pipelines on distributed cluster of computer, in order to simplify the development,\nthe deployment and the replicability of this kind of applications.\n\nFor this reason I wanted to test the capabilities of Docker to solve these problems in the\ncluster available in our [institute](http://www.crg.eu).\n\n## Method\n\nThe Docker engine has been installed in each node of our cluster, that runs a [Univa grid engine](http://www.univa.com/products/grid-engine.php) resource manager.\nA Docker private registry instance has also been installed in our internal network, so that images\ncan be pulled from the local repository in a much faster way when compared to the public\n[Docker registry](http://registry.hub.docker.com).\n\nMoreover the Univa grid engine has been configured with a custom [complex](http://www.gridengine.eu/mangridengine/htmlman5/complex.html)\nresource type. This allows us to request a specific Docker image as a resource type while\nsubmitting a job execution to the cluster.\n\nThe Docker image is requested as a _soft_ resource, by doing that the UGE scheduler\ntries to run a job to a node where that image has already been pulled,\notherwise a lower priority is given to it and it is executed, eventually, by a node where\nthe specified Docker image is not available. This will force the node to pull the required\nimage from the local registry at the time of the job execution.\n\nThis environment has been tested with [Piper-NF](https://github.com/cbcrg/piper-nf), a genomic pipeline for the\ndetection and mapping of long non-coding RNAs.\n\nThe pipeline runs on top of Nextflow, which takes care of the tasks parallelisation and submits\nthe jobs for execution to the Univa grid engine.\n\nThe Piper-NF code wasn't modified in order to run it using Docker.\nNextflow is able to handle it automatically. The Docker containers are run in such a way that\nthe tasks result files are created in the hosting file system, in other\nwords it behaves in a completely transparent manner without requiring extra steps or affecting\nthe flow of the pipeline execution.\n\nIt was only necessary to specify the Docker image (or images) to be used in the Nextflow\nconfiguration file for the pipeline. You can read more about this at [this link](https://www.nextflow.io/docs/latest/docker.html).\n\n## Results\n\nTo benchmark the impact of Docker on the pipeline performance a comparison was made running\nit with and without Docker.\n\nFor this experiment 10 cluster nodes were used. The pipeline execution launches around 100 jobs,\nand it was run 5 times by using the same dataset with and without Docker.\n\nThe average execution time without Docker was 28.6 minutes, while the average\npipeline execution time, running each job in a Docker container, was 32.2 minutes.\nThus, by using Docker the overall execution time increased by something around 12.5%.\n\nIt is important to note that this time includes both the Docker bootstrap time,\nand the time overhead that is added to the task execution by the virtualisation layer.\n\nFor this reason the actual task run time was measured as well i.e. without including the\nDocker bootstrap time overhead. In this case, the aggregate average task execution time was 57.3 minutes\nand 59.5 minutes when running the same tasks using Docker. Thus, the time overhead\nadded by the Docker virtualisation layer to the effective task run time can be estimated\nto around 4% in our test.\n\nKeeping the complete toolset required by the pipeline execution within a Docker image dramatically\nreduced configuration and deployment problems. Also storing these images into the private and\n[public](https://registry.hub.docker.com/repos/cbcrg/) repositories with a unique tag allowed us\nto replicate the results without the usual burden required to set-up an identical computing environment.\n\n## Conclusion\n\nThe fast start-up time for Docker containers technology allows one to virtualise a single process or\nthe execution of a bunch of applications, instead of a complete operating system. This opens up new possibilities,\nfor example the possibility to \"virtualise\" distributed job executions in an HPC cluster of computers.\n\nThe minimal performance loss introduced by the Docker engine is offset by the advantages of running\nyour analysis in a self-contained and dead easy to reproduce runtime environment, which guarantees\nthe consistency of the results over time and across different computing platforms.\n\n#### Credits\n\nThanks to Arnau Bria and the all scientific systems admins team to manage the Docker installation\nin the CRG computing cluster.",
    "images": [],
    "author": "Paolo Di Tommaso",
    "tags": "docker,reproducibility,data-analysis,hpc"
  },
  {
    "slug": "2015/innovation-in-science-the-story-behind-nextflow",
    "title": "Innovation In Science - The story behind Nextflow",
    "date": "2015-06-09T00:00:00.000Z",
    "content": "Innovation can be viewed as the application of solutions that meet new requirements or\nexisting market needs. Academia has traditionally been the driving force of innovation.\nScientific ideas have shaped the world, but only a few of them were brought to market by\nthe inventing scientists themselves, resulting in both time and financial loses.\n\nLately there have been several attempts to boost scientific innovation and translation,\nwith most notable in Europe being the Horizon 2020 funding program. The problem with these\ntypes of funding is that they are not designed for PhDs and Postdocs, but rather aim to\npromote the collaboration of senior scientists in different institutions. This neglects two\nvery important facts, first and foremost that most of the Nobel prizes were given for\ndiscoveries made when scientists were in their 20's / 30's (not in their 50's / 60's).\nSecondly, innovation really happens when a few individuals (not institutions) face a\nproblem in their everyday life/work, and one day they just decide to do something about it\n(end-user innovation). Without realizing, these people address a need that many others have.\nThey don’t do it for the money or the glory; they do it because it bothers them!\nMany examples of companies that started exactly this way include Apple, Google, and\nVirgin Airlines.\n\n### The story of Nextflow\n\nSimilarly, Nextflow started as an attempt to solve the every-day computational problems we\nwere facing with “big biomedical data” analyses. We wished that our huge and almost cryptic\nBASH-based pipelines could handle parallelization automatically. In our effort to make that\nhappen we stumbled upon the [Dataflow](http://en.wikipedia.org/wiki/Dataflow_programming)\nprogramming model and Nextflow was created.\nWe were getting furious every time our two-week long pipelines were crashing and we had\nto re-execute them from the beginning. We, therefore, developed a caching system, which\nallows Nextflow to resume any pipeline from the last executed step. While we were really\nenjoying developing a new [DSL](http://en.wikipedia.org/wiki/Domain-specific_language) and\ncreating our own operators, at the same time we were not willing to give up our favorite\nPerl/Python scripts and one-liners, and thus Nextflow became a polyglot.\n\nAnother problem we were facing was that our pipelines were invoking a lot of\nthird-party software, making distribution and execution on different platforms a nightmare.\nOnce again while searching for a solution to this problem, we were able to identify a\nbreakthrough technology [Docker](https://www.docker.com/), which is now revolutionising\ncloud computation. Nextflow has been one of the first framework, that fully\nsupports Docker containers and allows pipeline execution in an isolated and easy to distribute manner.\nOf course, sharing our pipelines with our friends rapidly became a necessity and so we had\nto make Nextflow smart enough to support [Github](https://github.com) and [Bitbucket](https://bitbucket.org/) integration.\n\nI don’t know if Nextflow will make as much difference in the world as the Dataflow\nprogramming model and Docker container technology are making, but it has already made a\nbig difference in our lives and that is all we ever wanted…\n\n### Conclusion\n\nSummarising, it is a pity that PhDs and Postdocs are the neglected engine of Innovation.\nThey are not empowered to innovate, by identifying and addressing their needs, and to\npotentially set up commercial solutions to their problems. This fact becomes even sadder\nwhen you think that only 3% of Postdocs have a chance to become PIs in the UK. Instead more\nand more money is being invested into the senior scientists who only require their PhD students\nand Postdocs to put another step into a well-defined ladder. In todays world it seems that\nideas, such as Nextflow, will only get funded for their scientific value, not as innovative\nconcepts trying to address a need.",
    "images": [],
    "author": "Maria Chatzou",
    "tags": "innovation,science,pipelines,nextflow"
  },
  {
    "slug": "2015/introducing-nextflow-console",
    "title": "Introducing Nextflow REPL Console",
    "date": "2015-04-14T00:00:00.000Z",
    "content": "The latest version of Nextflow introduces a new _console_ graphical interface.\n\nThe Nextflow console is a REPL ([read-eval-print loop](http://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop))\nenvironment that allows one to quickly test part of a script or pieces of Nextflow code\nin an interactive manner.\n\nIt is a handy tool that allows one to evaluate fragments of Nextflow/Groovy code\nor fast prototype a complete pipeline script.\n\n### Getting started\n\nThe console application is included in the latest version of Nextflow\n([0.13.1](https://github.com/nextflow-io/nextflow/releases) or higher).\n\nYou can try this feature out, having Nextflow installed on your computer, by entering the\nfollowing command in your shell terminal: `nextflow console `.\n\nWhen you execute it for the first time, Nextflow will spend a few seconds downloading\nthe required runtime dependencies. When complete the console window will appear as shown in\nthe picture below.\n\n<img src=\"/img/nextflow-console1.png\" alt=\"Nextflow console\" style=\"width: 100%; padding: 2em 1em;\">\n\nIt contains a text editor (the top white box) that allows you to enter and modify code snippets.\nThe results area (the bottom yellow box) will show the executed code's output.\n\nAt the top you will find the menu bar (not shown in this picture) and the actions\ntoolbar that allows you to open, save, execute (etc.) the code been tested.\n\nAs a practical execution example, simply copy and paste the following piece of code in the\nconsole editor box:\n\n    echo true\n\n    process sayHello {\n\n     \"\"\"\n     echo Hello world\n     \"\"\"\n\n    }\n\nThen, in order to evaluate it, open the `Script` menu in the top menu bar and select the `Run`\ncommand. Alternatively you can use the `CTRL+R` keyboard shortcut to run it (`⌘+R` on the Mac).\nIn the result box an output similar to the following will appear:\n\n    [warm up] executor &gt; local\n    [00/d78a0f] Submitted process &gt; sayHello (1)\n    Hello world\n\nNow you can try to modify the entered process script, execute it again and check that\nthe printed result has changed.\n\nIf the output doesn't appear, open the `View` menu and make sure that the entry `Capture Standard\nOutput` is selected (it must have a tick on the left).\n\nIt is worth noting that the global script context is maintained across script executions.\nThis means that variables declared in the global script scope are not lost when the\nscript run is complete, and they can be accessed in further executions of the same or another\npiece of code.\n\nIn order to reset the global context you can use the command `Clear Script Context`\navailable in the `Script` menu.\n\n### Conclusion\n\nThe Nextflow console is a REPL environment which allows you to experiment and get used\nto the Nextflow programming environment. By using it you can prototype or test your code\nwithout the need to create/edit script files.\n\nNote: the Nextflow console is implemented by sub-classing the [Groovy console](http://groovy-lang.org/groovyconsole.html) tool.\nFor this reason you may find some labels that refer to the Groovy programming environment\nin this program.",
    "images": [
      "/img/nextflow-console1.png"
    ],
    "author": "Paolo Di Tommaso",
    "tags": "data-analysis,pipelines,repl,groovy"
  },
  {
    "slug": "2015/mpi-like-execution-with-nextflow",
    "title": "MPI-like distributed execution with Nextflow",
    "date": "2015-11-13T00:00:00.000Z",
    "content": "The main goal of Nextflow is to make workflows portable across different\ncomputing platforms taking advantage of the parallelisation features provided\nby the underlying system without having to reimplement your application code.\n\nFrom the beginning Nextflow has included executors designed to target the most popular\nresource managers and batch schedulers commonly used in HPC data centers,\nsuch as [Univa Grid Engine](http://www.univa.com), [Platform LSF](http://www.ibm.com/systems/platformcomputing/products/lsf/),\n[SLURM](https://computing.llnl.gov/linux/slurm/), [PBS](http://www.pbsworks.com/Product.aspx?id=1) and [Torque](http://www.adaptivecomputing.com/products/open-source/torque/).\n\nWhen using one of these executors Nextflow submits the computational workflow tasks\nas independent job requests to the underlying platform scheduler, specifying\nfor each of them the computing resources needed to carry out its job.\n\nThis approach works well for workflows that are composed of long running tasks, which\nis the case of most common genomic pipelines.\n\nHowever this approach does not scale well for workloads made up of a large number of\nshort-lived tasks (e.g. a few seconds or sub-seconds). In this scenario the resource\nmanager scheduling time is much longer than the actual task execution time, thus resulting\nin an overall execution time that is much longer than the real execution time.\nIn some cases this represents an unacceptable waste of computing resources.\n\nMoreover supercomputers, such as [MareNostrum](https://www.bsc.es/marenostrum-support-services/mn3)\nin the [Barcelona Supercomputer Center (BSC)](https://www.bsc.es/), are optimized for\nmemory distributed applications. In this context it is needed to allocate a certain\namount of computing resources in advance to run the application in a distributed manner,\ncommonly using the [MPI](https://en.wikipedia.org/wiki/Message_Passing_Interface) standard.\n\nIn this scenario, the Nextflow execution model was far from optimal, if not unfeasible.\n\n### Distributed execution\n\nFor this reason, since the release 0.16.0, Nextflow has implemented a new distributed execution\nmodel that greatly improves the computation capability of the framework. It uses [Apache Ignite](https://ignite.apache.org/),\na lightweight clustering engine and in-memory data grid, which has been recently open sourced\nunder the Apache software foundation umbrella.\n\nWhen using this feature a Nextflow application is launched as if it were an MPI application.\nIt uses a job wrapper that submits a single request specifying all the needed computing\nresources. The Nextflow command line is executed by using the `mpirun` utility, as shown in the\nexample below:\n\n    #!/bin/bash\n    #$ -l virtual_free=120G\n    #$ -q <queue name=\"\">\n    #$ -N <job name=\"\">\n    #$ -pe ompi <nodes>\n    mpirun --pernode nextflow run <your-project-name> -with-mpi [pipeline parameters]\n\nThis tool spawns a Nextflow instance in each of the computing nodes allocated by the\ncluster manager.\n\nEach Nextflow instance automatically connects with the other peers creating an _private_\ninternal cluster, thanks to the Apache Ignite clustering feature that\nis embedded within Nextflow itself.\n\nThe first node becomes the application driver that manages the execution of the\nworkflow application, submitting the tasks to the remaining nodes that act as workers.\n\nWhen the application is complete, the Nextflow driver automatically shuts down the\nNextflow/Ignite cluster and terminates the job execution.\n\n![Nextflow distributed execution](/img/nextflow-distributed-execution.png)\n\n### Conclusion\n\nIn this way it is possible to deploy a Nextflow workload in a supercomputer using an\nexecution strategy that resembles the MPI distributed execution model. This doesn't\nrequire to implement your application using the MPI api/library and it allows you to\nmaintain your code portable across different execution platforms.\n\nAlthough we do not currently have a performance comparison between a Nextflow distributed\nexecution and an equivalent MPI application, we assume that the latter provides better\nperformance due to its low-level optimisation.\n\nNextflow, however, focuses on the fast prototyping of scientific applications in a portable\nmanner while maintaining the ability to scale and distribute the application workload in an\nefficient manner in an HPC cluster.\n\nThis allows researchers to validate an experiment, quickly, reusing existing tools and\nsoftware components. This eventually makes it possible to implement an optimised version\nusing a low-level programming language in the second stage of a project.\n\nRead the documentation to learn more about the [Nextflow distributed execution model](https://www.nextflow.io/docs/latest/ignite.html#execution-with-mpi).\n</your-project-name></nodes></job></queue>",
    "images": [],
    "author": "Paolo Di Tommaso",
    "tags": "mpi,hpc,pipelines,genomic"
  },
  {
    "slug": "2015/the-impact-of-docker-on-genomic-pipelines",
    "title": "The impact of Docker containers on the performance of genomic pipelines",
    "date": "2015-06-15T00:00:00.000Z",
    "content": "In a recent publication we assessed the impact of Docker containers technology\non the performance of bioinformatic tools and data analysis workflows.\n\nWe benchmarked three different data analyses: a RNA sequence pipeline for gene expression,\na consensus assembly and variant calling pipeline, and finally a pipeline for the detection\nand mapping of long non-coding RNAs.\n\nWe found that Docker containers have only a minor impact on the performance\nof common genomic data analysis, which is negligible when the executed tasks are demanding\nin terms of computational time.\n\n_[This publication is available as PeerJ preprint at this link](https://peerj.com/preprints/1171/)._",
    "images": [],
    "author": "Paolo Di Tommaso",
    "tags": "docker,reproducibility,pipelines,nextflow,genomic"
  },
  {
    "slug": "2016/best-practice-for-reproducibility",
    "title": "Workflows & publishing: best practice for reproducibility",
    "date": "2016-04-13T00:00:00.000Z",
    "content": "Publication time acts as a snapshot for scientific work. Whether a project is ongoing\nor not, work which was performed months ago must be described, new software documented,\ndata collated and figures generated.\n\nThe monumental increase in data and pipeline complexity has led to this task being\nperformed to many differing standards, or [lack of thereof](http://journals.plos.org/plosone/article?id=10.1371/journal.pone.0080278).\nWe all agree it is not good enough to simply note down the software version number.\nBut what practical measures can be taken?\n\nThe recent publication describing _Kallisto_ [(Bray et al. 2016)](https://doi.org/10.1038/nbt.3519)\nprovides an excellent high profile example of the growing efforts to ensure reproducible\nscience in computational biology. The authors provide a GitHub [repository](https://github.com/pachterlab/kallisto_paper_analysis)\nthat _“contains all the analysis to reproduce the results in the kallisto paper”_.\n\nThey should be applauded and indeed - in the Twittersphere - they were. The corresponding\nauthor Lior Pachter stated that the publication could be reproduced starting from raw\nreads in the NCBI Sequence Read Archive through to the results, which marks a fantastic\naccomplishment.\n\n&gt; Hoping people will notice [https://t.co/qiu3LFozMX](https://t.co/qiu3LFozMX) by [@yarbsalocin](https://twitter.com/yarbsalocin) [@hjpimentel](https://twitter.com/hjpimentel) [@pmelsted](https://twitter.com/pmelsted) reproducing ALL the [#kallisto](https://twitter.com/hashtag/kallisto?src=hash) paper from SRA→results\n&gt; \n&gt; — Lior Pachter (@lpachter) [April 5, 2016](https://twitter.com/lpachter/status/717279998424457216)\n\n<script async=\"\" src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\nThey achieve this utilising the workflow framework [Snakemake](https://bitbucket.org/snakemake/snakemake/wiki/Home).\nIncreasingly, we are seeing scientists applying workflow frameworks to their pipelines,\nwhich is great to see. There is a learning curve, but I have personally found the payoffs\nin productivity to be immense.\n\nAs both users and developers of Nextflow, we have long discussed best practice to ensure\nreproducibility of our work. As a community, we are at the beginning of that conversation\n\n- there are still many ideas to be aired and details ironed out - nevertheless we wished\n  to provide a _state-of-play_ as we see it and to describe what is possible with Nextflow\n  in this regard.\n\n### Guaranteed Reproducibility\n\nThis is our goal. It is one thing for a pipeline to be able to be reproduced in your own\nhands, on your machine, yet is another for this to be guaranteed so that anyone anywhere\ncan reproduce it. What I mean by guaranteed is that when a given pipeline is executed,\nthere is only one result which can be output.\nEnvisage what I term the _reproducibility triangle_: consisting of data, code and\ncompute environment.\n\n![Reproducibility Triangle](/img/reproducibility-triangle.png)\n\n**Figure 1:** The Reproducibility Triangle. _Data_: raw data such as sequencing reads,\ngenomes and annotations but also metadata such as experimental design. _Code_:\nscripts, binaries and libraries/dependencies. _Environment_: operating system.\n\nIf there is any change to one of these then the reproducibililty is no longer guaranteed.\nFor years there have been solutions to each of these individual components. But they have\nlived a somewhat discrete existence: data in databases such as the SRA and Ensembl, code\non GitHub and compute environments in the form of virtual machines. We think that in the\nfuture science must embrace solutions that integrate each of these components natively and\nholistically.\n\n### Implementation\n\nNextflow provides a solution to reproduciblility through version control and sandboxing.\n\n#### Code\n\nVersion control is provided via [native integration with GitHub](https://www.nextflow.io/docs/latest/sharing.html)\nand other popular code management platforms such as Bitbucket and GitLab.\nPipelines can be pulled, executed, developed, collaborated on and shared. For example,\nthe command below will pull a specific version of a [simple Kallisto + Sleuth pipeline](https://github.com/cbcrg/kallisto-nf)\nfrom GitHub and execute it. The `-r` parameter can be used to specify a specific tag, branch\nor revision that was previously defined in the Git repository.\n\n    nextflow run cbcrg/kallisto-nf -r v0.9\n\n#### Environment\n\nSandboxing during both development and execution is another key concept; version control\nalone does not ensure that all dependencies nor the compute environment are the same.\n\nA simplified implementation of this places all binaries, dependencies and libraries within\nthe project repository. In Nextflow, any binaries within the the `bin` directory of a\nrepository are added to the path. Also, within the Nextflow [config file](https://github.com/cbcrg/kallisto-nf/blob/master/nextflow.config),\nenvironmental variables such as `PERL5LIB` can be defined so that they are automatically\nadded during the task executions.\n\nThis can be taken a step further with containerisation such as [Docker](https://www.nextflow.io/docs/latest/docker.html).\nWe have recently published [work](https://doi.org/10.7717/peerj.1273) about this:\nbriefly a [dockerfile](https://github.com/cbcrg/kallisto-nf/blob/master/Dockerfile)\ncontaining the instructions on how to build the docker image resides inside a repository.\nThis provides a specification for the operating system, software, libraries and\ndependencies to be run.\n\nThe images themself also have content-addressable identifiers in the form of\n[digests](https://docs.docker.com/engine/userguide/containers/dockerimages/#image-digests),\nwhich ensure not a single byte of information, from the operating system through to the\nlibraries pulled from public repos, has been changed. This container digest can be specified\nin the [pipeline config file](https://github.com/cbcrg/kallisto-nf/blob/master/nextflow.config).\n\n    process {\n        container = \"cbcrg/kallisto-nf@sha256:9f84012739...\"\n    }\n\nWhen doing so Nextflow automatically pulls the specified image from the Docker Hub and\nmanages the execution of the pipeline tasks from within the container in a transparent manner,\ni.e. without having to adapt or modify your code.\n\n#### Data\n\nData is currently one of the more challenging aspect to address. _Small data_ can be\neasily version controlled within git-like repositories. For larger files\nthe [Git Large File Storage](https://git-lfs.github.com/), for which Nextflow provides\nbuilt-in support, may be one solution. Ultimately though, the real home of scientific data\nis in publicly available, programmatically accessible databases.\n\nProviding out-of-box solutions is difficult given the hugely varying nature of the data\nand meta-data within these databases. We are currently looking to incorporate the most\nhighly used ones, such as the [SRA](http://www.ncbi.nlm.nih.gov/sra) and [Ensembl](http://www.ensembl.org/index.html).\nIn the long term we have an eye on initiatives, such as [NCBI BioProject](https://www.ncbi.nlm.nih.gov/bioproject/),\nwith the idea there is a single identifier for both the data and metadata that can be referenced in a workflow.\n\nAdhering to the practices above, one could imagine one line of code which would appear within a publication.\n\n    nextflow run [user/repo] -r [version] --data[DB_reference:data_reference] -with-docker\n\nThe result would be guaranteed to be reproduced by whoever wished.\n\n### Conclusion\n\nWith this approach the reproducilbility triangle is complete. But it must be noted that\nthis does not guard against conceptual or implementation errors. It does not replace proper\ndocumentation. What it does is to provide transparency to a result.\n\nThe assumption that the deterministic nature of computation makes results insusceptible\nto irreproducbility is clearly false. We consider Nextflow with its other features such\nits polyglot nature, out-of-the-box portability and native support across HPC and Cloud\nenvironments to be an ideal solution in our everyday work. We hope to see more scientists\nadopt this approach to their workflows.\n\nThe recent efforts by the _Kallisto_ authors highlight the appetite for increasing these\nstandards and we encourage the community at large to move towards ensuring this becomes\nthe normal state of affairs for publishing in science.\n\n### References\n\nBray, Nicolas L., Harold Pimentel, Páll Melsted, and Lior Pachter. 2016. “Near-Optimal Probabilistic RNA-Seq Quantification.” Nature Biotechnology, April. Nature Publishing Group. doi:10.1038/nbt.3519.\n\nDi Tommaso P, Palumbo E, Chatzou M, Prieto P, Heuer ML, Notredame C. (2015) \"The impact of Docker containers on the performance of genomic pipelines.\" PeerJ 3:e1273 doi.org:10.7717/peerj.1273.\n\nGarijo D, Kinnings S, Xie L, Xie L, Zhang Y, Bourne PE, et al. (2013) \"Quantifying Reproducibility in Computational Biology: The Case of the Tuberculosis Drugome.\" PLoS ONE 8(11): e80278. doi:10.1371/journal.pone.0080278",
    "images": [],
    "author": "Evan Floden",
    "tags": "bioinformatics,reproducibility,pipelines,nextflow,genomic,docker"
  },
  {
    "slug": "2016/deploy-in-the-cloud-at-snap-of-a-finger",
    "title": "Deploy your computational pipelines in the cloud at the snap-of-a-finger",
    "date": "2016-09-01T00:00:00.000Z",
    "content": "*Learn how to deploy and run a computational pipeline in the Amazon AWS cloud with ease\nthanks to Nextflow and Docker containers*\n\nNextflow is a framework that simplifies the writing of parallel and distributed computational\npipelines in a portable and reproducible manner across different computing platforms, from\na laptop to a cluster of computers.\n\nIndeed, the original idea, when this project started three years ago, was to\nimplement a tool that would allow researchers in\n[our lab](http://www.crg.eu/es/programmes-groups/comparative-bioinformatics) to smoothly migrate\ntheir data analysis applications in the cloud when needed - without having\nto change or adapt their code.\n\nHowever to date Nextflow has been used mostly to deploy computational workflows within on-premise\ncomputing clusters or HPC data-centers, because these infrastructures are easier to use\nand provide, on average, cheaper cost and better performance when compared to a cloud environment.\n\nA major obstacle to efficient deployment of scientific workflows in the cloud is the lack\nof a performant POSIX compatible shared file system. These kinds of applications\nare usually made-up by putting together a collection of tools, scripts and\nsystem commands that need a reliable file system to share with each other the input and\noutput files as they are produced, above all in a distributed cluster of computers.\n\nThe recent availability of the [Amazon Elastic File System](https://aws.amazon.com/efs/)\n(EFS), a fully featured NFS based file system hosted on the AWS infrastructure represents\na major step in this context, unlocking the deployment of scientific computing\nin the cloud and taking it to the next level.\n\n### Nextflow support for the cloud\n\nNextflow could already be deployed in the cloud, either using tools such as\n[ElastiCluster](https://github.com/gc3-uzh-ch/elasticluster) or\n[CfnCluster](https://aws.amazon.com/hpc/cfncluster/), or by using custom deployment\nscripts. However the procedure was still cumbersome and, above all, it was not optimised\nto fully take advantage of cloud elasticity i.e. the ability to (re)shape the computing\ncluster dynamically as the computing needs change over time.\n\nFor these reasons, we decided it was time to provide Nextflow with a first-class support\nfor the cloud, integrating the Amazon EFS and implementing an optimised native cloud\nscheduler, based on [Apache Ignite](https://ignite.apache.org/), with a full support for cluster\nauto-scaling and spot/preemptible instances.\n\nIn practice this means that Nextflow can now spin-up and configure a fully featured computing\ncluster in the cloud with a single command, after that you need only to login to the master\nnode and launch the pipeline execution as you would do in your on-premise cluster.\n\n### Demo !\n\nSince a demo is worth a thousands words, I've record a short screencast showing how\nNextflow can setup a cluster in the cloud and mount the Amazon EFS shared file system.\n\n<script type=\"text/javascript\" src=\"https://asciinema.org/a/9vupd4d72ivaz6h56pajjjkop.js\" id=\"asciicast-9vupd4d72ivaz6h56pajjjkop\" async=\"\"></script>\n\nNote: in this screencast it has been cut the Ec2 instances startup delay. It required around\n5 minutes to launch them and setup the cluster.\n\nLet's recap the steps showed in the demo:\n\n- The user provides the cloud parameters (such as the VM image ID and the instance type)\n  in the `nextflow.config` file.\n\n- To configure the EFS file system you need to provide your EFS storage ID and the mount path\n  by using the `sharedStorageId` and `sharedStorageMount` properties.\n\n- To use [EC2 Spot](https://aws.amazon.com/ec2/spot/) instances, just specify the price\n  you want to bid by using the `spotPrice` property.\n\n- The AWS access and secret keys are provided by using the usual environment variables.\n\n- The `nextflow cloud create` launches the requested number of instances, configures the user and\n  access key, mounts the EFS storage and setups the Nextflow cluster automatically.\n  Any Linux AMI can be used, it is only required that the [cloud-init](https://cloudinit.readthedocs.io/en/latest/)\n  package, a Java 7+ runtime and the Docker engine are present.\n\n- When the cluster is ready, you can SSH in the master node and launch the pipeline execution\n  as usual with the `nextflow run <pipeline name=\"\">` command.\n\n- For the sake of this demo we are using [paraMSA](https://github.com/pditommaso/paraMSA),\n  a pipeline for generating multiple sequence alignments and bootstrap replicates developed\n  in our lab.\n\n- Nextflow automatically pulls the pipeline code from its GitHub repository when the\n  execution is launched. This repository includes also a dataset which is used by default.\n  [The many bioinformatic tools used by the pipeline](https://github.com/pditommaso/paraMSA#dependencies-)\n  are packaged using a Docker image, which is downloaded automatically on each computing node.\n\n- The pipeline results are uploaded automatically in the S3 bucket specified\n  by the `--output s3://cbcrg-eu/para-msa-results` command line option.\n\n- When the computation is completed, the cluster can be safely shutdown and the\n  EC2 instances terminated with the `nextflow cloud shutdown` command.\n\n### Try it yourself\n\n~~We are releasing the Nextflow integrated cloud support in the upcoming version `0.22.0`~~.\n\nNextflow integrated cloud support is available from version `0.22.0`. To use it just make sure to\nhave this or an higher version of Nextflow.\n\nBare in mind that Nextflow requires a Unix-like operating system and a Java runtime version 7+\n(Windows 10 users which have installed the [Ubuntu subsystem](https://blogs.windows.com/buildingapps/2016/03/30/run-bash-on-ubuntu-on-windows/)\nshould be able to run it, at their risk..).\n\nOnce you have installed it, you can follow the steps in the above demo. For your convenience\nwe made publicly available the EC2 image ~~`ami-43f49030`~~ `ami-4b7daa32`^\\* ^ (EU Ireland region) used to record this\nscreencast.\n\nAlso make sure you have the following the following variables defined in your environment:\n\n    AWS_ACCESS_KEY_ID=\"<your aws=\"\" access=\"\" key=\"\">\"\n    AWS_SECRET_ACCESS_KEY=\"<your aws=\"\" secret=\"\" key=\"\">\"\n    AWS_DEFAULT_REGION=\"<your aws=\"\" region=\"\">\"\n\nReferes to the [documentation](/docs/latest/awscloud.html) for configuration details.\n\n\\* Update: the AMI has been updated with Java 8 on Sept 2017.\n\n### Conclusion\n\nNextflow provides state of the art support for cloud and containers technologies making\nit possible to create computing clusters in the cloud and deploy computational workflows\nin a no-brainer way, with just two commands on your terminal.\n\nIn an upcoming post I will describe the autoscaling capabilities implemented by the\nNextflow scheduler that allows, along with the use of spot/preemptible instances,\na cost effective solution for the execution of your pipeline in the cloud.\n\n#### Credits\n\nThanks to [Evan Floden](https://github.com/skptic) for reviewing this post and for writing\nthe [paraMSA](https://github.com/skptic/paraMSA/) pipeline.\n</your></your></your></pipeline>",
    "images": [],
    "author": "Paolo Di Tommaso",
    "tags": "aws,cloud,pipelines,nextflow,genomic,docker"
  },
  {
    "slug": "2016/developing-bioinformatics-pipeline-across-multiple-environments",
    "title": "Developing a bioinformatics pipeline across multiple environments",
    "date": "2016-02-04T00:00:00.000Z",
    "content": "As a new bioinformatics student with little formal computer science training, there are\nfew things that scare me more than PhD committee meetings and having to run my code in a\ncompletely different operating environment.\n\nRecently my work landed me in the middle of the phylogenetic tree jungle and the computational\nrequirements of my project far outgrew the resources that were available on our institute’s\n[Univa Grid Engine](https://en.wikipedia.org/wiki/Univa_Grid_Engine) based cluster. Luckily for me,\nan opportunity arose to participate in a joint program at the MareNostrum HPC at the\n[Barcelona Supercomputing Centre](http://www.bsc.es) (BSC).\n\nAs one of the top 100 supercomputers in the world, the [MareNostrum III](https://www.bsc.es/discover-bsc/the-centre/marenostrum)\ndwarfs our cluster and consists of nearly 50'000 processors. However it soon became apparent\nthat with great power comes great responsibility and in the case of the BSC, great restrictions.\nThese include no internet access, restrictive wall times for jobs, longer queues,\nfewer pre-installed binaries and an older version of bash. Faced with the possibility of\nhaving to rewrite my 16 bodged scripts for another queuing system I turned to Nextflow.\n\nStraight off the bat I was able to reduce all my previous scripts to a single Nextflow script.\nAdmittedly, the original code was not great, but the data processing model made me feel confident\nin what I was doing and I was able to reduce the volume of code to 25% of its initial amount\nwhilst making huge improvements in the readability. The real benefits however came from the portability.\n\nI was able to write the project on my laptop (Macbook Air), continuously test it on my local\ndesktop machine (Linux) and then perform more realistic heavy lifting runs on the cluster,\nall managed from a single GitHub repository. The BSC uses the [Load Sharing Facility](https://en.wikipedia.org/wiki/Platform_LSF)\n(LSF) platform with longer queue times, but a large number of CPUs. My project on the other\nhand had datasets that require over 100'000 tasks, but the tasks processes themselves run\nfor a matter of seconds or minutes. We were able to marry these two competing interests\ndeploying Nextflow in a [distributed execution manner that resemble the one of an MPI application](/blog/2015/mpi-like-execution-with-nextflow.html).\n\nIn this configuration, the queuing system allocates the Nextflow requested resources and\nusing the embedded [Apache Ignite](https://ignite.apache.org/) clustering engine, Nextflow handles\nthe submission of processes to the individual nodes.\n\nHere is some examples of how to run the same Nextflow project over multiple platforms.\n\n#### Local\n\nIf I wished to launch a job locally I can run it with the command:\n\n    nextflow run myproject.nf\n\n#### Univa Grid Engine (UGE)\n\nFor the UGE I simply needed to specify the following in the `nextflow.config` file:\n\n    process {\n            executor='uge'\n            queue='my_queue'\n    }\n\nAnd then launch the pipeline execution as we did before:\n\n    nextflow run myproject.nf\n\n#### Load Sharing Facility (LSF)\n\nFor running the same pipeline in the MareNostrum HPC environment, taking advantage of the MPI\nstandard to deploy my workload, I first created a wrapper script (for example `bsc-wrapper.sh`)\ndeclaring the resources that I want to reserve for the pipeline execution:\n\n    #!/bin/bash\n    #BSUB -oo logs/output_%J.out\n    #BSUB -eo logs/output_%J.err\n    #BSUB -J myProject\n    #BSUB -q bsc_ls\n    #BSUB -W 2:00\n    #BSUB -x\n    #BSUB -n 512\n    #BSUB -R \"span[ptile=16]\"\n    export NXF_CLUSTER_SEED=$(shuf -i 0-16777216 -n 1)\n    mpirun --pernode bin/nextflow run concMSA.nf -with-mpi\n\nAnd then can execute it using `bsub` as shown below:\n\n    bsub &lt; bsc-wrapper.sh\n\nBy running Nextflow in this way and given the wrapper above, a single `bsub` job will run\non 512 cores in 32 computing nodes (512/16 = 32) with a maximum wall time of 2 hours.\nThousands of Nextflow processes can be spawned during this and the execution can be monitored\nin the standard manner from a single Nextflow output and error files. If any errors occur\nthe execution can of course to continued with [`-resume` command line option](/docs/latest/getstarted.html?highlight=resume#modify-and-resume).\n\n### Conclusion\n\nNextflow provides a simplified way to develop across multiple platforms and removes\nmuch of the overhead associated with running niche, user developed pipelines in an HPC\nenvironment.",
    "images": [],
    "author": "Evan Floden",
    "tags": "bioinformatics,reproducibility,pipelines,nextflow,genomic,hpc"
  },
  {
    "slug": "2016/docker-for-dunces-nextflow-for-nunces",
    "title": "Docker for dunces & Nextflow for nunces",
    "date": "2016-06-10T00:00:00.000Z",
    "content": "_Below is a step-by-step guide for creating [Docker](http://www.docker.io) images for use with [Nextflow](http://www.nextflow.io) pipelines. This post was inspired by recent experiences and written with the hope that it may encourage others to join in the virtualization revolution._\n\nModern science is built on collaboration. Recently I became involved with one such venture between several groups across Europe. The aim was to annotate long non-coding RNA (lncRNA) in farm animals and I agreed to help with the annotation based on RNA-Seq data. The basic procedure relies on mapping short read data from many different tissues to a genome, generating transcripts and then determining if they are likely to be lncRNA or protein coding genes.\n\nDuring several successful 'hackathon' meetings the best approach was decided and implemented in a joint effort. I undertook the task of wrapping the procedure up into a Nextflow pipeline with a view to replicating the results across our different institutions and to allow the easy execution of the pipeline by researchers anywhere.\n\nCreating the Nextflow pipeline ([here](http://www.github.com/cbcrg/lncrna-annotation-nf)) in itself was not a difficult task. My collaborators had documented their work well and were on hand if anything was not clear. However installing and keeping aligned all the pipeline dependencies across different the data centers was still a challenging task.\n\nThe pipeline is typical of many in bioinformatics, consisting of binary executions, BASH scripting, R, Perl, BioPerl and some custom Perl modules. We found the BioPerl modules in particular where very sensitive to the various versions in the _long_ dependency tree. The solution was to turn to [Docker](https://www.docker.com/) containers.\n\nI have taken this opportunity to document the process of developing the Docker side of a Nextflow + Docker pipeline in a step-by-step manner.\n\n###Docker Installation\n\nBy far the most challenging issue is the installation of Docker. For local installations, the [process is relatively straight forward](https://docs.docker.com/engine/installation). However difficulties arise as computing moves to a cluster. Owing to security concerns, many HPC administrators have been reluctant to install Docker system-wide. This is changing and Docker developers have been responding to many of these concerns with [updates addressing these issues](https://blog.docker.com/2016/02/docker-engine-1-10-security/).\n\nThat being the case, local installations are usually perfectly fine for development. One of the golden rules in Nextflow development is to have a small test dataset that can run the full pipeline in minutes with few computational resources, ie can run on a laptop.\n\nIf you have Docker and Nextflow installed and you wish to view the working pipeline, you can perform the following commands to obtain everything you need and run the full lncrna annotation pipeline on a test dataset.\n\n    docker pull cbcrg/lncrna_annotation\n    nextflow run cbcrg/lncrna-annotation-nf -profile test\n\n[If the following does not work, there could be a problem with your Docker installation.]\n\nThe first command will download the required Docker image in your computer, while the second will launch Nextflow which automatically download the pipeline repository and\nrun it using the test data included with it.\n\n###The Dockerfile\n\nThe `Dockerfile` contains all the instructions required by Docker to build the Docker image. It provides a transparent and consistent way to specify the base operating system and installation of all software, libraries and modules.\n\nWe begin by creating a file `Dockerfile` in the Nextflow project directory. The Dockerfile begins with:\n\n    # Set the base image to debian jessie\n    FROM debian:jessie\n\n    # File Author / Maintainer\n    MAINTAINER Evan Floden <evanfloden@gmail.com>\n\nThis sets the base distribution for our Docker image to be Debian v8.4, a lightweight Linux distribution that is ideally suited for the task. We must also specify the maintainer of the Docker image.\n\nNext we update the repository sources and install some essential tools such as `wget` and `perl`.\n\n    RUN apt-get update &amp;&amp; apt-get install --yes --no-install-recommends \\\n        wget \\\n        locales \\\n        vim-tiny \\\n        git \\\n        cmake \\\n        build-essential \\\n        gcc-multilib \\\n        perl \\\n        python ...\n\nNotice that we use the command `RUN` before each line. The `RUN` instruction executes commands as if they are performed from the Linux shell.\n\nAlso is good practice to group as many as possible commands in the same `RUN` statement. This reduces the size of the final Docker image. See [here](https://blog.replicated.com/2016/02/05/refactoring-a-dockerfile-for-image-size/) for these details and [here](https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/) for more best practices.\n\nNext we can specify the install of the required perl modules using [cpan minus](http://search.cpan.org/~miyagawa/Menlo-1.9003/script/cpanm-menlo):\n\n    # Install perl modules\n    RUN cpanm --force CPAN::Meta \\\n        YAML \\\n        Digest::SHA \\\n        Module::Build \\\n        Data::Stag \\\n        Config::Simple \\\n        Statistics::Lite ...\n\nWe can give the instructions to download and install software from GitHub using:\n\n    # Install Star Mapper\n    RUN wget -qO- https://github.com/alexdobin/STAR/archive/2.5.2a.tar.gz | tar -xz \\\n        &amp;&amp; cd STAR-2.5.2a \\\n        &amp;&amp; make STAR\n\nWe can add custom Perl modules and specify environmental variables such as `PERL5LIB` as below:\n\n    # Install FEELnc\n    RUN wget -q https://github.com/tderrien/FEELnc/archive/a6146996e06f8a206a0ae6fd59f8ca635c7d9467.zip \\\n        &amp;&amp; unzip a6146996e06f8a206a0ae6fd59f8ca635c7d9467.zip \\\n        &amp;&amp; mv FEELnc-a6146996e06f8a206a0ae6fd59f8ca635c7d9467 /FEELnc \\\n        &amp;&amp; rm a6146996e06f8a206a0ae6fd59f8ca635c7d9467.zip\n\n    ENV FEELNCPATH /FEELnc\n    ENV PERL5LIB $PERL5LIB:${FEELNCPATH}/lib/\n\nR and R libraries can be installed as follows:\n\n    # Install R\n    RUN echo \"deb http://cran.rstudio.com/bin/linux/debian jessie-cran3/\" &gt;&gt;  /etc/apt/sources.list &amp;&amp;\\\n    apt-key adv --keyserver keys.gnupg.net --recv-key 381BA480 &amp;&amp;\\\n    apt-get update --fix-missing &amp;&amp; \\\n    apt-get -y install r-base\n\n    # Install R libraries\n    RUN R -e 'install.packages(\"ROCR\", repos=\"http://cloud.r-project.org/\"); install.packages(\"randomForest\",repos=\"http://cloud.r-project.org/\")'\n\nFor the complete working Dockerfile of this project see [here](https://github.com/cbcrg/lncRNA-Annotation-nf/blob/master/Dockerfile)\n\n###Building the Docker Image\n\nOnce we start working on the Dockerfile, we can build it anytime using:\n\n    docker build -t skptic/lncRNA_annotation .\n\nThis builds the image from the Dockerfile and assigns a tag (i.e. a name) for the image. If there are no errors, the Docker image is now in you local Docker repository ready for use.\n\n###Testing the Docker Image\n\nWe find it very helpful to test our images as we develop the Docker file. Once built, it is possible to launch the Docker image and test if the desired software was correctly installed. For example, we can test if FEELnc and its dependencies were successfully installed by running the following:\n\n    docker run -ti lncrna_annotation\n\n    cd FEELnc/test\n\n    FEELnc_filter.pl -i transcript_chr38.gtf -a annotation_chr38.gtf \\\n    &gt; -b transcript_biotype=protein_coding &gt; candidate_lncRNA.gtf\n\n    exit # remember to exit the Docker image\n\n###Tagging the Docker Image\n\nOnce you are confident your image is built correctly, you can tag it, allowing you to push it to [Dockerhub.io](https://hub.docker.com/). Dockerhub is an online repository for docker images which allows anyone to pull public images and run them.\n\nYou can view the images in your local repository with the `docker images` command and tag using `docker tag` with the image ID and the name.\n\n    docker images\n\n    REPOSITORY                               TAG                 IMAGE ID            CREATED             SIZE\n    lncrna_annotation                        latest              d8ec49cbe3ed        2 minutes ago       821.5 MB\n\n    docker tag d8ec49cbe3ed cbcrg/lncrna_annotation:latest\n\nNow when we check our local images we can see the updated tag.\n\n    docker images\n\n    REPOSITORY                               TAG                 IMAGE ID            CREATED             SIZE\n    cbcrg/lncrna_annotation                 latest              d8ec49cbe3ed        2 minutes ago       821.5 MB\n\n###Pushing the Docker Image to Dockerhub\n\nIf you have not previously, sign up for a Dockerhub account [here](https://hub.docker.com/). From the command line, login to Dockerhub and push your image.\n\n    docker login --username=cbcrg\n    docker push cbcrg/lncrna_annotation\n\nYou can test if you image has been correctly pushed and is publicly available by removing your local version using the IMAGE ID of the image and pulling the remote:\n\n    docker rmi -f d8ec49cbe3ed\n\n    # Ensure the local version is not listed.\n    docker images\n\n    docker pull cbcrg/lncrna_annotation\n\nWe are now almost ready to run our pipeline. The last step is to set up the Nexflow config.\n\n###Nextflow Configuration\n\nWithin the `nextflow.config` file in the main project directory we can add the following line which links the Docker image to the Nexflow execution. The images can be:\n\n- General (same docker image for all processes):\n\n        process {\n            container = 'cbcrg/lncrna_annotation'\n        }\n\n- Specific to a profile (specified by `-profile crg` for example):\n\n        profile {\n            crg {\n                container = 'cbcrg/lncrna_annotation'\n            }\n        }\n\n- Specific to a given process within a pipeline:\n\n        $processName.container = 'cbcrg/lncrna_annotation'\n\nIn most cases it is easiest to use the same Docker image for all processes. One further thing to consider is the inclusion of the sha256 hash of the image in the container reference. I have [previously written about this](https://www.nextflow.io/blog/2016/best-practice-for-reproducibility.html), but briefly, including a hash ensures that not a single byte of the operating system or software is different.\n\n        process {\n            container = 'cbcrg/lncrna_annotation@sha256:9dfe233b...'\n        }\n\nAll that is left now to run the pipeline.\n\n    nextflow run lncRNA-Annotation-nf -profile test\n\nWhilst I have explained this step-by-step process in a linear, consequential manner, in reality the development process is often more circular with changes in the Docker images reflecting changes in the pipeline.\n\n###CircleCI and Nextflow\n\nNow that you have a pipeline that successfully runs on a test dataset with Docker, a very useful step is to add a continuous development component to the pipeline. With this, whenever you push a modification of the pipeline to the GitHub repo, the test data set is run on the [CircleCI](http://www.circleci.com) servers (using Docker).\n\nTo include CircleCI in the Nexflow pipeline, create a file named `circle.yml` in the project directory. We add the following instructions to the file:\n\n    machine:\n        java:\n            version: oraclejdk8\n        services:\n            - docker\n\n    dependencies:\n        override:\n\n    test:\n        override:\n            - docker pull cbcrg/lncrna_annotation\n            - curl -fsSL get.nextflow.io | bash\n            - ./nextflow run . -profile test\n\nNext you can sign up to CircleCI, linking your GitHub account.\n\nWithin the GitHub README.md you can add a badge with the following:\n\n    ![CircleCI status](https://circleci.com/gh/cbcrg/lncRNA-Annotation-nf.png?style=shield)\n\n###Tips and Tricks\n\n**File permissions**: When a process is executed by a Docker container, the UNIX user running the process is not you. Therefore any files that are used as an input should have the appropriate file permissions. For example, I had to change the permissions of all the input data in the test data set with:\n\nfind <data-path> -type f -exec chmod 644 {} \\;\nfind <data-path> -type d -exec chmod 755 {} \\;\n\n###Summary\nThis was my first time building a Docker image and after a bit of trial-and-error the process was surprising straight forward. There is a wealth of information available for Docker and the almost seamless integration with Nextflow is fantastic. Our collaboration team is now looking forward to applying the pipeline to different datasets and publishing the work, knowing our results will be completely reproducible across any platform.\n</data-path></data-path></evanfloden@gmail.com>",
    "images": [],
    "author": "Evan Floden",
    "tags": "bioinformatics,reproducibility,pipelines,nextflow,genomic,docker"
  },
  {
    "slug": "2016/enabling-elastic-computing-nextflow",
    "title": "Enabling elastic computing with Nextflow",
    "date": "2016-10-19T00:00:00.000Z",
    "content": "*Learn how to deploy an elastic computing cluster in the AWS cloud with Nextflow *\n\nIn the [previous post](/blog/2016/deploy-in-the-cloud-at-snap-of-a-finger.html) I introduced\nthe new cloud native support for AWS provided by Nextflow.\n\nIt allows the creation of a computing cluster in the cloud in a no-brainer way, enabling\nthe deployment of complex computational pipelines in a few commands.\n\nThis solution is characterised by using a lean application stack which does not\nrequire any third party component installed in the EC2 instances other than a Java VM and the\nDocker engine (the latter it's only required in order to deploy pipeline binary dependencies).\n\n![Nextflow cloud deployment](/img/cloud-deployment.png)\n\nEach EC2 instance runs a script, at bootstrap time, that mounts the [EFS](https://aws.amazon.com/efs/)\nstorage and downloads and launches the Nextflow cluster daemon. This daemon is self-configuring,\nit automatically discovers the other running instances and joins them forming the computing cluster.\n\nThe simplicity of this stack makes it possible to setup the cluster in the cloud in just a few minutes,\na little more time than is required to spin up the EC2 VMs. This time does not depend on\nthe number of instances launched, as they configure themself independently.\n\nThis also makes it possible to add or remove instances as needed, realising the [long promised\nelastic scalability](http://www.nextplatform.com/2016/09/21/three-great-lies-cloud-computing/)\nof cloud computing.\n\nThis ability is even more important for bioinformatic workflows, which frequently crunch\nnot homogeneous datasets and are composed of tasks with very different computing requirements\n(eg. a few very long running tasks and many short-lived tasks in the same workload).\n\n### Going elastic\n\nThe Nextflow support for the cloud features an elastic cluster which is capable of resizing itself\nto adapt to the actual computing needs at runtime, thus spinning up new EC2 instances when jobs\nwait for too long in the execution queue, or terminating instances that are not used for\na certain amount of time.\n\nIn order to enable the cluster autoscaling you will need to specify the autoscale\nproperties in the `nextflow.config` file. For example:\n\n```\ncloud {\n  imageId = 'ami-4b7daa32'\n  instanceType = 'm4.xlarge'\n\n  autoscale {\n     enabled = true\n     minInstances = 5\n     maxInstances = 10\n  }\n}\n```\n\nThe above configuration enables the autoscaling features so that the cluster will include\nat least 5 nodes. If at any point one or more tasks spend more than 5 minutes without being\nprocessed, the number of instances needed to fullfil the pending tasks, up to limit specified\nby the `maxInstances` attribute, are launched. On the other hand, if these instances are\nidle, they are terminated before reaching the 60 minutes instance usage boundary.\n\nThe autoscaler launches instances by using the same AMI ID and type specified in the `cloud`\nconfiguration. However it is possible to define different attributes as shown below:\n\n```\ncloud {\n  imageId = 'ami-4b7daa32'\n  instanceType = 'm4.large'\n\n  autoscale {\n     enabled = true\n     maxInstances = 10\n     instanceType = 'm4.2xlarge'\n     spotPrice = 0.05\n  }\n}\n```\n\nThe cluster is first created by using instance(s) of type `m4.large`. Then, when new\ncomputing nodes are required the autoscaler launches instances of type `m4.2xlarge`.\nAlso, since the `spotPrice` attribute is specified, [EC2 spot](https://aws.amazon.com/ec2/spot/)\ninstances are launched, instead of regular on-demand ones, bidding for the price specified.\n\n### Conclusion\n\nNextflow implements an easy though effective cloud scheduler that is able to scale dynamically\nto meet the computing needs of deployed workloads taking advantage of the _elastic_ nature\nof the cloud platform.\n\nThis ability, along the support for spot/preemptible instances, allows a cost effective solution\nfor the execution of your pipeline in the cloud.",
    "images": [],
    "author": "Paolo Di Tommaso",
    "tags": "aws,cloud,pipelines,nextflow,genomic,docker"
  },
  {
    "slug": "2016/error-recovery-and-automatic-resources-management",
    "title": "Error recovery and automatic resource management with Nextflow",
    "date": "2016-02-11T00:00:00.000Z",
    "content": "Recently a new feature has been added to Nextflow that allows failing jobs to be rescheduled,\nautomatically increasing the amount of computational resources requested.\n\n## The problem\n\nNextflow provides a mechanism that allows tasks to be automatically re-executed when\na command terminates with an error exit status. This is useful to handle errors caused by\ntemporary or even permanent failures (i.e. network hiccups, broken disks, etc.) that\nmay happen in a cloud based environment.\n\nHowever in an HPC cluster these events are very rare. In this scenario\nerror conditions are more likely to be caused by a peak in computing resources, allocated\nby a job exceeding the original resource requested. This leads to the batch scheduler\nkilling the job which in turn stops the overall pipeline execution.\n\nIn this context automatically re-executing the failed task is useless because it\nwould simply replicate the same error condition. A common solution consists of increasing\nthe resource request for the needs of the most consuming job, even though this will result\nin a suboptimal allocation of most of the jobs that are less resource hungry.\n\nMoreover it is also difficult to predict such upper limit. In most cases the only way to\ndetermine it is by using a painful fail-and-retry approach.\n\nTake in consideration, for example, the following Nextflow process:\n\n    process align {\n        executor 'sge'\n        memory 1.GB\n        errorStrategy 'retry'\n\n        input:\n        file 'seq.fa' from sequences\n\n        script:\n        '''\n        t_coffee -in seq.fa\n        '''\n    }\n\nThe above definition will execute as many jobs as there are fasta files emitted\nby the `sequences` channel. Since the `retry` _error strategy_ is specified, if the\ntask returns a non-zero error status, Nextflow will reschedule the job execution requesting\nthe same amount of memory and disk storage. In case the error is generated by `t_coffee` that\nit needs more than one GB of memory for a specific alignment, the task will continue to fail,\nstopping the pipeline execution as a consequence.\n\n## Increase job resources automatically\n\nA better solution can be implemented with Nextflow which allows resources to be defined in\na dynamic manner. By doing this it is possible to increase the memory request when\nrescheduling a failing task execution. For example:\n\n    process align {\n        executor 'sge'\n        memory { 1.GB * task.attempt }\n        errorStrategy 'retry'\n\n        input:\n        file 'seq.fa' from sequences\n\n        script:\n        '''\n        t_coffee -in seq.fa\n        '''\n    }\n\nIn the above example the memory requirement is defined by using a dynamic rule.\nThe `task.attempt` attribute represents the current task attempt (`1` the first time the task\nis executed, `2` the second and so on).\n\nThe task will then request one GB of memory. In case of an error it will be rescheduled\nrequesting 2 GB and so on, until it is executed successfully or the limit of times a task\ncan be retried is reached, forcing the termination of the pipeline.\n\nIt is also possible to define the `errorStrategy` directive in a dynamic manner. This\nis useful to re-execute failed jobs only if a certain condition is verified.\n\nFor example the Univa Grid Engine batch scheduler returns the exit status `140` when a job\nis terminated because it's using more resources than the ones requested.\n\nBy checking this exit status we can reschedule only the jobs that fail by exceeding the\nresources allocation. This can be done with the following directive declaration:\n\n    errorStrategy { task.exitStatus == 140 ? 'retry' : 'terminate' }\n\nIn this way a failed task is rescheduled only when it returns the `140` exit status.\nIn all other cases the pipeline execution is terminated.\n\n## Conclusion\n\nNextflow provides a very flexible mechanism for defining the job resource request and\nhandling error events. It makes it possible to automatically reschedule failing tasks under\ncertain conditions and to define job resource requests in a dynamic manner so that they\ncan be adapted to the actual job's needs and to optimize the overall resource utilisation.",
    "images": [],
    "author": "Paolo Di Tommaso",
    "tags": "bioinformatics,pipelines,nextflow,hpc"
  },
  {
    "slug": "2016/more-fun-containers-hpc",
    "title": "More fun with containers in HPC",
    "date": "2016-12-20T00:00:00.000Z",
    "content": "Nextflow was one of the [first workflow framework](https://www.nextflow.io/blog/2014/nextflow-meets-docker.html)\nto provide built-in support for Docker containers. A couple of years ago we also started\nto experiment with the deployment of containerised bioinformatic pipelines at CRG,\nusing Docker technology (see [here](&lt;(https://www.nextflow.io/blog/2014/using-docker-in-hpc-cluster.html)&gt;) and [here](https://www.nextplatform.com/2016/01/28/crg-goes-with-the-genomics-flow/)).\n\nWe found that by isolating and packaging the complete computational workflow environment\nwith the use of Docker images, radically simplifies the burden of maintaining complex\ndependency graphs of real workload data analysis pipelines.\n\nEven more importantly, the use of containers enables replicable results with minimal effort\nfor the system configuration. The entire computational environment can be archived in a\nself-contained executable format, allowing the replication of the associated analysis at\nany point in time.\n\nThis ability is the main reason that drove the rapid adoption of Docker in the bioinformatic\ncommunity and its support in many projects, like for example [Galaxy](https://galaxyproject.org),\n[CWL](http://commonwl.org), [Bioboxes](http://bioboxes.org), [Dockstore](https://dockstore.org) and many others.\n\nHowever, while the popularity of Docker spread between the developers, its adaption in\nresearch computing infrastructures continues to remain very low and it's very unlikely\nthat this trend will change in the future.\n\nThe reason for this resides in the Docker architecture, which requires a daemon running\nwith root permissions on each node of a computing cluster. Such a requirement raises many\nsecurity concerns, thus good practices would prevent its use in shared HPC cluster or\nsupercomputer environments.\n\n### Introducing Singularity\n\nAlternative implementations, such as [Singularity](http://singularity.lbl.gov), have\nfortunately been promoted by the interested in containers technology.\n\nSingularity is a containers engine developed at the Berkeley Lab and designed for the\nneeds of scientific workloads. The main differences with Docker are: containers are file\nbased, no root escalation is allowed nor root permission is needed to run a container\n(although a privileged user is needed to create a container image), and there is no\nseparate running daemon.\n\nThese, along with other features, such as support for autofs mounts, makes Singularity a\ncontainer engine better suited to the requirements of HPC clusters and supercomputers.\n\nMoreover, although Singularity uses a container image format different to that of Docker,\nthey provide a conversion tool that allows Docker images to be converted to the\nSingularity format.\n\n### Singularity in the wild\n\nWe integrated Singularity support in Nextflow framework and tested it in the CRG\ncomputing cluster and the BSC [MareNostrum](https://www.bsc.es/discover-bsc/the-centre/marenostrum) supercomputer.\n\nThe absence of a separate running daemon or image gateway made the installation\nstraightforward when compared to Docker or other solutions.\n\nTo evaluate the performance of Singularity we carried out the [same benchmarks](https://peerj.com/articles/1273/)\nwe performed for Docker and compared the results of the two engines.\n\nThe benchmarks consisted in the execution of three Nextflow based genomic pipelines:\n\n1. [Rna-toy](https://github.com/nextflow-io/rnatoy/tree/peerj5515): a simple pipeline for RNA-Seq data analysis.\n2. [Nmdp-Flow](https://github.com/nextflow-io/nmdp-flow/tree/peerj5515/): an assembly-based variant calling pipeline.\n3. [Piper-NF](https://github.com/cbcrg/piper-nf/tree/peerj5515): a pipeline for the detection and mapping of long non-coding RNAs.\n\nIn order to repeat the analyses, we converted the container images we used to perform\nthe Docker benchmarks to Singularity image files by using the [docker2singularity](https://github.com/singularityware/docker2singularity) tool\n_(this is not required anymore, see the update below)_.\n\nThe only change needed to run these pipelines with Singularity was to replace the Docker\nspecific settings with the following ones in the configuration file:\n\n    singularity.enabled = true\n    process.container = '<the image=\"\" file=\"\" path=\"\">'\n\nEach pipeline was executed 10 times, alternately by using Docker and Singularity as\ncontainer engine. The results are shown in the following table (time in minutes):\n\n<style>\ntable#benchmark { width: 100%; margin-bottom: 1em; margin-top: 1em; border-top: 1px solid #999; border-bottom: 1px solid #999 }\ntable#benchmark th { text-align: center; background-color: #eee; padding: 2px 5px }\ntable#benchmark td { text-align: right; padding: 2px 5px; padding-right: 15px }\ntable#benchmark .r { text-align: right }\ntable#benchmark .l { text-align: left }\n</style>\n<table id=\"benchmark\">\n<tbody><tr>\n<th class=\"l\">Pipeline</th>\n<th>Tasks</th>\n<th colspan=\"2\">Mean task time</th>\n<th colspan=\"2\">Mean execution time</th>\n<th colspan=\"2\">Execution time std dev</th>\n<th colspan=\"2\">Ratio</th>\n</tr>\n\n<tr>\n<th>&nbsp;</th>\n<th>&nbsp;</th>\n<th>Singularity</th>\n<th>Docker</th>\n<th>Singularity</th>\n<th>Docker</th>\n<th>Singularity</th>\n<th>Docker</th>\n<th>&nbsp;</th>\n</tr>\n\n<tr>\n<td class=\"l\">RNA-Seq</td>\n<td>9</td>\n<td>73.7</td>\n<td>73.6</td>\n<td>663.6</td>\n<td>662.3</td>\n<td>2.0</td>\n<td>3.1</td>\n<td>0.998</td>\n</tr>\n\n<tr>\n<td class=\"l\">Variant call</td>\n<td>48</td>\n<td>22.1</td>\n<td>22.4</td>\n<td>1061.2</td>\n<td>1074.4</td>\n<td>43.1</td>\n<td>38.5</td>\n<td>1.012</td>\n</tr>\n\n<tr>\n<td class=\"l\">Piper-NF</td>\n<td>98</td>\n<td>1.2</td>\n<td>1.3</td>\n<td>120.0</td>\n<td>124.5</td>\n<td>6.9 </td>\n<td>2.8</td>\n<td>1.038</td>\n</tr>\n\n</tbody></table>\n\nThe benchmark results show that there isn't any significative difference in the\nexecution times of containerised workflows between Docker and Singularity. In two\ncases Singularity was slightly faster and a third one it was almost identical although\na little slower than Docker.\n\n### Conclusion\n\nIn our evaluation Singularity proved to be an easy to install,\nstable and performant container engine.\n\nThe only minor drawback, we found when compared to Docker, was the need to define the\nhost path mount points statically when the Singularity images were created. In fact,\neven if Singularity supports user mount points to be defined dynamically when the\ncontainer is launched, this feature requires the overlay file system which was not\nsupported by the kernel available in our system.\n\nDocker surely will remain the _de facto_ standard engine and image format for containers\ndue to its popularity and [impressive growth](http://www.coscale.com/blog/docker-usage-statistics-increased-adoption-by-enterprises-and-for-production-use).\n\nHowever, in our opinion, Singularity is the tool of choice for the execution of\ncontainerised workloads in the context of HPC, thanks to its focus on system security\nand its simpler architectural design.\n\nThe transparent support provided by Nextflow for both Docker and Singularity technology\nguarantees the ability to deploy your workflows in a range of different platforms (cloud,\ncluster, supercomputer, etc). Nextflow transparently manages the deployment of the\ncontainerised workload according to the runtime available in the target system.\n\n#### Credits\n\nThanks to Gabriel Gonzalez (CRG), Luis Exposito (CRG) and Carlos Tripiana Montes (BSC)\nfor the support installing Singularity.\n\n**Update** Singularity, since version 2.3.x, is able to pull and run Docker images from the Docker Hub.\nThis greatly simplifies the interoperability with existing Docker containers. You only need\nto prefix the image name with the `docker://` pseudo-protocol to download it as a Singularity image,\nfor example:\n\n    singularity pull --size 1200 docker://nextflow/rnatoy\n</the>",
    "images": [],
    "author": "Paolo Di Tommaso",
    "tags": "aws,pipelines,nextflow,genomic,docker,singularity"
  },
  {
    "slug": "2017/caw-and-singularity",
    "title": "Running CAW with Singularity and Nextflow",
    "date": "2017-11-16T00:00:00.000Z",
    "content": "*This is a guest post authored by Maxime Garcia from the Science for Life Laboratory in Sweden. Max\ndescribes how they deploy complex cancer data analysis pipelines using Nextflow\nand Singularity. We are very happy to share their experience across the Nextflow community.*\n\n### The CAW pipeline\n\n<img src=\"/img/CAW_logo.png\" alt=\"Cancer Analysis Workflow logo\" style=\"float:right\">\n\n[Cancer Analysis Workflow](http://opensource.scilifelab.se/projects/sarek/) (CAW for short) is a Nextflow based analysis pipeline developed for the analysis of tumour: normal pairs.\nIt is developed in collaboration with two infrastructures within [Science for Life Laboratory](https://www.scilifelab.se/): [National Genomics Infrastructure](https://ngisweden.scilifelab.se/) (NGI), in The Stockholm [Genomics Applications Development Facility](https://www.scilifelab.se/facilities/ngi-stockholm/) to be precise and [National Bioinformatics Infrastructure Sweden](https://www.nbis.se/) (NBIS).\n\nCAW is based on [GATK Best Practices](https://software.broadinstitute.org/gatk/best-practices/) for the preprocessing of FastQ files, then uses various variant calling tools to look for somatic SNVs and small indels ([MuTect1](https://github.com/broadinstitute/mutect/), [MuTect2](https://github.com/broadgsa/gatk-protected/), [Strelka](https://github.com/Illumina/strelka/), [Freebayes](https://github.com/ekg/freebayes/)), ([GATK HaplotyeCaller](https://github.com/broadgsa/gatk-protected/)), for structural variants([Manta](https://github.com/Illumina/manta/)) and for CNVs ([ASCAT](https://github.com/Crick-CancerGenomics/ascat/)).\nAnnotation tools ([snpEff](http://snpeff.sourceforge.net/), [VEP](https://www.ensembl.org/info/docs/tools/vep/index.html)) are also used, and finally [MultiQC](http://multiqc.info/) for handling reports.\n\nWe are currently working on a manuscript, but you're welcome to look at (or even contribute to) our [github repository](https://github.com/SciLifeLab/CAW/) or talk with us on our [gitter channel](https://gitter.im/SciLifeLab/CAW/).\n\n### Singularity and UPPMAX\n\n[Singularity](http://singularity.lbl.gov/) is a tool package software dependencies into a contained environment, much like Docker. It's designed to run on HPC environments where Docker is often a problem due to its requirement for administrative privileges.\n\nWe're based in Sweden, and [Uppsala Multidisciplinary Center for Advanced Computational Science](https://uppmax.uu.se/) (UPPMAX) provides Computational infrastructures for all Swedish researchers.\nSince we're analyzing sensitive data, we are using secure clusters (with a two factor authentication), set up by UPPMAX: [SNIC-SENS](https://www.uppmax.uu.se/projects-and-collaborations/snic-sens/).\n\nIn my case, since we're still developing the pipeline, I am mainly using the research cluster [Bianca](https://www.uppmax.uu.se/resources/systems/the-bianca-cluster/).\nSo I can only transfer files and data in one specific repository using SFTP.\n\nUPPMAX provides computing resources for Swedish researchers for all scientific domains, so getting software updates can occasionally take some time.\nTypically, [Environment Modules](http://modules.sourceforge.net/) are used which allow several versions of different tools - this is good for reproducibility and is quite easy to use. However, the approach is not portable across different clusters outside of UPPMAX.\n\n### Why use containers?\n\nThe idea of using containers, for improved portability and reproducibility, and more up to date tools, came naturally to us, as it is easily managed within Nextflow.\nWe cannot use [Docker](https://www.docker.com/) on our secure cluster, so we wanted to run CAW with [Singularity](http://singularity.lbl.gov/) images instead.\n\n### How was the switch made?\n\nWe were already using Docker containers for our continuous integration testing with Travis, and since we use many tools, I took the approach of making (almost) a container for each process.\nBecause this process is quite slow, repetitive and I~~'m lazy~~ like to automate everything, I made a simple NF [script](https://github.com/SciLifeLab/CAW/blob/master/buildContainers.nf) to build and push all docker containers.\nBasically it's just `build` and `pull` for all containers, with some configuration possibilities.\n\n```\ndocker build -t ${repository}/${container}:${tag} ${baseDir}/containers/${container}/.\n\ndocker push ${repository}/${container}:${tag}\n```\n\nSince Singularity can directly pull images from DockerHub, I made the build script to pull all containers from DockerHub to have local Singularity image files.\n\n```\nsingularity pull --name ${container}-${tag}.img docker://${repository}/${container}:${tag}\n```\n\nAfter this, it's just a matter of moving all containers to the secure cluster we're using, and using the right configuration file in the profile.\nI'll spare you the details of the SFTP transfer.\nThis is what the configuration file for such Singularity images looks like: [`singularity-path.config`](https://github.com/SciLifeLab/CAW/blob/master/configuration/singularity-path.config)\n\n```\n/*\nvim: syntax=groovy\n-*- mode: groovy;-*-\n * -------------------------------------------------\n * Nextflow config file for CAW project\n * -------------------------------------------------\n * Paths to Singularity images for every process\n * No image will be pulled automatically\n * Need to transfer and set up images before\n * -------------------------------------------------\n */\n\nsingularity {\n  enabled = true\n  runOptions = \"--bind /scratch\"\n}\n\nparams {\n  containerPath='containers'\n  tag='1.2.3'\n}\n\nprocess {\n  $ConcatVCF.container      = \"${params.containerPath}/caw-${params.tag}.img\"\n  $RunMultiQC.container     = \"${params.containerPath}/multiqc-${params.tag}.img\"\n  $IndelRealigner.container = \"${params.containerPath}/gatk-${params.tag}.img\"\n  // I'm not putting the whole file here\n  // you probably already got the point\n}\n```\n\nThis approach ran (almost) perfectly on the first try, except a process failing due to a typo on a container name...\n\n### Conclusion\n\nThis switch was completed a couple of months ago and has been a great success.\nWe are now using Singularity containers in almost all of our Nextflow pipelines developed at NGI.\nEven if we do enjoy the improved control, we must not forgot that:\n\n&gt; With great power comes great responsibility!\n\n### Credits\n\nThanks to [Rickard Hammarén](https://github.com/Hammarn) and [Phil Ewels](http://phil.ewels.co.uk/) for comments and suggestions for improving the post.",
    "images": [
      "/img/CAW_logo.png"
    ],
    "author": "Maxime Garcia",
    "tags": "pipelines,nextflow,genomic,workflow,singularity,cancer"
  },
  {
    "slug": "2017/nextflow-and-cwl",
    "title": "Nextflow and the Common Workflow Language",
    "date": "2017-07-20T00:00:00.000Z",
    "content": "The Common Workflow Language ([CWL](http://www.commonwl.org/)) is a specification for defining\nworkflows in a declarative manner. It has been implemented to varying degrees\nby different software packages. Nextflow and CWL share a common goal of enabling portable\nreproducible workflows.\n\nWe are currently investigating the automatic conversion of CWL workflows into Nextflow scripts\nto increase the portability of workflows. This work is being developed as\nthe [cwl2nxf](https://github.com/nextflow-io/cwl2nxf) project, currently in early prototype stage.\n\nOur first phase of the project was to determine mappings of CWL to Nextflow and familiarize\nourselves with how the current implementation of the converter supports a number of CWL specific\nfeatures.\n\n### Mapping CWL to Nextflow\n\nInputs in the CWL workflow file are initially parsed as _channels_ or other Nextflow input types.\nEach step specified in the workflow is then parsed independently. At the time of writing\nsubworkflows are not supported, each step must be a CWL `CommandLineTool` file.\n\nThe image below shows an example of the major components in the CWL files and then post-conversion (click to zoom).\n\n[![Nextflow CWL conversion](/img/cwl2nxf-min.png)](/img/cwl2nxf-min.png)\n\nCWL and Nextflow share a similar structure of defining inputs and outputs as shown above.\n\nA notable difference between the two is how tasks are defined. CWL requires either a separate\nfile for each task or a sub-workflow. CWL also requires the explicit mapping of each command\nline option for an executed tool. This is done using YAML meta-annotation to indicate the position, prefix, etc.\nfor each command line option.\n\nIn Nextflow a task command is defined as a separated component in the `process` definition and\nit is ultimately a multiline string which is interpreted by a command script by the underlying\nsystem. Input parameters can be used in the command string with a simple variable interpolation\nmechanism. This is beneficial as it simplifies porting existing BASH scripts to Nextflow\nwith minimal refactoring.\n\nThese examples highlight some of the differences between the two approaches, and the difficulties\nconverting complex use cases such as scatter, CWL expressions, and conditional command line inclusion.\n\n### Current status\n\nThe cwl2nxf is a Groovy based tool with a limited conversion ability. It parses the\nYAML documents and maps the various CWL objects to Nextflow. Conversion examples are\nprovided as part of the repository along with documentation for each example specifying the mapping.\n\nThis project was initially focused on developing an understanding of how to translate CWL to Nextflow.\nA number of CWL specific features such as scatter, secondary files and simple JavaScript expressions\nwere analyzed and implemented.\n\nThe GitHub repository includes instructions on how to build cwl2nxf and an example usage.\nThe tool can be executed as either just a parser printing the converted CWL to stdout,\nor by specifying an output file which will generate the Nextflow script file and if necessary\na config file.\n\nThe tool takes in a CWL workflow file and the YAML inputs file. It does not currently work\nwith a standalone `CommandLineTool`. The following example show how to run it:\n\n```\njava -jar build/libs/cwl2nxf-*.jar rnatoy.cwl samp.yaml\n```\n\n<br>\nSee the GitHub [repository](https://github.com/nextflow-io/cwl2nxf) for further details.\n\n### Conclusion\n\nWe are continuing to investigate ways to improve the interoperability of Nextflow with CWL.\nAlthough still an early prototype, the cwl2nxf tool provides some level of conversion of CWL to Nextflow.\n\nWe are also planning to explore [CWL Avro](https://github.com/common-workflow-language/cwlavro),\nwhich may provide a more efficient way to parse and handle CWL objects for conversion to Nextflow.\n\nAdditionally, a number of workflows in the GitHub repository have been implemented in both\nCWL and Nextflow which can be used as a comparison of the two languages.\n\nThe Nextflow team will be presenting a short talk and participating in the Codefest at [BOSC 2017](https://www.open-bio.org/wiki/BOSC_2017).\nWe are interested in hearing from the community regarding CWL to Nextflow conversion, and would like\nto encourage anyone interested to contribute to the cwl2nxf project.",
    "images": [],
    "author": "Kevin Sayers",
    "tags": "nextflow,workflow,reproducibility,cwl"
  },
  {
    "slug": "2017/nextflow-hack17",
    "title": "Nexflow Hackathon 2017",
    "date": "2017-09-30T00:00:00.000Z",
    "content": "Last week saw the inaugural Nextflow meeting organised at the Centre for Genomic Regulation\n(CRG) in Barcelona. The event combined talks, demos, a tutorial/workshop for beginners as\nwell as two hackathon sessions for more advanced users.\n\nNearly 50 participants attended over the two days which included an entertaining tapas course\nduring the first evening!\n\nOne of the main objectives of the event was to bring together Nextflow users to work\ntogether on common interest projects. There were several proposals for the hackathon\nsessions and in the end five diverse ideas were chosen for communal development ranging from\nnew pipelines through to the addition of new features in Nextflow.\n\nThe proposals and outcomes of each the projects, which can be found in the issues section\nof [this GitHub repository](https://github.com/nextflow-io/hack17), have been summarised below.\n\n### Nextflow HTML tracing reports\n\nThe HTML tracing project aims to generate a rendered version of the Nextflow trace file to\nenable fast sorting and visualisation of task/process execution statistics.\n\nCurrently the data in the trace includes information such as CPU duration, memory usage and\ncompletion status of each task, however wading through the file is often not convenient\nwhen a large number of tasks have been executed.\n\n[Phil Ewels](https://github.com/ewels) proposed the idea and led the coordination effort\nwith the outcome being a very impressive working prototype which can be found in the Nextflow\nbranch `html-trace`.\n\nAn image of the example report is shown below with the interactive HTML available\n[here](/misc/nf-trace-report.html). It is expected to be merged into the main branch of Nextflow\nwith documentation in a near-future release.\n\n![Nextflow HTML execution report](/img/nf-trace-report-min.png)\n\n### Nextflow pipeline for 16S microbial data\n\nThe H3Africa Bioinformatics Network have been developing several pipelines which are used\nacross the participating centers. The diverse computing resources available across the nodes has led to\nmembers wanting workflow solutions with a particular focus on portability.\n\nWith this is mind, Scott Hazelhurst proposed a project for a 16S Microbial data analysis\npipeline which had [previously been developed using CWL](https://github.com/h3abionet/h3abionet16S/tree/master).\n\nThe participants made a new [branch](https://github.com/h3abionet/h3abionet16S/tree/nextflow)\nof the original pipeline and ported it into Nextflow.\n\nThe pipeline will continue to be developed with the goal of acting as a comparison between\nCWL and Nextflow. It is thought this can then be extended to other pipelines by both those\nwho are already familiar with Nextflow as well as used as a tool for training newer users.\n\n### Nextflow modules prototyping\n\n_Toolboxing_ allows users to incorporate software into their pipelines in an efficient and\nreproducible manner. Various software repositories are becoming increasing popular,\nhighlighted by the over 5,000 tools available in the [Galaxy Toolshed](https://toolshed.g2.bx.psu.edu/).\n\nProjects such as [Biocontainers](http://biocontainers.pro/) aim to wrap up the execution\nenvironment using containers. [Myself](https://github.com/skptic) and [Johan Viklund](https://github.com/viklund)\nwished to piggyback off existing repositories and settled on [Dockstore](https://dockstore.org)\nwhich is an open platform compliant with the [GA4GH](http://genomicsandhealth.org) initiative.\n\nThe majority of tools in Dockstore are written in the CWL and therefore we required a parser\nbetween the CWL CommandLineTool class and Nextflow processes. Johan was able to develop\na parser which generates Nextflow processes for several Dockstore tools.\n\nAs these resources such as Dockstore become mature and standardised, it will be\npossible to automatically generate a _Nextflow Store_ and enable efficient incorporation\nof tools into workflows.\n\n<script src=\"https://gist.github.com/pditommaso/7ccdb6e8af80133a25f259ae801371bf.js\"></script>\n\n_Example showing a Nextflow process generated from the Dockstore CWL repository for the tool BAMStats._\n\n### Nextflow pipeline for de novo assembly of nanopore reads\n\n[Nanopore sequencing](https://en.wikipedia.org/wiki/Nanopore_sequencing) is an exciting\nand emerging technology which promises to change the landscape of nucleotide sequencing.\n\nWith keen interest in Nanopore specific pipelines, [Hadrien Gourlé](https://github.com/HadrienG)\nlead the hackathon project for _Nanoflow_.\n\n[Nanoflow](https://github.com/HadrienG/nanoflow) is a de novo assembler of bacterials genomes\nfrom nanopore reads using Nextflow.\n\nDuring the two days the participants developed the pipeline for adapter trimming as well\nas assembly and consensus sequence generation using either\n[Canu](https://github.com/marbl/canu) and [Miniasm](https://github.com/lh3/miniasm).\n\nThe future plans are to finalise the pipeline to include a polishing step and a genome\nannotation step.\n\n### Nextflow AWS Batch integration\n\nNextflow already has experimental support for [AWS Batch](https://aws.amazon.com/batch/)\nand the goal of this project proposed by [Francesco Strozzi](https://github.com/fstrozzi)\nwas to improve this support, add features and test the implementation on real world pipelines.\n\nEarlier work from [Paolo Di Tommaso](https://github.com/pditommaso) in the Nextflow\nrepository, highlighted several challenges to using AWS Batch with Nextflow.\n\nThe major obstacle described by [Tim Dudgeon](https://github.com/tdudgeon) was the requirement\nfor each Docker container to have a version of the Amazon Web Services Command Line tools\n(aws-cli) installed.\n\nA solution was to install the AWS CLI tools on a custom AWS image that is used by the\nDocker host machine, and then mount the directory that contains the necessary items into\neach of the Docker containers as a volume. Early testing suggests this approach works\nwith the hope of providing a more elegant solution in future iterations.\n\nThe code and documentation for AWS Batch has been prepared and will be tested further\nbefore being rolled into an official Nextflow release in the near future.\n\n### Conclusion\n\nThe event was seen as an overwhelming success and special thanks must be made to all the\nparticipants. As the Nextflow community continues to grow, it would be fantastic to make these types\nmeetings more regular occasions.\n\nIn the meantime we have put together a short video containing some of the highlights\nof the two days.\n\nWe hope to see you all again in Barcelona soon or at new events around the world!\n\n<iframe width=\"760\" height=\"428\" src=\"https://www.youtube.com/embed/s7SqYMRiY8w?rel=0\" frameborder=\"0\" allowfullscreen=\"\"></iframe>",
    "images": [],
    "author": "Evan Floden",
    "tags": "nextflow,docker,hackathon"
  },
  {
    "slug": "2017/nextflow-nature-biotech-paper",
    "title": "Nextflow published in Nature Biotechnology",
    "date": "2017-04-12T00:00:00.000Z",
    "content": "We are excited to announce the publication of our work _[Nextflow enables reproducible computational workflows](http://rdcu.be/qZVo)_ in Nature Biotechnology.\n\nThe article provides a description of the fundamental components and principles of Nextflow.\nWe illustrate how the unique combination of containers, pipeline sharing and portable\ndeployment provides tangible advantages to researchers wishing to generate reproducible\ncomputational workflows.\n\nReproducibility is a [major challenge](http://www.nature.com/news/reproducibility-1.17552)\nin today's scientific environment. We show how three bioinformatics data analyses produce\ndifferent results when executed on different execution platforms and how Nextflow, along\nwith software containers, can be used to control numerical stability, enabling consistent\nand replicable results across different computing platforms. As complex omics analyses\nenter the clinical setting, ensuring that results remain stable brings on extra importance.\n\nSince its first release three years ago, the Nextflow user base has grown in an organic fashion.\nFrom the beginning it has been our own demands in a workflow tool and those of our users that\nhave driven the development of Nextflow forward. The publication forms an important milestone\nin the project and we would like to extend a warm thank you to all those who have been early\nusers and contributors.\n\nWe kindly ask if you use Nextflow in your own work to cite the following article:\n\n<div style=\"padding: 0.7em 1.5em; background-color: #eee\">\nDi Tommaso, P., Chatzou, M., Floden, E. W., Barja, P. P., Palumbo, E., &amp; Notredame, C. (2017).\n*Nextflow enables reproducible computational workflows.* Nature Biotechnology, 35(4), 316–319.\n[doi:10.1038/nbt.3820](http://www.nature.com/nbt/journal/v35/n4/full/nbt.3820.html)\n</div>",
    "images": [],
    "author": "Paolo Di Tommaso",
    "tags": "pipelines,nextflow,genomic,workflow,paper"
  },
  {
    "slug": "2017/nextflow-workshop",
    "title": "Nextflow workshop is coming!",
    "date": "2017-04-26T00:00:00.000Z",
    "content": "We are excited to announce the first Nextflow workshop that will take place at the\nBarcelona Biomedical Research Park building ([PRBB](https://www.prbb.org/)) on 14-15th September 2017.\n\nThis event is open to everybody who is interested in the problem of computational workflow\nreproducibility. Leading experts and users will discuss the current state of the Nextflow\ntechnology and how it can be applied to manage -omics analyses in a reproducible manner.\nBest practices will be introduced on how to deploy real-world large-scale genomic\napplications for precision medicine.\n\nDuring the hackathon, organized for the second day, participants will have the\nopportunity to learn how to write self-contained, replicable data analysis\npipelines along with Nextflow expert developers.\n\nMore details at [this link](http://www.crg.eu/en/event/coursescrg-nextflow-reproducible-silico-genomics).\nThe registration form is [available here](http://apps.crg.es/content/internet/events/webforms/17502) (deadline 15th Jun).\n\n### Schedule (draft)\n\n#### Thursday, 14 September\n\n<table border=\"1\" cellpadding=\"9\" width=\"90%\">\n<tbody><tr>\n<td valign=\"top\">10.00</td>\n<td valign=\"top\">Welcome &amp; introduction<br>\n    *Cedric Notredame<br>\n    Comparative Bioinformatics, CRG, Spain*</td>\n</tr>\n\n<tr>\n<td valign=\"top\">10.15</td>\n<td valign=\"top\">Nextflow: a quick review<br>\n    *Paolo Di Tommaso<br>\n    Comparative Bioinformatics, CRG, Spain*</td>\n</tr>\n\n<tr>\n<td valign=\"top\">10.30</td>\n<td valign=\"top\">Standardising Swedish genomics analyses using Nextflow<br>\n    *Phil Ewels<br>\n    National Genomics Infrastructure, SciLifeLab, Sweden*\n    </td>\n</tr>\n\n<tr>\n<td valign=\"top\">11.00</td>\n<td valign=\"top\">Building Pipelines to Support African Bioinformatics: the H3ABioNet Pipelines Project<br>\n    *Scott Hazelhurst<br>\n    University of the Witwatersrand, Johannesburg, South Africa*\n    </td>\n</tr>\n\n<tr>\n<td valign=\"top\">11.30</td>\n<td valign=\"top\">coffee break\n    </td>\n</tr>\n\n<tr>\n<td valign=\"top\">12.00</td>\n<td valign=\"top\">Using Nextflow for Large Scale Benchmarking of Phylogenetic methods and tools<br>\n    *Frédéric Lemoine<br>\n    Evolutionary Bioinformatics, Institut Pasteur, France*\n    </td>\n</tr>\n\n<tr>\n<td valign=\"top\">12.30</td>\n<td valign=\"top\">Nextflow for chemistry - crossing the divide<br>\n    *Tim Dudgeon<br>\n    Informatics Matters Ltd, UK*\n    </td>\n</tr>\n\n<tr>\n<td valign=\"top\">12.50</td>\n<td valign=\"top\">From zero to Nextflow @ CRG's Biocore<br>\n    *Luca Cozzuto<br>\n    Bioinformatics Core Facility, CRG, Spain*\n    </td>\n</tr>\n\n<tr>\n<td valign=\"top\">13.10</td>\n<td valign=\"top\">(to be determined)</td>\n</tr>\n\n<tr>\n<td valign=\"top\">13.30</td>\n<td valign=\"top\">Lunch</td>\n</tr>\n\n<tr>\n<td valign=\"top\">14.30<br>18.30</td>\n<td valign=\"top\">Hackathon &amp; course</td>\n</tr>\n\n</tbody></table>\n\n#### Friday, 15 September\n\n<table border=\"1\" cellpadding=\"9\" width=\"90%\">\n<tbody><tr>\n<td valign=\"top\">9.30</td>\n<td valign=\"top\">Computational workflows for omics analyses at the IARC<br>\n    *Matthieu Foll<br>\n    International Agency for Research on Cancer (IARC), France*</td>\n</tr>\n\n<tr>\n<td valign=\"top\">10.00</td>\n<td valign=\"top\">Medical Genetics at Oslo University Hospital<br>\n    *Hugues Fontanelle<br>\n    Oslo University Hospital, Norway*</td>\n</tr>\n\n<tr>\n<td valign=\"top\">10.30</td>\n<td valign=\"top\">Inside-Out: reproducible analysis of external data, inside containers with Nextflow<br>\n    *Evan Floden<br>\n    Comparative Bioinformatics, CRG, Spain*</td>\n</tr>\n\n<tr>\n<td valign=\"top\">11.00</td>\n<td valign=\"top\">coffee break</td>\n</tr>\n\n<tr>\n<td valign=\"top\">11.30</td>\n<td valign=\"top\">(title to be defined)<br>\n    *Johnny Wu<br>\n    Roche Sequencing, Pleasanton, USA*</td>\n</tr>\n\n<tr>\n<td valign=\"top\">12.00</td>\n<td valign=\"top\">Standardizing life sciences datasets to improve studies reproducibility in the EOSC<br>\n    *Jordi Rambla<br>\n    European Genome-Phenome Archive, CRG*</td>\n</tr>\n\n<tr>\n<td valign=\"top\">12.20</td>\n<td valign=\"top\">Unbounded by Economics<br>\n    *Brendan Bouffler<br>\n    AWS Research Cloud Program, UK*</td>\n</tr>\n\n<tr>\n<td valign=\"top\">12.40</td>\n<td valign=\"top\">Challenges with large-scale portable computational workflows<br>\n    *Paolo Di Tommaso<br>\n    Comparative Bioinformatics, CRG, Spain*</td>\n</tr>\n\n<tr>\n<td valign=\"top\">13.00</td>\n<td valign=\"top\">Lunch</td>\n</tr>\n\n<tr>\n<td valign=\"top\">14.00<br>18.00</td>\n<td valign=\"top\">Hackathon</td>\n</tr>\n\n</tbody></table>\n\n<br>\nSee you in Barcelona!\n\n![Nextflow workshop](/img/nf-workshop.png)",
    "images": [],
    "author": "Paolo Di Tommaso",
    "tags": "nextflow,genomic,workflow,reproducibility,workshop,"
  },
  {
    "slug": "2017/scaling-with-aws-batch",
    "title": "Scaling with AWS Batch",
    "date": "2017-11-08T00:00:00.000Z",
    "content": "The latest Nextflow release (0.26.0) includes built-in support for [AWS Batch](https://aws.amazon.com/batch/),\na managed computing service that allows the execution of containerised workloads\nover the Amazon EC2 Container Service (ECS).\n\nThis feature allows the seamless deployment of Nextflow pipelines in the cloud by offloading\nthe process executions as managed Batch jobs. The service takes care to spin up the required\ncomputing instances on-demand, scaling up and down the number and composition of the instances\nto best accommodate the actual workload resource needs at any point in time.\n\nAWS Batch shares with Nextflow the same vision regarding workflow containerisation\ni.e. each compute task is executed in its own Docker container. This dramatically\nsimplifies the workflow deployment through the download of a few container images.\nThis common design background made the support for AWS Batch a natural extension for Nextflow.\n\n### Batch in a nutshell\n\nBatch is organised in _Compute Environments_, _Job queues_, _Job definitions_ and _Jobs_.\n\nThe _Compute Environment_ allows you to define the computing resources required for a specific workload (type).\nYou can specify the minimum and maximum number of CPUs that can be allocated,\nthe EC2 provisioning model (On-demand or Spot), the AMI to be used and the allowed instance types.\n\nThe _Job queue_ definition allows you to bind a specific task to one or more Compute Environments.\n\nThen, the _Job definition_ is a template for one or more jobs in your workload. This is required\nto specify the Docker image to be used in running a particular task along with other requirements\nsuch as the container mount points, the number of CPUs, the amount of memory and the number of\nretries in case of job failure.\n\nFinally the _Job_ binds a Job definition to a specific Job queue\nand allows you to specify the actual task command to be executed in the container.\n\nThe job input and output data management is delegated to the user. This means that if you\nonly use Batch API/tools you will need to take care to stage the input data from a S3 bucket\n(or a different source) and upload the results to a persistent storage location.\n\nThis could turn out to be cumbersome in complex workflows with a large number of\ntasks and above all it makes it difficult to deploy the same applications across different\ninfrastructure.\n\n### How to use Batch with Nextflow\n\nNextflow streamlines the use of AWS Batch by smoothly integrating it in its workflow processing\nmodel and enabling transparent interoperability with other systems.\n\nTo run Nextflow you will need to set-up in your AWS Batch account a [Compute Environment](http://docs.aws.amazon.com/batch/latest/userguide/compute_environments.html)\ndefining the required computing resources and associate it to a [Job Queue](http://docs.aws.amazon.com/batch/latest/userguide/job_queues.html).\n\nNextflow takes care to create the required _Job Definitions_ and _Job_ requests as needed.\nThis spares some Batch configurations steps.\n\nIn the `nextflow.config`, file specify the `awsbatch` executor, the Batch `queue` and\nthe container to be used in the usual manner. You may also need to specify the AWS region\nand access credentials if they are not provided by other means. For example:\n\n    process.executor = 'awsbatch'\n    process.queue = 'my-batch-queue'\n    process.container = your-org/your-docker:image\n    aws.region = 'eu-west-1'\n    aws.accessKey = 'xxx'\n    aws.secretKey = 'yyy'\n\nEach process can eventually use a different queue and Docker image (see Nextflow documentation for details).\nThe container image(s) must be published in a Docker registry that is accessible from the\ninstances run by AWS Batch eg. [Docker Hub](https://hub.docker.com/), [Quay](https://quay.io/)\nor [ECS Container Registry](https://aws.amazon.com/ecr/).\n\nThe Nextflow process can be launched either in a local computer or a EC2 instance.\nThe latter is suggested for heavy or long running workloads.\n\nNote that input data should be stored in the S3 storage. In the same manner\nthe pipeline execution must specify a S3 bucket as a working directory by using the `-w` command line option.\n\nA final caveat about custom containers and computing AMI. Nextflow automatically stages input\ndata and shares tasks intermediate results by using the S3 bucket specified as a work directory.\nFor this reason it needs to use the `aws` command line tool which must be installed either\nin your process container or be present in a custom AMI that can be mounted and accessed\nby the Docker containers.\n\nYou may also need to create a custom AMI because the default image used by AWS Batch only\nprovides 22 GB of storage which may not be enough for real world analysis pipelines.\n\nSee the documentation to learn [how to create a custom AMI](/docs/latest/awscloud.html#custom-ami)\nwith larger storage and how to setup the AWS CLI tools.\n\n### An example\n\nIn order to validate Nextflow integration with AWS Batch, we used a simple RNA-Seq pipeline.\n\nThis pipeline takes as input a metadata file from the Encode project corresponding to a [search\nreturning all human RNA-seq paired-end datasets](https://www.encodeproject.org/search/?type=Experiment&amp;award.project=ENCODE&amp;replicates.library.biosample.donor.organism.scientific_name=Homo+sapiens&amp;files.file_type=fastq&amp;files.run_type=paired-ended&amp;replicates.library.nucleic_acid_term_name=RNA&amp;replicates.library.depleted_in_term_name=rRNA)\n(the metadata file has been additionally filtered to retain only data having a SRA ID).\n\nThe pipeline automatically downloads the FASTQ files for each sample from the EBI ENA database,\nit assesses the overall quality of sequencing data using FastQC and then runs [Salmon](https://combine-lab.github.io/salmon/)\nto perform the quantification over the human transcript sequences. Finally all the QC and\nquantification outputs are summarised using the [MultiQC](http://multiqc.info/) tool.\n\nFor the sake of this benchmark we used the first 38 samples out of the full 375 samples dataset.\n\nThe pipeline was executed both on AWS Batch cloud and in the CRG internal Univa cluster,\nusing [Singularity](/blog/2016/more-fun-containers-hpc.html) as containers runtime.\n\nIt's worth noting that with the exception of the two configuration changes detailed below,\nwe used exactly the same pipeline implementation at [this GitHub repository](https://github.com/nextflow-io/rnaseq-encode-nf).\n\nThe AWS deploy used the following configuration profile:\n\n    aws.region = 'eu-west-1'\n    aws.client.storageEncryption = 'AES256'\n    process.queue = 'large'\n    executor.name = 'awsbatch'\n    executor.awscli = '/home/ec2-user/miniconda/bin/aws'\n\nWhile for the cluster deployment the following configuration was used:\n\n    executor = 'crg'\n    singularity.enabled = true\n    process.container = \"docker://nextflow/rnaseq-nf\"\n    process.queue = 'cn-el7'\n    process.time = '90 min'\n    process.$quant.time = '4.5 h'\n\n### Results\n\nThe AWS Batch Compute environment was configured to use a maximum of 132 CPUs as the number of CPUs\nthat were available in the queue for local cluster deployment.\n\nThe two executions ran in roughly the same time: 2 hours and 24 minutes when running in the\nCRG cluster and 2 hours and 37 minutes when using AWS Batch.\n\nIt must be noted that 14 jobs failed in the Batch deployment, presumably because one or more spot\ninstances were retired. However Nextflow was able to re-schedule the failed jobs automatically\nand the overall pipeline execution completed successfully, also showing the benefits of a truly\nfault tolerant environment.\n\nThe overall cost for running the pipeline with AWS Batch was **$5.47** ($ 3.28 for EC2 instances,\n$1.88 for EBS volume and $0.31 for S3 storage). This means that with ~ $55 we could have\nperformed the same analysis on the full Encode dataset.\n\nIt is more difficult to estimate the cost when using the internal cluster, because we don't\nhave access to such detailed cost accounting. However, as a user, we can estimate it roughly\ncomes out at $0.01 per CPU-Hour. The pipeline needed around 147 CPU-Hour to carry out the analysis,\nhence with an estimated cost of **$1.47** just for the computation.\n\nThe execution report for the Batch execution is available at [this link](https://cdn.rawgit.com/nextflow-io/rnaseq-encode-nf/db303a81/benchmark/aws-batch/report.html)\nand the one for cluster is available [here](https://cdn.rawgit.com/nextflow-io/rnaseq-encode-nf/db303a81/benchmark/crg-cluster/report.html).\n\n### Conclusion\n\nThis post shows how Nextflow integrates smoothly with AWS Batch and how it can be used to\ndeploy and execute real world genomics pipeline in the cloud with ease.\n\nThe auto-scaling ability provided by AWS Batch along with the use of spot instances make\nthe use of the cloud even more cost effective. Running on a local cluster may still be cheaper,\neven if it is non trivial to account for all the real costs of a HPC infrastructure.\nHowever the cloud allows flexibility and scalability not possible with common on-premises clusters.\n\nWe also demonstrate how the same Nextflow pipeline can be _transparently_ deployed in two very\ndifferent computing infrastructure, using different containerisation technologies by simply\nproviding a separate configuration profile.\n\nThis approach enables the interoperability across different deployment sites, reduces\noperational and maintenance costs and guarantees consistent results over time.\n\n### Credits\n\nThis post is co-authored with [Francesco Strozzi](https://twitter.com/fstrozzi),\nwho also helped to write the pipeline used for the benchmark in this post and contributed\nto and tested the AWS Batch integration. Thanks to [Emilio Palumbo](https://github.com/emi80)\nthat helped to set-up and configure the AWS Batch environment and [Evan Floden](https://gitter.im/skptic)\nfor the comments.",
    "images": [],
    "author": "Paolo Di Tommaso",
    "tags": "pipelines,nextflow,genomic,workflow,aws,batch"
  },
  {
    "slug": "2018/bringing-nextflow-to-google-cloud-wuxinextcode",
    "title": "Bringing Nextflow to Google Cloud Platform with WuXi NextCODE",
    "date": "2018-12-18T00:00:00.000Z",
    "content": "<div class=\"text-muted\" style=\"margin-bottom:2em\">\n*This is a guest post authored by Halli Bjornsson, Head of Product Development Operations at WuXi NextCODE and Jonathan Sheffi, Product Manager, Biomedical Data at Google Cloud.\n*\n</div>\n\nGoogle Cloud and WuXi NextCODE are dedicated to advancing the state of the art in biomedical informatics, especially through open source, which allows developers to collaborate broadly and deeply.\n\nWuXi NextCODE is itself a user of Nextflow, and Google Cloud has many customers that use Nextflow. Together, we’ve collaborated to deliver Google Cloud Platform (GCP) support for Nextflow using the [Google Pipelines API](https://cloud.google.com/genomics/pipelines). Pipelines API is a managed computing service that allows the execution of containerized workloads on GCP.\n\n<div class=\"row\">\n  <div class=\"column\">\n  <img src=\"/img/google-cloud.svg\" style=\"width:80%; padding:1.7em; \">\n  </div>\n  <div class=\"column\">\n  <img src=\"/img/wuxi-nextcode.jpeg\" style=\"width:80%; padding:1em\">\n  </div>\n</div>\n<style>\n.column {\n  float: left;\n  width: 50%;\n}\n\n.row:after {\ncontent: \"\";\ndisplay: table;\nclear: both;\n}\n</style>\n\nNextflow now provides built-in support for Google Pipelines API which allows the seamless deployment of a Nextflow pipeline in the cloud, offloading the process executions as pipelines running on Google's scalable infrastructure with a few commands. This makes it even easier for customers and partners like WuXi NextCODE to process biomedical data using Google Cloud.\n\n### Get started!\n\nThis feature is currently available in the Nextflow edge channel. Follow these steps to get started:\n\n- Install Nextflow from the edge channel exporting the variables shown below and then running the usual Nextflow installer Bash snippet:\n\n  ```\n  export NXF_VER=18.12.0-edge\n  export NXF_MODE=google\n  curl https://get.nextflow.io | bash\n  ```\n\n- [Enable the Google Genomics API for your GCP projects](https://console.cloud.google.com/flows/enableapi?apiid=genomics.googleapis.com,compute.googleapis.com,storage-api.googleapis.com).\n\n- [Download and set credentials for your Genomics API-enabled project](https://cloud.google.com/docs/authentication/production#obtaining_and_providing_service_account_credentials_manually).\n\n- Change your `nextflow.config` file to use the Google Pipelines executor and specify the required config values for it as [described in the documentation](/docs/edge/google.html#google-pipelines).\n\n- Finally, run your script with Nextflow like usual, specifying a Google Storage bucket as the pipeline work directory with the `-work-dir` option. For example:\n\n  ```\n  nextflow run rnaseq-nf -work-dir gs://your-bucket/scratch\n  ```\n\n<br>\nYou can find more detailed info about available configuration settings and deployment options at [this link](/docs/edge/google.html).\n\nWe’re thrilled to make this contribution available to the Nextflow community!",
    "images": [
      "/img/google-cloud.svg",
      "/img/wuxi-nextcode.jpeg"
    ],
    "author": "Paolo Di Tommaso",
    "tags": "nextflow,wuxinextcode,google,cloud"
  },
  {
    "slug": "2018/clarification-about-nextflow-license",
    "title": "Clarification about the Nextflow license",
    "date": "2018-07-20T00:00:00.000Z",
    "content": "Over past week there was some discussion on social media regarding the Nextflow license\nand its impact on users' workflow applications.\n\n&gt; …&nbsp;don’t use Nextflow, yo. [https://t.co/Paip5W1wgG](https://t.co/Paip5W1wgG)\n&gt; \n&gt; — Konrad Rudolph 👨‍🔬💻 (@klmr) [July 10, 2018](https://twitter.com/klmr/status/1016606226103357440?ref_src=twsrc%5Etfw)\n\n<script async=\"\" src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\n&gt; This is certainly disappointing. An argument in favor of writing workflows in [@commonwl](https://twitter.com/commonwl?ref_src=twsrc%5Etfw), which is independent of the execution engine. [https://t.co/mIbdLQQxmf](https://t.co/mIbdLQQxmf)\n&gt; \n&gt; — John Didion (@jdidion) [July 10, 2018](https://twitter.com/jdidion/status/1016612435938160640?ref_src=twsrc%5Etfw)\n\n<script async=\"\" src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\n&gt; GPL is generally considered toxic to companies due to fear of the viral nature of the license.\n&gt; \n&gt; — Jeff Gentry (@geoffjentry) [July 10, 2018](https://twitter.com/geoffjentry/status/1016656901139025921?ref_src=twsrc%5Etfw)\n\n<script async=\"\" src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\n### What's the problem with GPL?\n\nNextflow has been released under the GPLv3 license since its early days [over 5 years ago](https://github.com/nextflow-io/nextflow/blob/c080150321e5000a2c891e477bb582df07b7f75f/src/main/groovy/nextflow/Nextflow.groovy).\nGPL is a very popular open source licence used by many projects\n(like, for example, [Linux](https://www.kernel.org/doc/html/v4.17/process/license-rules.html) and [Git](https://git-scm.com/about/free-and-open-source))\nand it has been designed to promote the adoption and spread of open source software and culture.\n\nWith this idea in mind, GPL requires the author of a piece of software, _derived_ from a GPL licensed application or library, to distribute it using the same license i.e. GPL itself.\n\nThis is generally good, because this requirement incentives the growth of the open source ecosystem and the adoption of open source software more widely.\n\nHowever, this is also a reason for concern by some users and organizations because it's perceived as too strong requirement by copyright holders (who may not want to disclose their code) and because it can be difficult to interpret what a \\*derived\\* application is. See for example\n[this post by Titus Brown](http://ivory.idyll.org/blog/2015-on-licensing-in-bioinformatics.html) at this regard.\n\n#### What's the impact of the Nextflow license on my application?\n\nIf you are not distributing your application, based on Nextflow, it doesn't affect you in any way.\nIf you are distributing an application that requires Nextflow to be executed, technically speaking your application is dynamically linking to the Nextflow runtime and it uses routines provided by it. For this reason your application should be released as GPLv3. See [here](https://www.gnu.org/licenses/gpl-faq.en.html#GPLStaticVsDynamic) and [here](https://www.gnu.org/licenses/gpl-faq.en.html#IfInterpreterIsGPL).\n\n**However, this was not our original intention. We don’t consider workflow applications to be subject to the GPL copyleft obligations of the GPL even though they may link dynamically to Nextflow functionality through normal calls and we are not interested to enforce the license requirement to third party workflow developers and organizations. Therefore you can distribute your workflow application using the license of your choice. For other kind of derived applications the GPL license should be used, though.\n**\n\n### That's all?\n\nNo. We are aware that this is not enough and the GPL licence can impose some limitation in the usage of Nextflow to some users and organizations. For this reason we are working with the CRG legal department to move Nextflow to a more permissive open source license. This is primarily motivated by our wish to make it more adaptable and compatible with all the different open source ecosystems, but also to remove any remaining legal uncertainty that using Nextflow through linking with its functionality may cause.\n\nWe are expecting that this decision will be made over the summer so stay tuned and continue to enjoy Nextflow.",
    "images": [],
    "author": "Paolo Di Tommaso",
    "tags": "nextflow,gpl,license"
  },
  {
    "slug": "2018/conda-support-has-landed",
    "title": "Conda support has landed!",
    "date": "2018-06-05T00:00:00.000Z",
    "content": "Nextflow aims to ease the development of large scale, reproducible workflows allowing\ndevelopers to focus on the main application logic and to rely on best community tools and\nbest practices.\n\nFor this reason we are very excited to announce that the latest Nextflow version (`0.30.0`) finally\nprovides built-in support for [Conda](https://conda.io/docs/).\n\nConda is a popular package manager that simplifies the installation of software packages\nand the configuration of complex software environments. Above all, it provides access to large\ntool and software package collections maintained by domain specific communities such as\n[Bioconda](https://bioconda.github.io) and [BioBuild](https://biobuilds.org/).\n\nThe native integration with Nextflow allows researchers to develop workflow applications\nin a rapid and easy repeatable manner, reusing community tools, whilst taking advantage of the\nconfiguration flexibility, portability and scalability provided by Nextflow.\n\n### How it works\n\nNextflow automatically creates and activates the Conda environment(s) given the dependencies\nspecified by each process.\n\nDependencies are specified by using the [conda](/docs/latest/process.html#conda) directive,\nproviding either the names of the required Conda packages, the path of a Conda environment yaml\nfile or the path of an existing Conda environment directory.\n\nConda environments are stored on the file system. By default Nextflow instructs Conda to save\nthe required environments in the pipeline work directory. You can specify the directory where the\nConda environments are stored using the `conda.cacheDir` configuration property.\n\n#### Use Conda package names\n\nThe simplest way to use one or more Conda packages consists in specifying their names using the `conda` directive.\nMultiple package names can be specified by separating them with a space. For example:\n\n```\nprocess foo {\n    conda \"bwa samtools multiqc\"\n\n    \"\"\"\n    your_command --here\n    \"\"\"\n}\n```\n\nUsing the above definition a Conda environment that includes BWA, Samtools and MultiQC tools\nis created and activated when the process is executed.\n\nThe usual Conda package syntax and naming conventions can be used. The version of a package can be\nspecified after the package name as shown here: `bwa=0.7.15`.\n\nThe name of the channel where a package is located can be specified prefixing the package with\nthe channel name as shown here: `bioconda::bwa=0.7.15`.\n\n#### Use Conda environment files\n\nWhen working in a project requiring a large number of dependencies it can be more convenient\nto consolidate all required tools using a Conda environment file. This is a file that\nlists the required packages and channels, structured using the YAML format. For example:\n\n```\nname: my-env\nchannels:\n  - bioconda\n  - conda-forge\n  - defaults\ndependencies:\n  - star=2.5.4a\n  - bwa=0.7.15\n```\n\nThe path of the environment file can be specified using the `conda` directive:\n\n```\nprocess foo {\n  conda '/some/path/my-env.yaml'\n\n  '''\n  your_command --here\n  '''\n}\n```\n\nNote: the environment file name **must** end with a `.yml` or `.yaml` suffix otherwise\nit won't be properly recognized. Also relative paths are resolved against the workflow\nlaunching directory.\n\nThe suggested approach is to store the the Conda environment file in your project root directory\nand reference it in the `nextflow.config` directory using the `baseDir` variable as shown below:\n\n```\nprocess.conda = \"$baseDir/my-env.yaml\"\n```\n\nThis guarantees that the environment paths is correctly resolved independently of the execution path.\n\nSee the [documentation](/docs/latest/conda.html) for more details on how to configure and\nuse Conda environments in your Nextflow workflow.\n\n### Bonus!\n\nThis release includes also a better support for [Biocontainers](https://biocontainers.pro/). So far,\nNextflow users were able to use container images provided by the Biocontainers community. However,\nit was not possible to collect process metrics and runtime statistics within those images due to the usage\nof a legacy version of the `ps` system tool that is not compatible with the one expected by Nextflow.\n\nThe latest version of Nextflow does not require the `ps` tool any more to fetch execution metrics\nand runtime statistics, therefore this information is collected and correctly reported when using Biocontainers\nimages.\n\n### Conclusion\n\nWe are very excited by this new feature bringing the ability to use popular Conda tool collections,\nsuch as Bioconda, directly into Nextflow workflow applications.\n\nNextflow developers have now yet another option to transparently manage the dependencies in their\nworkflows along with [Environment Modules](/docs/latest/process.html#module) and [containers](/docs/latest/docker.html)\n[technology](/docs/latest/singularity.html), giving them great configuration flexibility.\n\nThe resulting workflow applications can easily be reconfigured and deployed across a range of different\nplatforms choosing the best technology according to the requirements of the target system.",
    "images": [],
    "author": "Paolo Di Tommaso",
    "tags": "nextflow,conda,bioconda"
  },
  {
    "slug": "2018/goodbye-zero-hello-apache",
    "title": "Goodbye zero, Hello Apache!",
    "date": "2018-10-24T00:00:00.000Z",
    "content": "Today marks an important milestone in the Nextflow project. We are thrilled to announce three important changes to better meet users’ needs and ground the project on a solid foundation upon which to build a vibrant ecosystem of tools and data analysis applications for genomic research and beyond.\n\n### Apache license\n\nNextflow was originally licensed as GPLv3 open source software more than five years ago. GPL is designed to promote the adoption and spread of open source software and culture. On the other hand it has also some controversial side-effects, such as the one on [derivative works](https://copyleft.org/guide/comprehensive-gpl-guidech5.html) and [legal implications](https://opensource.com/law/14/7/lawsuit-threatens-break-new-ground-gpl-and-software-licensing-issues) which make the use of GPL released software a headache in many organisations. We have previously discussed these concerns in [this blog post](/blog/2018/clarification-about-nextflow-license.html) and, after community feedback, have opted to change the project license to Apache 2.0.\n\nThis is a popular permissive free software license written by the [Apache Software Foundation](https://www.apache.org/) (ASF). Software distributed with this license requires the preservation of the copyright notice and disclaimer. It allows the freedom to use the software for any purpose, to distribute it, to modify it, and to distribute modified versions of the software without dictating the licence terms of the resulting applications and derivative works. We are sure this licensing model addresses the concerns raised by the Nextflow community and will boost further project developments.\n\n### New release schema\n\nIn the time since Nextflow was open sourced, we have released 150 versions which have been used by many organizations to deploy critical production workflows on a large range of computational platforms and under heavy loads and stress conditions.\n\nFor example, at the Centre for Genomic Regulation (CRG) alone, Nextflow has been used to deploy data intensive computation workflows since 2014, and it has orchestrated the execution of over 12 million jobs totalling 1.4 million CPU-hours.\n\n<img src=\"/img/nextflow-release-schema-01.png\" alt=\"Nextflow release schema\" style=\"float:right; width: 240pt; margin-top: -20px; margin-left: 20px\">\n\nThis extensive use across different execution environments has resulted in a reliable software package, and it's therefore finally time to declare Nextflow stable and drop the zero from the version number!\n\nFrom today onwards, Nextflow will use a 3 monthly time-based _stable_ release cycle. Today's release is numbered as **18.10**, the next one will be on January 2019, numbered as 19.01, and so on. This gives our users a more predictable release cadence and allows us to better focus on new feature development and scheduling.\n\nAlong with the 3-months stable release cycle, we will provide a monthly _edge_ release, which will include access to the latest experimental features and developments. As such, it should only be used for evaluation and testing purposes.\n\n### Commercial support\n\nFinally, for organisations requiring commercial support, we have recently incorporated [Seqera Labs](https://www.seqera.io/), a spin-off of the Centre for Genomic Regulation.\n\nSeqera Labs will foster Nextflow adoption as professional open source software by providing commercial support services and exploring new innovative products and solutions.\n\nIt's important to highlight that Seqera Labs will not close or make Nextflow a commercial project. Nextflow is and will continue to be owned by the CRG and the other contributing organisations and individuals.\n\n### Conclusion\n\nThe Nextflow project has reached an important milestone. In the last five years it has grown and managed to become a stable technology used by thousands of people daily to deploy large scale workloads for life science data analysis applications and beyond. The project is now exiting from the experimental stage.\n\nWith the above changes we want to fulfil the needs of researchers, for a reliable tool enabling scalable and reproducible data analysis, along with the demand of production oriented users, who require reliable support and services for critical deployments.\n\nAbove all, our aim is to strengthen the community effort around the Nextflow ecosystem and make it a sustainable and solid technology in the long run.\n\n### Credits\n\nWe want to say thank you to all the people who have supported and contributed to this project to this stage. First of all to Cedric Notredame for his long term commitment to the project within the Comparative Bioinformatics group at CRG. The Open Bioinformatics Foundation (OBF) in the name of Chris Fields and The Ontario Institute for Cancer Research (OICR), namely Dr Lincoln Stein, for supporting the Nextflow change of license. The CRG TBDO department, and in particular Salvatore Cappadona for his continued support and advice. Finally, the user community who with their feedback and constructive criticism contribute everyday to make this project more stable, useful and powerful.",
    "images": [
      "/img/nextflow-release-schema-01.png"
    ],
    "author": "Paolo Di Tommaso",
    "tags": "nextflow,gpl,apache,license"
  },
  {
    "slug": "2018/nextflow-meets-dockstore",
    "title": "Nextflow meets Dockstore",
    "date": "2018-09-18T00:00:00.000Z",
    "content": "<div class=\"text-muted\" style=\"margin-bottom:2em\">\n*This post is co-authored with Denis Yuen, lead of the Dockstore project at the Ontario Institute for Cancer Research*\n</div>\n\nOne key feature of Nextflow is the ability to automatically pull and execute a workflow application directly from a sharing platform such as GitHub. We realised this was critical to allow users to properly track code changes and releases and, above all, to enable the [seamless sharing of workflow projects](/blog/2016/best-practice-for-reproducibility.html).\n\nNextflow never wanted to implement its own centralised workflow registry because we thought that in order for a registry to be viable and therefore useful, it should be technology agnostic and it should be driven by a consensus among the wider user community.\n\nThis is exactly what the [Dockstore](https://dockstore.org/) project is designed for and for this reason we are thrilled to announce that Dockstore has just released the support for Nextflow workflows in its latest release!\n\n### Dockstore in a nutshell\n\nDockstore is an open platform that collects and catalogs scientific data analysis tools and workflows, starting from the genomics community. It’s developed by the [OICR](https://oicr.on.ca/) in collaboration with [UCSC](https://ucscgenomics.soe.ucsc.edu/) and it is based on the [GA4GH](https://www.ga4gh.org/) open standards and the FAIR principles i.e. the idea to make research data and applications findable, accessible, interoperable and reusable ([FAIR](https://www.nature.com/articles/sdata201618)).\n\n<img src=\"/img/dockstore.png\" alt=\"Dockstore logo\" style=\"float:right; width: 150pt; padding: .5em;\">\n\nIn Dockstore’s initial release of support for Nextflow, users will be able to register and display Nextflow workflows. Many of Dockstore’s cross-language features will be available such as [searching](https://dockstore.org/search?descriptorType=nfl&amp;searchMode=files), displaying metadata information on authorship from Nextflow’s config ([author and description](https://www.nextflow.io/docs/latest/config.html?highlight=author#scope-manifest)), displaying the [Docker images](https://dockstore.org/workflows/github.com/nf-core/hlatyping:1.1.1?tab=tools) used by a workflow, and limited support for displaying a visualization of the [workflow structure](https://dockstore.org/workflows/github.com/nf-core/hlatyping:1.1.1?tab=dag).\n\nThe Dockstore team will initially work to on-board the high-quality [nf-core](https://github.com/nf-core) workflows curated by the Nextflow community. However, all developers that develop Nextflow workflows will be able to login, contribute, and maintain workflows starting with our standard [workflow tutorials](https://docs.dockstore.org/docs/publisher-tutorials/workflows/).\n\nMoving forward, the Dockstore team hopes to engage more with the Nextflow community and integrate Nextflow code in order to streamline the process of publishing Nextflow workflows and draw better visualizations of Nextflow workflows. Dockstore also hopes to work with a cloud vendor to add browser based launch-with support for Nextflow workflows.\n\nFinally, support for Nextflow workflows in Dockstore will also enable the possibility of cloud platforms that implement [GA4GH WES](https://github.com/ga4gh/workflow-execution-service-schemas) to run Nextflow workflows.\n\n### Conclusion\n\nWe welcome the support for Nextflow workflows in the Dockstore platform. This is a valuable contribution and presents great opportunities for workflow developers and the wider scientific community.\n\nWe invite all Nextflow developers to register their data analysis applications in the Dockstore platform to make them accessible and reusable to a wider community of researchers.",
    "images": [
      "/img/dockstore.png"
    ],
    "author": "Paolo Di Tommaso",
    "tags": "nextflow,ga4gh,nf-core,dockstore"
  },
  {
    "slug": "2018/nextflow-turns-5",
    "title": "Nextflow turns five! Happy birthday!",
    "date": "2018-04-03T00:00:00.000Z",
    "content": "Nextflow is growing up. The past week marked five years since the [first commit](https://github.com/nextflow-io/nextflow/commit/c080150321e5000a2c891e477bb582df07b7f75f) of the project on GitHub. Like a parent reflecting on their child attending school for the first time, we know reaching this point hasn’t been an entirely solo journey, despite Paolo's best efforts!\n\nA lot has happened recently and we thought it was time to highlight some of the recent evolutions. We also take the opportunity to extend the warmest of thanks to all those who have contributed to the development of Nextflow as well as the fantastic community of users who consistently provide ideas, feedback and the occasional late night banter on the [Gitter channel](https://gitter.im/nextflow-io/nextflow).\n\nHere are a few neat developments churning out of the birthday cake mix.\n\n### nf-core\n\n[nf-core](https://nf-core.github.io/) is a community effort to provide a home for high quality, production-ready, curated analysis pipelines built using Nextflow. The project has been initiated and is being led by [Phil Ewels](https://github.com/ewels) of [MultiQC](http://multiqc.info/) fame. The principle is that _nf-core_ pipelines can be used out-of-the-box or as inspiration for something different.\n\nAs well as being a place for best-practise pipelines, other features of _nf-core_ include the [cookie cutter template tool](https://github.com/nf-core/cookiecutter) which provides a fast way to create a dependable workflow using many of Nextflow’s sweet capabilities such as:\n\n- _Outline:_ Skeleton pipeline script.\n- _Data:_ Reference Genome implementation (AWS iGenomes).\n- _Configuration:_ Robust configuration setup.\n- _Containers:_ Skeleton files for Docker image generation.\n- _Reporting:_ HTML email functionality and and HTML results output.\n- _Documentation:_ Installation, Usage, Output, Troubleshooting, etc.\n- _Continuous Integration:_ Skeleton files for automated testing using Travis CI.\n\nThere is also a Python package with helper tools for Nextflow.\n\nYou can find more information about the community via the project [website](https://nf-core.github.io), [GitHub repository](https://github.com/nf-core), [Twitter account](https://twitter.com/nf_core) or join the dedicated [Gitter](https://gitter.im/nf-core/Lobby) chat.\n\n<div class=\"row\"><div class=\"col-md-6 col-md-offset-3\">\n\n[![nf-core logo](/img/nf-core-logo-min.png)](https://nf-co.re)\n\n</div></div>\n\n### Kubernetes has landed\n\nAs of version 0.28.0 Nextflow now has support for Kubernetes. If you don’t know much about Kubernetes, at its heart it is an open-source platform for the management and deployment of containers at scale. Google led the initial design and it is now maintained by the Cloud Native Computing Foundation. I found the [The Illustrated Children's Guide to Kubernetes](https://www.youtube.com/watch?v=4ht22ReBjno) particularly useful in explaining the basic vocabulary and concepts.\n\nKubernetes looks be one of the key technologies for the application of containers in the cloud as well as for building Infrastructure as a Service (IaaS) and Platform and a Service (PaaS) applications. We have been approached by many users who wish to use Nextflow with Kubernetes to be able to deploy workflows across both academic and commercial settings. With enterprise versions of Kubernetes such as Red Hat's [OpenShift](https://www.openshift.com/), it was becoming apparent there was a need for native execution with Nextflow.\n\nThe new command `nextflow kuberun` launches the Nextflow driver as a _pod_ which is then able to run workflow tasks as other pods within a Kubernetes cluster. You can read more in the documentation on Kubernetes support for Nextflow [here](https://www.nextflow.io/docs/latest/kubernetes.html).\n\n![Nextflow and Kubernetes](/img/nextflow-kubernetes-min.png)\n\n### Improved reporting and notifications\n\nFollowing the hackathon in September we wrote about the addition of HTML trace reports that allow for the generation HTML detailing resource usage (CPU time, memory, disk i/o etc).\n\nThanks to valuable feedback there has continued to be many improvements to the reports as tracked through the Nextflow GitHub issues page. Reports are now able to display [thousands of tasks](https://github.com/nextflow-io/nextflow/issues/547) and include extra information such as the [container engine used](https://github.com/nextflow-io/nextflow/issues/521). Tasks can be filtered and an [overall progress bar](https://github.com/nextflow-io/nextflow/issues/534) has been added.\n\nYou can explore a [real-world HTML report](/misc/nf-trace-report2.html) and more information on HTML reports can be found in the [documentation](https://www.nextflow.io/docs/latest/tracing.html).\n\nThere has also been additions to workflow notifications. Currently these can be configured to automatically send a notification email when a workflow execution terminates. You can read more about how to setup notifications in the [documentation](https://www.nextflow.io/docs/latest/mail.html?highlight=notification#workflow-notification).\n\n### Syntax-tic!\n\nWriting workflows no longer has to be done in monochrome. There is now syntax highlighting for Nextflow in the popular [Atom editor](https://atom.io) as well as in [Visual Studio Code](https://code.visualstudio.com).\n\n<div class=\"row\"><div class=\"col-md-6\">\n\n[![Nextflow syntax highlighting with Atom](/img/atom-min.png)](/img/atom-min.png)\n\n</div><div class=\"col-md-6\">\n\n[![Nextflow syntax highlighting with VSCode](/img/vscode-min.png)](/img/vscode-min.png)\n\n</div></div>\n\nYou can find the Atom plugin by searching for Nextflow in Atoms package installer or clicking [here](https://atom.io/packages/language-nextflow). The Visual Studio plugin can be downloaded [here](https://marketplace.visualstudio.com/items?itemName=nextflow.nextflow).\n\nOn a related note, Nextflow is now an official language on GitHub!\n\n![GitHub nextflow syntax](/img/github-nf-syntax-min.png)\n\n### Conclusion\n\nNextflow developments are progressing faster than ever and with the help of the community, there are a ton of great new features on the way. If you have any suggestions of your killer NF idea then please drop us a line, open an issue or even better, join in the fun.\n\nOver the coming months Nextflow will be reaching out with several training and presentation sessions across the US and Europe. We hope to see as many of you as possible on the road.",
    "images": [],
    "author": "Evan Floden",
    "tags": "nextflow,kubernetes,nf-core"
  },
  {
    "slug": "2019/demystifying-nextflow-resume",
    "title": "Demystifying Nextflow resume",
    "date": "2019-06-24T00:00:00.000Z",
    "content": "_This two-part blog aims to help users understand Nextflow’s powerful caching mechanism. Part one describes how it works whilst part two will focus on execution provenance and troubleshooting. You can read part two [here](/blog/2019/troubleshooting-nextflow-resume.html)_\n\nTask execution caching and checkpointing is an essential feature of any modern workflow manager and Nextflow provides an automated caching mechanism with every workflow execution. When using the `-resume` flag, successfully completed tasks are skipped and the previously cached results are used in downstream tasks. But understanding the specifics of how it works and debugging situations when the behaviour is not as expected is a common source of frustration.\n\nThe mechanism works by assigning a unique ID to each task. This unique ID is used to create a separate execution directory, called the working directory, where the tasks are executed and the results stored. A task’s unique ID is generated as a 128-bit hash number obtained from a composition of the task’s:\n\n- Inputs values\n- Input files\n- Command line string\n- Container ID\n- Conda environment\n- Environment modules\n- Any executed scripts in the bin directory\n\n### How does resume work?\n\nThe `-resume` command line option allows for the continuation of a workflow execution. It can be used in its most basic form with:\n\n```\n$ nextflow run nextflow-io/hello -resume\n```\n\nIn practice, every execution starts from the beginning. However, when using resume, before launching a task, Nextflow uses the unique ID to check if:\n\n- the working directory exists\n- it contains a valid command exit status\n- it contains the expected output files.\n\nIf these conditions are satisfied, the task execution is skipped and the previously computed outputs are applied. When a task requires recomputation, ie. the conditions above are not fulfilled, the downstream tasks are automatically invalidated.\n\n### The working directory\n\nBy default, the task work directories are created in the directory from where the pipeline is launched. This is often a scratch storage area that can be cleaned up once the computation is completed. A different location for the execution work directory can be specified using the command line option `-w` e.g.\n\n```\n$ nextflow run <script> -w /some/scratch/dir\n```\n\nNote that if you delete or move the pipeline work directory, this will prevent to use the resume feature in subsequent runs.\n\nAlso note that the pipeline work directory is intended to be used as a temporary scratch area. The final\nworkflow outputs are expected to be stored in a different location specified using the [`publishDir` directive](https://www.nextflow.io/docs/latest/process.html#publishdir).\n\n### How is the hash calculated on input files?\n\nThe hash provides a convenient way for Nextflow to determine if a task requires recomputation. For each input file, the hash code is computed with:\n\n- The complete file path\n- The file size\n- The last modified timestamp\n\nTherefore, even just performing a touch on a file will invalidate the task execution.\n\n### How to ensure resume works as expected?\n\nIt is good practice to organize each experiment in its own folder. An experiment’s input parameters can be specified using a Nextflow config file which also makes it simple to track and replicate an experiment over time. Note that you should avoid launching two (or more) Nextflow instances in the same directory concurrently.\n\nThe nextflow log command lists the executions run in the current folder:\n\n<style>\npre {\n    white-space: pre;\n    overflow-x: auto;\n}\n</style>\n<pre>\n$ nextflow log\n\nTIMESTAMP            DURATION  RUN NAME          STATUS  REVISION ID  SESSION ID                            COMMAND\n2019-05-06 12:07:32  1.2s      focused_carson    ERR     a9012339ce   7363b3f0-09ac-495b-a947-28cf430d0b85  nextflow run hello\n2019-05-06 12:08:33  21.1s     mighty_boyd       OK      a9012339ce   7363b3f0-09ac-495b-a947-28cf430d0b85  nextflow run rnaseq-nf -with-docker\n2019-05-06 12:31:15  1.2s      insane_celsius    ERR     b9aefc67b4   4dc656d2-c410-44c8-bc32-7dd0ea87bebf  nextflow run rnaseq-nf\n2019-05-06 12:31:24  17s       stupefied_euclid  OK      b9aefc67b4   4dc656d2-c410-44c8-bc32-7dd0ea87bebf  nextflow run rnaseq-nf -resume -with-docker\n</pre>\n\nYou can use the resume command with the session ID to recover a specific execution. For example:\n\n```\nnextflow run naseq-nf -resume 4dc656d2-c410-44c8-bc32-7dd0ea87bebf\n```\n\n_Stay tuned for part two where we will discuss resume in more detail with respect to provenance and troubleshooting techniques!_\n</div></script>",
    "images": [],
    "author": "Evan Floden",
    "tags": "nextflow,resume"
  },
  {
    "slug": "2019/easy-provenance-report",
    "title": "Easy provenance reporting",
    "date": "2019-08-29T00:00:00.000Z",
    "content": "_Continuing our [series on understanding Nextflow resume](blog/2019/demystifying-nextflow-resume.html), we wanted to delve deeper to show how you can report which tasks contribute to a given workflow output._\n\n### Easy provenance reports\n\nWhen provided with a run name or session ID, the log command can return useful information about a pipeline execution. This can be composed to track the provenance of a workflow result.\n\nWhen supplying a run name or session ID, the log command lists all the work directories used to compute the final result. For example:\n\n```\n$ nextflow log tiny_fermat\n\n/data/.../work/7b/3753ff13b1fa5348d2d9b6f512153a\n/data/.../work/c1/56a36d8f498c99ac6cba31e85b3e0c\n/data/.../work/f7/659c65ef60582d9713252bcfbcc310\n/data/.../work/82/ba67e3175bd9e6479d4310e5a92f99\n/data/.../work/e5/2816b9d4e7b402bfdd6597c2c2403d\n/data/.../work/3b/3485d00b0115f89e4c202eacf82eba\n```\n\nUsing the option `-f` (fields) it’s possible to specify which metadata should be printed by the log command. For example:\n\n```\n$ nextflow log tiny_fermat -f 'process,exit,hash,duration'\n\nindex\t0\t7b/3753ff\t2s\nfastqc\t0\tc1/56a36d\t9.3s\nfastqc\t0\tf7/659c65\t9.1s\nquant\t0\t82/ba67e3\t2.7s\nquant\t0\te5/2816b9\t3.2s\nmultiqc\t0\t3b/3485d0\t6.3s\n```\n\nThe complete list of available fields can be retrieved with the command:\n\n```\n$ nextflow log -l\n```\n\nThe option `-F` allows the specification of filtering criteria to print only a subset of tasks. For example:\n\n```\n$ nextflow log tiny_fermat -F 'process =~ /fastqc/'\n\n/data/.../work/c1/56a36d8f498c99ac6cba31e85b3e0c\n/data/.../work/f7/659c65ef60582d9713252bcfbcc310\n```\n\nThis can be useful to locate specific tasks work directories.\n\nFinally, the `-t` option allows for the creation of a basic custom HTML provenance report that can be generated by providing a template file, in any format of your choice. For example:\n\n```\n<div>\n<h2>${name}</h2>\n<div>\nScript:\n<pre>${script}</pre>\n</div>\n\n- Exit: ${exit}\n- Status: ${status}\n- Work dir: ${workdir}\n- Container: ${container}\n\n</div>\n```\n\nBy saving the above snippet in a file named template.html, you can run the following command:\n\n```\n$ nextflow log tiny_fermat -t template.html &gt; provenance.html\n```\n\nOpen it in your browser, et voilà!\n\n## Conclusion\n\nThis post introduces a little know Nextflow feature and it's intended to show how it can be used\nto produce a custom execution report reporting some - basic - provenance information.\n\nIn future releases we plan to support a more formal provenance specification and execution tracking features.",
    "images": [],
    "author": "Evan Floden",
    "tags": "nextflow,resume"
  },
  {
    "slug": "2019/one-more-step-towards-modules",
    "title": "One more step towards Nextflow modules",
    "date": "2019-05-22T00:00:00.000Z",
    "content": "The ability to create components, libraries or module files has been\namong the most requested feature ever over the years.\n\nFor this reason, today we are very happy to announce that a preview implementation\nof the [modules feature](https://github.com/nextflow-io/nextflow/issues/984) has been merged\non master branch of the project and included in the\n[19.05.0-edge](https://github.com/nextflow-io/nextflow/releases/tag/v19.05.0-edge) release.\n\nThe implementation of this feature has opened the possibility for many fantastic improvements to Nextflow and its syntax. We are extremely excited as it results in a radical new way of writing Nextflow applications! So much so, that we are referring to these changes as DSL 2.\n\n#### Enabling DSL 2 syntax\n\nSince this is still a preview technology and, above all, to not break\nany existing applications, to enable the new syntax you will need to add\nthe following line at the beginning of your workflow script:\n\n```\nnextflow.preview.dsl=2\n```\n\n#### Module files\n\nA module file simply consists of one or more `process` definitions, written with the usual syntax. The _only_ difference is that the `from` and `into` clauses in the `input:` and `output:` definition blocks has to be omitted. For example:\n\n```\nprocess INDEX {\n  input:\n    file transcriptome\n  output:\n    file 'index'\n  script:\n    \"\"\"\n    salmon index --threads $task.cpus -t $transcriptome -i index\n    \"\"\"\n}\n```\n\nThe above snippet defines a process component that can be imported in the main\napplication script using the `include` statement shown below.\n\nAlso, module files can declare optional parameters using the usual `params` idiom,\nas it can be done in any standard script file.\n\nThis approach, which is consistent with the current Nextflow syntax, makes very easy to migrate existing code to the new modules system, reducing it to a mere copy &amp; pasting exercise in most cases.\n\nYou can see a complete module file [here](https://github.com/nextflow-io/rnaseq-nf/blob/66ebeea/modules/rnaseq.nf).\n\n### Module inclusion\n\nA module file can be included into a Nextflow script using the `include` statement.\nWith this it becomes possible to reference any process defined in the module using the usual syntax for a function invocation, and specifying the expected input channels as they were function arguments.\n\n```\nnextflow.preview.dsl=2\ninclude 'modules/rnaseq'\n\nread_pairs_ch = Channel.fromFilePairs( params.reads, checkIfExists: true )\ntranscriptome_file = file( params.transcriptome )\n\nINDEX( transcriptome_file )\nFASTQC( read_pairs_ch )\nQUANT( INDEX.out, read_pairs_ch )\nMULTIQC( QUANT.out.mix(FASTQC.out).collect(), multiqc_file )\n```\n\nNotably, each process defines its own namespace in the script scope which allows the access of the process output channel(s) using the `.out` attribute. This can be used then as any other Nextflow channel variable in your pipeline script.\n\nThe `include` statement gives also the possibility to include only a [specific process](https://www.nextflow.io/docs/edge/dsl2.html#selective-inclusion)\nor to include a process with a different [name alias](https://www.nextflow.io/docs/edge/dsl2.html#module-aliases).\n\n### Smart channel forking\n\nOne of the most important changes of the new syntax is that any channel can be read as many\ntimes as you need removing the requirement to duplicate them using the `into` operator.\n\nFor example, in the above snippet, the `read_pairs_ch` channel has been used twice, as input both for the `FASTQC` and `QUANT` processes. Nextflow forks it behind the scene for you.\n\nThis makes the writing of workflow scripts much more fluent, readable and ... fun! No more channel names proliferation!\n\n### Nextflow pipes!\n\nFinally, maybe our favourite one. The new DSL introduces the `|` (pipe) operator which allows for the composition\nof Nextflow channels, processes and operators together seamlessly in a much more expressive way.\n\nConsider the following example:\n\n```\nprocess align {\n  input:\n    file seq\n  output:\n    file 'result'\n\n  \"\"\"\n    t_coffee -in=${seq} -out result\n  \"\"\"\n}\n\nChannel.fromPath(params.in) | splitFasta | align | view { it.text }\n```\n\nIn the last line, the `fromPath` channel is piped to the [`splitFasta`](https://www.nextflow.io/docs/latest/operator.html#splitfasta) operator whose result is used as input by\nthe `align` process. Then the output is finally printed by the [`view`](https://www.nextflow.io/docs/latest/operator.html#view)\noperator.\n\nThis syntax finally realizes the Nextflow vision of empowering developers to write\ncomplex data analysis applications with a simple but powerful language that mimics\nthe expressiveness of the Unix pipe model but at the same time makes it possible to\nhandle complex data structures and patterns as is required for highly\nparallelised and distributed computational workflows.\n\n#### Conclusion\n\nThis wave of improvements brings a radically new experience when it comes to\nwriting Nextflow workflows. We are releasing it as a preview technology to allow\nusers to try, test, provide their feedback and give us the possibility\nstabilise it.\n\nWe are also working to other important enhancements that will be included soon,\nsuch as remote modules, sub-workflows composition, simplified file path\nwrangling and more. Stay tuned!",
    "images": [],
    "author": "Paolo Di Tommaso",
    "tags": "nextflow,release,modules,dsl2"
  },
  {
    "slug": "2019/release-19.03.0-edge",
    "title": "Edge release 19.03: The Sequence Read Archive & more!",
    "date": "2019-03-19T00:00:00.000Z",
    "content": "It's time for the monthly Nextflow release for March, _edge_ version 19.03. This is another great release with some cool new features, bug fixes and improvements.\n\n### SRA channel factory\n\nThis sees the introduction of the long-awaited sequence read archive (SRA) channel factory.\nThe [SRA](https://www.ncbi.nlm.nih.gov/sra) is a key public repository for sequencing data and run in coordination between The National Center for\nBiotechnology Information (NCBI), The European Bioinformatics Institute (EBI) and the DNA Data Bank of Japan (DDBJ).\n\nThis feature originates all the way back in [2015](https://github.com/nextflow-io/nextflow/issues/89) and was worked on during a 2018 Nextflow hackathon. It was brought to fore again thanks to the release of Phil Ewels' excellent [SRA Explorer](https://ewels.github.io/sra-explorer/). The SRA channel factory allows users to pull read data in FASTQ format directly from SRA by referencing a study, accession ID or even a keyword. It works in a similar way to [`fromFilePairs`](https://www.nextflow.io/docs/latest/channel.html#fromfilepairs), returning a sample ID and files (single or pairs of files) for each sample.\n\nThe code snippet below creates a channel containing 24 samples from a chromatin dynamics study and runs FASTQC on the resulting files.\n\n```\nChannel\n    .fromSRA('SRP043510')\n    .set{reads}\n\nprocess fastqc {\n    input:\n    set sample_id, file(reads_file) from reads\n\n    output:\n    file(\"fastqc_${sample_id}_logs\") into fastqc_ch\n\n    script:\n    \"\"\"\n    mkdir fastqc_${sample_id}_logs\n    fastqc -o fastqc_${sample_id}_logs -f fastq -q ${reads_file}\n    \"\"\"\n}\n```\n\nSee the [documentation](https://www.nextflow.io/docs/edge/channel.html#fromsra) for more details. When combined with downstream processes, you can quickly open a firehose of data on your workflow!\n\n### Edge release\n\nNote that this is a monthly edge release. To use it simply execute the following command prior to running Nextflow:\n\n```\nexport NXF_VER=19.03.0-edge\n```\n\n### If you need help\n\nPlease don’t hesitate to use our very active [Gitter](https://gitter.im/nextflow-io/nextflow) channel or create a thread in the [Google discussion group](https://groups.google.com/forum/#!forum/nextflow).\n\n### Reporting Issues\n\nExperiencing issues introduced by this release? Please report them in our [issue tracker](https://github.com/nextflow-io/nextflow/issues). Make sure to fill in the fields of the issue template.\n\n### Contributions\n\nSpecial thanks to the contributors of this release:\n\n- Akira Sekiguchi - [pachiras](https://github.com/pachiras)\n- Jon Haitz Legarreta Gorroño - [jhlegarreta](https://github.com/jhlegarreta)\n- Jonathan Leitschuh - [JLLeitschuh](https://github.com/JLLeitschuh)\n- Kevin Sayers - [KevinSayers](https://github.com/KevinSayers)\n- Lukas Jelonek - [lukasjelonek](https://github.com/lukasjelonek)\n- Paolo Di Tommaso - [pditommaso](https://github.com/pditommaso)\n- Toni Hermoso Pulido - [toniher](https://github.com/toniher)\n- Philippe Hupé [phupe](https://github.com/phupe)\n- [phue](https://github.com/phue)\n\n### Complete changes\n\n- Fix Nextflow hangs submitting jobs to AWS batch #1024\n- Fix process builder incomplete output [2fe1052c]\n- Fix Grid executor reports invalid queue status #1045\n- Fix Script execute permission is lost in container #1060\n- Fix K8s serviceAccount is not honoured #1049\n- Fix K8s kuberun login path #1072\n- Fix K8s imagePullSecret and imagePullPolicy #1062\n- Fix Google Storage docs #1023\n- Fix Env variable NXF_CONDA_CACHEDIR is ignored #1051\n- Fix failing task due to legacy sleep command [3e150b56]\n- Fix SplitText operator should accept a closure parameter #1021\n- Add Channel.fromSRA factory method #1070\n- Add voluntary/involuntary context switches to metrics #1047\n- Add noHttps option to singularity config #1041\n- Add docker-daemon Singularity support #1043 [dfef1391]\n- Use peak_vmem and peak_rss as default output in the trace file instead of rss and vmem #1020\n- Improve ansi log rendering #996 [33038a18]\n\n### Breaking changes:\n\nNone known.",
    "images": [],
    "author": "Evan Floden",
    "tags": "nextflow,release"
  },
  {
    "slug": "2019/release-19.04.0-stable",
    "title": "Nextflow 19.04.0 stable release is out!",
    "date": "2019-04-18T00:00:00.000Z",
    "content": "We are excited to announce the new Nextflow 19.04.0 stable release!\n\nThis version includes numerous bug fixes, enhancement and new features.\n\n#### Rich logging\n\nIn this release, we are making the new interactive rich output using ANSI escape characters as the default logging option. This produces a much more readable and easy to follow log of the running workflow execution.\n\n<script type=\"text/javascript\" src=\"https://asciinema.org/a/IrT6uo85yyVoOjPa6KVzT2FXQ.js\" id=\"asciicast-IrT6uo85yyVoOjPa6KVzT2FXQ\" async=\"\"></script>\n\nThe ANSI log is implicitly disabled when the nextflow is launched in the background i.e. when using the `-bg` option. It can also be explicitly disabled using the `-ansi-log false` option or setting the `NXF_ANSI_LOG=false` variable in your launching environment.\n\n#### NCBI SRA data source\n\nThe support for NCBI SRA archive was introduced in the [previous edge release](/blog/2019/release-19.03.0-edge.html). Given the very positive reaction, we are graduating this feature into the stable release for general availability.\n\n#### Sharing\n\nThis version includes also a new Git repository provider for the [Gitea](https://gitea.io) self-hosted source code management system, which is added to the already existing support for GitHub, Bitbucket and GitLab sharing platforms.\n\n#### Reports and metrics\n\nFinally, this version includes important enhancements and bug fixes for the task executions metrics collected by Nextflow. If you are using this feature we strongly suggest updating Nextflow to this version.\n\nRemember that updating can be done with the `nextflow -self-update` command.\n\n### Changelog\n\nThe complete list of changes and bug fixes is available on GitHub at [this link](https://github.com/nextflow-io/nextflow/releases/tag/v19.04.0).\n\n### Contributions\n\nSpecial thanks to all people contributed to this release by reporting issues, improving the docs or submitting (patiently) a pull request (sorry if we have missed somebody):\n\n- [Alex Cerjanic](https://github.com/acerjanic)\n- [Anthony Underwood](https://github.com/aunderwo)\n- [Akira Sekiguchi](https://github.com/pachiras)\n- [Bill Flynn](https://github.com/wflynny)\n- [Jorrit Boekel](https://github.com/glormph)\n- [Olga Botvinnik](https://github.com/olgabot)\n- [Ólafur Haukur Flygenring](https://github.com/olifly)\n- [Sven Fillinger](https://github.com/sven1103)",
    "images": [],
    "author": "Paolo Di Tommaso",
    "tags": "nextflow,release,stable"
  },
  {
    "slug": "2019/troubleshooting-nextflow-resume",
    "title": "Troubleshooting Nextflow resume",
    "date": "2019-07-01T00:00:00.000Z",
    "content": "_This two-part blog aims to help users understand Nextflow’s powerful caching mechanism. Part one describes how it works whilst part two will focus on execution provenance and troubleshooting. You can read part one [here](/blog/2019/demystifying-nextflow-resume.html)_.\n\n### Troubleshooting resume\n\nIf your workflow execution is not resumed as expected, there exists several strategies to debug the problem.\n\n#### Modified input file(s)\n\nMake sure that there has been no change in your input files. Don’t forget the unique task hash is computed by taking into account the complete file path, the last modified timestamp and the file size. If any of these change, the workflow will be re-executed, even if the input content is the same.\n\n#### A process modifying one or more inputs\n\nA process should never alter input files. When this happens, the future execution of tasks will be invalidated for the same reason explained in the previous point.\n\n#### Inconsistent input file attributes\n\nSome shared file system, such as NFS, may report inconsistent file timestamp i.e. a different timestamp for the same file even if it has not been modified. There is an option to use the [lenient mode of caching](https://www.nextflow.io/docs/latest/process.html#cache) to avoid this problem.\n\n#### Race condition in a global variable\n\nNextflow does its best to simplify parallel programming and to prevent race conditions and the access of shared resources. One of the few cases in which a race condition may arise is when using a global variable with two (or more) operators. For example:\n\n```\nChannel\n    .from(1,2,3)\n    .map { it -&gt; X=it; X+=2 }\n    .println { \"ch1 = $it\" }\n\nChannel\n    .from(1,2,3)\n    .map { it -&gt; X=it; X*=2 }\n    .println { \"ch2 = $it\" }\n```\n\nThe problem with this snippet is that the `X` variable in the closure definition is defined in the global scope. Since operators are executed in parallel, the `X` value can, therefore, be overwritten by the other `map` invocation.\n\nThe correct implementation requires the use of the `def` keyword to declare the variable local.\n\n```\nChannel\n    .from(1,2,3)\n    .map { it -&gt; def X=it; X+=2 }\n    .view { \"ch1 = $it\" }\n\nChannel\n    .from(1,2,3)\n    .map { it -&gt; def X=it; X*=2 }\n    .view { \"ch2 = $it\" }\n```\n\n#### Non-deterministic input channels\n\nWhile dataflow channel ordering is guaranteed i.e. data is read in the same order in which it’s written in the channel, when a process declares as input two or more channels, each of which is the output of a different process, the overall input ordering is not consistent across different executions.\n\nConsider the following snippet:\n\n```\nprocess foo {\n  input: set val(pair), file(reads) from reads_ch\n  output: set val(pair), file('*.bam') into bam_ch\n  \"\"\"\n  your_command --here\n  \"\"\"\n}\n\nprocess bar {\n  input: set val(pair), file(reads) from reads_ch\n  output: set val(pair), file('*.bai') into bai_ch\n  \"\"\"\n  other_command --here\n  \"\"\"\n}\n\nprocess gather {\n  input:\n  set val(pair), file(bam) from bam_ch\n  set val(pair), file(bai) from bai_ch\n  \"\"\"\n  merge_command $bam $bai\n  \"\"\"\n}\n```\n\nThe inputs declared in the gather process can be delivered in any order as the execution order of the process `foo` and `bar` is not deterministic due to parallel executions.\n\nTherefore, the input of the third process needs to be synchronized using the `join` operator or a similar approach. The third process should be written as:\n\n```\nprocess gather {\n  input:\n  set val(pair), file(bam), file(bai) from bam_ch.join(bai_ch)\n  \"\"\"\n  merge_command $bam $bai\n  \"\"\"\n}\n```\n\n#### Still in trouble?\n\nThese are most frequent causes of problems with the Nextflow resume mechanism. If you are still not able to resolve\nyour problem, identify the first process not resuming correctly, then run your script twice using `-dump-hashes`. You can then compare the resulting `.nextflow.log` files (the first will be named `.nextflow.log.1`).\n\nUnfortunately, the information reported by `-dump-hashes` can be quite cryptic, however, with the help of a good _diff_ tool it is possible to compare the two log files to identify the reason for the cache to be invalidated.\n\n#### The golden rule\n\nNever try to debug this kind of problem with production data! This issue can be annoying, but when it happens\nit should be able to be replicated in a consistent manner with any data.\n\nTherefore, we always suggest Nextflow developers include in their pipeline project\na small synthetic dataset to easily execute and test the complete pipeline execution in a few seconds.\nThis is the golden rule for debugging and troubleshooting execution problems avoids getting stuck with production data.\n\n#### Resume by default?\n\nGiven the majority of users always apply resume, we recently discussed having resume applied by the default.\n\nIs there any situation where you do not use resume? Would a flag specifying `-no-cache` be enough to satisfy these use cases?\n\nWe want to hear your thoughts on this. Help steer Nextflow development and vote in the twitter poll below.\n\n&gt; Should -resume⏯️ be the default when launching a Nextflow pipeline?\n&gt; \n&gt; — Nextflow (@nextflowio) [July 1, 2019](https://twitter.com/nextflowio/status/1145599932268785665?ref_src=twsrc%5Etfw)\n\n<script async=\"\" src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\n<br>\n*In the following post of this series, we will show how to produce a provenance report using a built-in Nextflow command.*",
    "images": [],
    "author": "Evan Floden",
    "tags": "nextflow,resume"
  },
  {
    "slug": "2020/cli-docs-release",
    "title": "The Nextflow CLI - tricks and treats!",
    "date": "2020-10-22T00:00:00.000Z",
    "content": "For most developers, the command line is synonymous with agility. While tools such as [Nextflow Tower](https://tower.nf) are opening up the ecosystem to a whole new set of users, the Nextflow CLI remains a bedrock for pipeline development. The CLI in Nextflow has been the core interface since the beginning; however, its full functionality was never extensively documented. Today we are excited to release the first iteration of the CLI documentation available on the [Nextflow website](https://www.nextflow.io/docs/edge/cli.html).\n\nAnd given Halloween is just around the corner, in this blog post we'll take a look at 5 CLI tricks and examples which will make your life easier in designing, executing and debugging data pipelines. We are also giving away 5 limited-edition Nextflow hoodies and sticker packs so you can code in style this Halloween season!\n\n### 1. Invoke a remote pipeline execution with the latest revision\n\nNextflow facilitates easy collaboration and re-use of existing pipelines in multiple ways. One of the simplest ways to do this is to use the URL of the Git repository.\n\n```\n$ nextflow run https://www.github.com/nextflow-io/hello\n```\n\nWhen executing a pipeline using the run command, it first checks to see if it has been previously downloaded in the ~/.nextflow/assets directory, and if so, Nextflow uses this to execute the pipeline. If the pipeline is not already cached, Nextflow will download it, store it in the `$HOME/.nextflow/` directory and then launch the execution.\n\nHow can we make sure that we always run the latest code from the remote pipeline? We simply need to add the `-latest` option to the run command, and Nextflow takes care of the rest.\n\n```\n$ nextflow run nextflow-io/hello -latest\n```\n\n### 2. Query work directories for a specific execution\n\nFor every invocation of Nextflow, all the metadata about an execution is stored including task directories, completion status and time etc. We can use the `nextflow log` command to generate a summary of this information for a specific run.\n\nTo see a list of work directories associated with a particular execution (for example, `tiny_leavitt`), use:\n\n```\n$ nextflow log tiny_leavitt\n```\n\nTo filter out specific process-level information from the logs of any execution, we simply need to use the fields (-f) option and specify the fields.\n\n```\n$ nextflow log tiny_leavitt –f 'process, hash, status, duration'\n```\n\nThe hash is the name of the work directory where the process was executed; therefore, the location of a process work directory would be something like `work/74/68ff183`.\n\nThe log command also has other child options including `-before` and `-after` to help with the chronological inspection of logs.\n\n### 3. Top-level configuration\n\nNextflow emphasizes customization of pipelines and exposes multiple options to facilitate this. The configuration is applied to multiple Nextflow commands and is therefore a top-level option. In practice, this means specifying configuration options _before_ the command.\n\nNextflow CLI provides two kinds of config overrides - the soft override and the hard override.\n\nThe top-level soft override \"-c\" option allows us to change the previous config in an additive manner, overriding only the fields included the configuration file.\n\n```\n$ nextflow -c my.config run nextflow-io/hello\n```\n\nOn the other hand, the hard override `-C` completely replaces and ignores any additional configurations.\n\n    $ nextflow –C my.config nextflow-io/hello\n\nMoreover, we can also use the config command to inspect the final inferred configuration and view any profiles.\n\n```\n$ nextflow config -show-profiles\n```\n\n### 4. Passing in an input parameter file\n\nNextflow is designed to work across both research and production settings. In production especially, specifying multiple parameters for the pipeline on the command line becomes cumbersome. In these cases, environment variables or config files are commonly used which contain all input files, options and metadata. Love them or hate them, YAML and JSON are the standard formats for human and machines, respectively.\n\nThe Nextflow run option `-params-file` can be used to pass in a file containing parameters in either format.\n\n```\n$ nextflow run nextflow-io/rnaseq -params-file run_42.yaml\n```\n\nThe YAML file could contain the following.\n\n```\nreads      : \"s3://gatk-data/run_42/reads/*_R{1,2}_*.fastq.gz\"\nbwa_index  : \"$baseDir/index/*.bwa-index.tar.gz\"\npaired_end : true\npenalty    : 12\n```\n\n### 5. Specific workflow entry points\n\nThe recently released [DSL2](https://www.nextflow.io/blog/2020/dsl2-is-here.html) adds powerful modularity to Nextflow and enables scripts to contain multiple workflows. By default, the unnamed workflow is assumed to be the main entry point for the script, however, with numerous named workflows, the entry point can be customized by using the `entry` child-option of the run command.\n\n    $ nextflow run main.nf -entry workflow1\n\nThis allows users to run a specific sub-workflow or a section of their entire workflow script. For more information, refer to the [implicit workflow](https://www.nextflow.io/docs/latest/dsl2.html#implicit-workflow) section of the documentation.\n\nAdditionally, as of version 20.09.1-edge, you can specify the script in a project to run other than `main.nf` using the command line option\n`-main-script`.\n\n    $ nextflow run http://github.com/my/pipeline -main-script my-analysis.nf\n\n### Bonus trick! Web dashboard launched from the CLI\n\nThe tricks above highlight the functionality of the Nextflow CLI. However, for long-running workflows, monitoring becomes all the more crucial. With Nextflow Tower, we can invoke any Nextflow pipeline execution from the CLI and use the integrated dashboard to follow the workflow execution wherever we are. Sign-in to [Tower](https://tower.nf) using your GitHub credentials, obtain your token from the Getting Started page and export them into your terminal, `~/.bashrc` or include them in your `nextflow.config`.\n\n```\n$ export TOWER_ACCESS_TOKEN=my-secret-tower-key\n$ export NXF_VER=20.07.1\n```\n\nNext simply add the \"-with-tower\" child-option to any Nextflow run command. A URL with the monitoring dashboard will appear.\n\n```\n$ nextflow run nextflow-io/hello -with-tower\n```\n\n### Nextflow Giveaway\n\nIf you want to look stylish while you put the above tips into practice, or simply like free stuff, we are giving away five of our latest Nextflow hoodie and sticker packs. Retweet or like the Nextflow tweet about this article and we will draw and notify the winners on October 31st!\n\n### About the Author\n\n[Abhinav Sharma](https://www.linkedin.com/in/abhi18av/) is a Bioinformatics Engineer at [Seqera Labs](https://www.seqera.io) interested in Data Science and Cloud Engineering. He enjoys working on all things Genomics, Bioinformatics and Nextflow.\n\n### Acknowledgements\n\nShout out to [Kevin Sayers](https://github.com/KevinSayers) and [Alexander Peltzer](https://github.com/apeltzer) for their earlier efforts in documenting the CLI and which inspired this work.\n\n_The latest CLI docs can be found in the edge release docs at [https://www.nextflow.io/docs/latest/cli.html](https://www.nextflow.io/docs/latest/cli.html)._",
    "images": [],
    "author": "Abhinav Sharma",
    "tags": "nextflow,docs"
  },
  {
    "slug": "2020/dsl2-is-here",
    "title": "Nextflow DSL 2 is here!",
    "date": "2020-07-24T00:00:00.000Z",
    "content": "We are thrilled to announce the stable release of Nextflow DSL 2 as part of the latest 20.07.1 version!\n\nNextflow DSL 2 represents a major evolution of the Nextflow language and makes it possible to scale and modularise your data analysis pipeline while continuing to use the Dataflow programming paradigm that characterises the Nextflow processing model.\n\nWe spent more than one year collecting user feedback and making sure that DSL 2 would naturally fit the programming experience Nextflow developers are used to.\n\n#### DLS 2 in a nutshell\n\nBackward compatibility is a paramount value, for this reason the changes introduced in the syntax have been minimal and above all, guarantee the support of all existing applications. DSL 2 will be an opt-in feature for at least the next 12 to 18 months. After this transitory period, we plan to make it the default Nextflow execution mode.\n\nAs of today, to use DSL 2 in your Nextflow pipeline, you are required to use the following declaration at the top of your script:\n\n```\nnextflow.enable.dsl=2\n```\n\nNote that the previous `nextflow.preview` directive is still available, however, when using the above declaration the use of the final syntax is enforced.\n\n#### Nextflow modules\n\nA module file is nothing more than a Nextflow script containing one or more `process` definitions that can be imported from another Nextflow script.\n\nThe only difference when compared with legacy syntax is that the process is not bound with specific input and output channels, as was previously required using the `from` and `into` keywords respectively. Consider this example of the new syntax:\n\n```\nprocess INDEX {\n  input:\n    path transcriptome\n  output:\n    path 'index'\n  script:\n    \"\"\"\n    salmon index --threads $task.cpus -t $transcriptome -i index\n    \"\"\"\n}\n```\n\nThis allows the definition of workflow processes that can be included from any other script and invoked as a custom function within the new `workflow` scope. This effectively allows for the composition of the pipeline logic and enables reuse of workflow components. We anticipate this to improve both the speed that users can develop new pipelines, and the robustness of these pipelines through the use of validated modules.\n\nAny process input can be provided as a function argument using the usual channel semantics familiar to Nextflow developers. Moreover process outputs can either be assigned to a variable or accessed using the implicit `.out` attribute in the scope implicitly defined by the process name itself. See the example below:\n\n```\ninclude { INDEX; FASTQC; QUANT; MULTIQC } from './some/module/script.nf'\n\nread_pairs_ch = channel.fromFilePairs( params.reads)\n\nworkflow {\n  INDEX( params.transcriptome )\n  FASTQC( read_pairs_ch )\n  QUANT( INDEX.out, read_pairs_ch )\n  MULTIQC( QUANT.out.mix(FASTQC.out).collect(), multiqc_file )\n}\n```\n\nAlso enhanced is the ability to use channels as inputs multiple times without the need to duplicate them (previously done with the special into operator) which makes the resulting pipeline code more concise, fluent and therefore readable!\n\n#### Sub-workflows\n\nNotably, the DSL 2 syntax allows for the definition of reusable processes as well as sub-workflow libraries. The only requirement is to provide a `workflow` name that will be used to reference and declare the corresponding inputs and outputs using the new `take` and `emit` keywords. For example:\n\n```\nworkflow RNASEQ {\n  take:\n    transcriptome\n    read_pairs_ch\n\n  main:\n    INDEX(transcriptome)\n    FASTQC(read_pairs_ch)\n    QUANT(INDEX.out, read_pairs_ch)\n\n  emit:\n     QUANT.out.mix(FASTQC.out).collect()\n}\n```\n\nNow named sub-workflows can be used in the same way as processes, allowing you to easily include and reuse multi-step workflows as part of larger workflows. Find more details [here](/docs/latest/dsl2.html).\n\n#### More syntax sugar\n\nAnother exciting feature of Nextflow DSL 2 is the ability to compose built-in operators, pipeline processes and sub-workflows with the pipe (|) operator! For example the last line in the above example could be written as:\n\n```\nemit:\n QUANT.out | mix(FASTQC.out) | collect\n```\n\nThis syntax finally realizes the Nextflow vision of empowering developers to write complex data analysis applications with a simple but powerful language that mimics the expressiveness of the Unix pipe model but at the same time makes it possible to handle complex data structures and patterns as is required for highly parallelised and distributed computational workflows.\n\nAnother change is the introduction of `channel` as an alternative name as a synonym of `Channel` type identifier and therefore allows the use of `channel.fromPath` instead of `Channel.fromPath` and so on. This is a small syntax sugar to keep the capitazionation consistent with the rest of the language.\n\nMoreover, several process inputs and outputs syntax shortcuts were removed when using the final version of DSL 2 to make it more predictable. For example, with DSL1, in a tuple input or output declaration the component type could be omitted, for example:\n\n```\ninput:\n  tuple foo, 'bar'\n```\n\nThe `foo` identifier was implicitly considered an input value declaration instead the string `'bar'` was considered a shortcut for `file('bar')`. However, this was a bit confusing especially for new users and therefore using DSL 2, the fully qualified version must be used:\n\n```\ninput:\n  tuple val(foo), path('bar')\n```\n\nYou can find more detailed migration notes at [this link](/docs/latest/dsl2.html#dsl2-migration-notes).\n\n#### What's next\n\nAs always, reaching an important project milestone can be viewed as a major success, but at the same time the starting point for challenges and developments. Having a modularization mechanism opens new needs and possibilities. The first one of which will be focused on the ability to test and validate process modules independently using a unit-testing style approach. This will definitely help to make the resulting pipelines more resilient.\n\nAnother important area for the development of the Nextflow language will be the ability to better formalise pipeline inputs and outputs and further decouple for the process declaration. Nextflow currently strongly relies on the `publishDir` constructor for the generation of the workflow outputs.\n\nHowever in the new _module_ world, this approach results in `publishDir` being tied to a single process definition. The plan is instead to extend this concept in a more general and abstract manner, so that it will be possible to capture and redirect the result of any process and sub-workflow based on semantic annotations instead of hardcoding it at the task level.\n\n### Conclusion\n\nWe are extremely excited about today's release. This was a long awaited advancement and therefore we are very happy to make it available for general availability to all Nextflow users. We greatly appreciate all of the community feedback and ideas over the past year which have shaped DSL 2.\n\nWe are confident this represents a big step forward for the project and will enable the writing of a more scalable and complex data analysis pipeline and above all, a more enjoyable experience.",
    "images": [],
    "author": "Paolo Di Tommaso",
    "tags": "nextflow,release,modules,dsl2"
  },
  {
    "slug": "2020/groovy3-syntax-sugar",
    "title": "More syntax sugar for Nextflow developers!",
    "date": "2020-11-03T00:00:00.000Z",
    "content": "The latest Nextflow version 2020.10.0 is the first stable release running on Groovy 3.\n\nThe first benefit of this change is that now Nextflow can be compiled and run on any modern Java virtual machine,\nfrom Java 8, all the way up to the latest Java 15!\n\nAlong with this, the new Groovy runtime brings a whole lot of syntax enhancements that can be useful in\nthe everyday life of pipeline developers. Let's see them more in detail.\n\n### Improved not operator\n\nThe `!` (not) operator can now prefix the `in` and `instanceof` keywords.\nThis makes for more concise writing of some conditional expression, for example, the following snippet:\n\n```\nlist = [10,20,30]\n\nif( !(x in list) ) {\n  // ..\n}\nelse if( !(x instanceof String) ) {\n  // ..\n}\n```\n\ncould be replaced by the following:\n\n```\nlist = [10,20,30]\n\nif( x !in list ) {\n   // ..\n}\nelse if( x !instanceof String ) {\n   // ..\n}\n```\n\nAgain, this is a small syntax change which makes the code a little more\nreadable.\n\n### Elvis assignment operator\n\nThe elvis assignment operator `?=` allows the assignment of a value only if it was not\npreviously assigned (or if it evaluates to `null`). Consider the following example:\n\n```\ndef opts = [foo: 1]\n\nopts.foo ?= 10\nopts.bar ?= 20\n\nassert opts.foo == 1\nassert opts.bar == 20\n```\n\nIn this snippet, the assignment `opts.foo ?= 10` would be ignored because the dictionary `opts` already\ncontains a value for the `foo` attribute, while it is now assigned as expected.\n\nIn other words this is a shortcut for the following idiom:\n\n```\nif( some_variable != null ) {\n  some_variable = 'Hello'\n}\n```\n\nIf you are wondering why it's called _Elvis_ assignment, well it's simple, because there's also the [Elvis operator](https://groovy-lang.org/operators.html#_elvis_operator) that you should know (and use!) already. 😆\n\n### Java style lambda expressions\n\nGroovy 3 supports the syntax for Java lambda expression. If you don't know what a Java lambda expression is\ndon't worry; it's a concept very similar to a Groovy closure, though with slight differences\nboth in the syntax and the semantic. In a few words, a Groovy closure can modify a variable in the outside scope,\nwhile a Java lambda cannot.\n\nIn terms of syntax, a Groovy closure is defined as:\n\n```\n{ it -&gt; SOME_EXPRESSION_HERE }\n```\n\nWhile Java lambda expression looks like:\n\n```\nit -&gt; { SOME_EXPRESSION_HERE }\n```\n\nwhich can be simplified to the following form when the expression is a single statement:\n\n```\nit -&gt; SOME_EXPRESSION_HERE\n```\n\nThe good news is that the two syntaxes are interoperable in many cases and we can use the _lambda_\nsyntax to get rid-off of the curly bracket parentheses used by the Groovy notation to make our Nextflow\nscript more readable.\n\nFor example, the following Nextflow idiom:\n\n```\nChannel\n    .of( 1,2,3 )\n    .map { it * it +1 }\n    .view { \"the value is $it\" }\n```\n\nCan be rewritten using the lambda syntax as:\n\n```\nChannel\n    .of( 1,2,3 )\n    .map( it -&gt; it * it +1 )\n    .view( it -&gt; \"the value is $it\" )\n```\n\nIt is a bit more consistent. Note however that the `it -&gt;` implicit argument is now mandatory (while when using the closure syntax it could be omitted). Also, when the operator argument is not _single_ value, the lambda requires the\nround parentheses to define the argument e.g.\n\n```\nChannel\n    .of( 1,2,3 )\n    .map( it -&gt; tuple(it * it,  it+1) )\n    .view( (a,b) -&gt; \"the values are $a and $b\" )\n```\n\n### Full support for Java streams API\n\nSince version 8, Java provides a [stream library](https://winterbe.com/posts/2014/07/31/java8-stream-tutorial-examples/) that is very powerful and implements some concepts and operators similar to Nextflow channels.\n\nThe main differences between the two are that Nextflow channels and the corresponding operators are _non-blocking_\ni.e. their evaluation is performed asynchronously without blocking your program execution, while Java streams are\nexecuted in a synchronous manner (at least by default).\n\nA Java stream looks like the following:\n\n```\nassert (1..10).stream()\n                .filter(e -&gt; e % 2 == 0)\n                .map(e -&gt; e * 2)\n                .toList() == [4, 8, 12, 16, 20]\n\n```\n\nNote, in the above example\n[filter](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#filter-java.util.function.Predicate-),\n[map](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#map-java.util.function.Function-) and\n[toList](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#toList--)\nmethods are Java stream operator not the\n[Nextflow](https://www.nextflow.io/docs/latest/operator.html#filter)\n[homonymous](https://www.nextflow.io/docs/latest/operator.html#map)\n[ones](https://www.nextflow.io/docs/latest/operator.html#tolist).\n\n### Java style method reference\n\nThe new runtime also allows for the use of the `::` operator to reference an object method.\nThis can be useful to pass a method as an argument to a Nextflow operator in a similar\nmanner to how it was already possible using a closure. For example:\n\n```\nChannel\n .of( 'a', 'b', 'c')\n .view( String::toUpperCase )\n```\n\nThe above prints:\n\n```\n  A\n  B\n  C\n```\n\nBecause to [view](https://www.nextflow.io/docs/latest/operator.html#filter) operator applied\nthe method [toUpperCase](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#toUpperCase--)\nto each element emitted by the channel.\n\n### Conclusion\n\nThe new Groovy runtime brings a lot of syntax sugar for Nextflow pipelines and allows the use of modern Java\nruntime which delivers better performance and resource usage.\n\nThe ones listed above are only a small selection which may be useful to everyday Nextflow developers.\nIf you are curious to learn more about all the changes in the new Groovy parser you can find more details in\n[this link](https://groovy-lang.org/releasenotes/groovy-3.0.html).\n\nFinally, a big thanks to the Groovy community for their significant efforts in developing and maintaining this\ngreat programming environment.",
    "images": [],
    "author": "Paolo Di Tommaso",
    "tags": "nextflow,dsl2"
  },
  {
    "slug": "2020/learning-nextflow-in-2020",
    "title": "Learning Nextflow in 2020",
    "date": "2020-12-01T00:00:00.000Z",
    "content": "With the year nearly over, we thought it was about time to pull together the best-of-the-best guide for learning Nextflow in 2020. These resources will support anyone in the journey from total noob to Nextflow expert so this holiday season, give yourself or someone you know the gift of learning Nextflow!\n\n### Prerequisites to get started\n\nWe recommend that learners are comfortable with using the command line and the basic concepts of a scripting language such as Python or Perl before they start writing pipelines. Nextflow is widely used for bioinformatics applications, and the examples in these guides often focus on applications in these topics. However, Nextflow is now adopted in a number of data-intensive domains such as radio astronomy, satellite imaging and machine learning. No domain expertise is expected.\n\n### Time commitment\n\nWe estimate that the speediest of learners can complete the material in around 12 hours. It all depends on your background and how deep you want to dive into the rabbit-hole! Most of the content is introductory with some more advanced dataflow and configuration material in the workshops and patterns sections.\n\n### Overview of the material\n\n- Why learn Nextflow?\n- Introduction to Nextflow - AWS HPC Conference 2020 (8m)\n- A simple RNA-Seq hands-on tutorial (2h)\n- Full-immersion workshop (8h)\n- Nextflow advanced implementation Patterns (2h)\n- Other resources\n- Community and Support\n\n### 1. Why learn Nextflow?\n\nNextflow is an open-source workflow framework for writing and scaling data-intensive computational pipelines. It is designed around the Linux philosophy of simple yet powerful command-line and scripting tools that, when chained together, facilitate complex data manipulations. Combined with support for containerization, support for major cloud providers and on-premise architectures, Nextflow simplifies the writing and deployment of complex data pipelines on any infrastructure.\n\nThe following are some high-level motivations on why people choose to adopt Nextflow:\n\n1. Integrating Nextflow in your analysis workflows helps you implement **reproducible** pipelines. Nextflow pipelines follow FDA repeatability and reproducibility guidelines with version-control and containers to manage all software dependencies.\n2. Avoid vendor lock-in by ensuring portability. Nextflow is **portable**; the same pipeline written on a laptop can quickly scale to run HPC cluster, Amazon and Google cloud services, and Kubernetes. The code stays constant across varying infrastructures allowing collaboration and avoiding lock-in.\n3. It is **scalable** allowing the parallelization of tasks using the dataflow paradigm without having to hard-code the pipeline to a specific platform architecture.\n4. It is **flexible** and supports scientific workflow requirements like caching processes to prevent re-computation, and workflow reports to better understand the workflows’ executions.\n5. It is **growing fast** and has **long-term support**. Developed since 2013 by the same team, the Nextflow ecosystem is expanding rapidly.\n6. It is **open source** and licensed under Apache 2.0. You are free to use it, modify it and distribute it.\n\n### 2. Introduction to Nextflow from the HPC on AWS Conference 2020\n\nThis short YouTube video provides a general overview of Nextflow, the motivations behind its development and a demonstration of some of the latest features.\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/SYhDkUgcOXo\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen=\"\"></iframe>\n\n### 3. A simple RNA-Seq hands-on tutorial\n\nThis hands-on tutorial from Seqera Labs will guide you through implementing a proof-of-concept RNA-seq pipeline. The goal is to become familiar with basic concepts, including how to define parameters, use channels for data and write processes to perform tasks. It includes all scripts, data and resources and is perfect for getting a flavor for Nextflow.\n\n[Tutorial link on GitHub](https://github.com/seqeralabs/nextflow-tutorial)\n\n### 4. Full-immersion workshop\n\nHere you’ll dive deeper into Nextflow’s most prominent features and learn how to apply them. The full workshop includes an excellent section on containers, how to build them and how to use them with Nextflow. The written materials come with examples and hands-on exercises. Optionally, you can also follow with a series of videos from a live training workshop.\n\nThe workshop includes topics on:\n\n- Environment Setup\n- Basic NF Script and Concepts\n- Nextflow Processes\n- Nextflow Channels\n- Nextflow Operators\n- Basic RNA-Seq pipeline\n- Containers &amp; Conda\n- Nextflow Configuration\n- On-premise &amp; Cloud Deployment\n- DSL 2 &amp; Modules\n- [GATK hands-on exercise](https://seqera.io/training/handson/)\n\n[Workshop](https://seqera.io/training) &amp; [YouTube playlist](https://www.youtube.com/playlist?list=PLPZ8WHdZGxmUv4W8ZRlmstkZwhb_fencI).\n\n### 5. Nextflow implementation Patterns\n\nThis advanced section discusses recurring patterns and solutions to many common implementation requirements. Code examples are available with notes to follow along with as well as a GitHub repository.\n\n[Nextflow Patterns](http://nextflow-io.github.io/patterns/index.html) &amp; [GitHub repository](https://github.com/nextflow-io/patterns).\n\n### Other resources\n\nThe following resources will help you dig deeper into Nextflow and other related projects like the nf-core community who maintain curated pipelines and a very active Slack channel. There are plenty of Nextflow tutorials and videos online, and the following list is no way exhaustive. Please let us know if we are missing something.\n\n#### Nextflow docs\n\nThe reference for the Nextflow language and runtime. The docs should be your first point of reference when something is not clear. Newest features are documented in edge documentation pages released every month with the latest stable releases every three months.\n\nLatest [stable](https://www.nextflow.io/docs/latest/index.html) &amp; [edge](https://www.nextflow.io/docs/edge/index.html) documentation.\n\n#### nf-core\n\nnf-core is a growing community of Nextflow users and developers. You can find curated sets of biomedical analysis pipelines built by domain experts with Nextflow, that have passed tests and have been implemented according to best practice guidelines. Be sure to sign up to the Slack channel.\n\n[nf-core website](https://nf-co.re)\n\n#### Tower Docs\n\nNextflow Tower is a platform to easily monitor, launch and scale Nextflow pipelines on cloud providers and on-premise infrastructure. The documentation provides details on setting up compute environments, monitoring pipelines and launching using either the web graphic interface or API.\n\n[Nextflow Tower documentation](http://help.tower.nf)\n\n#### Nextflow Biotech Blueprint by AWS\n\nA quickstart for deploying a genomics analysis environment on Amazon Web Services (AWS) cloud, using Nextflow to create and orchestrate analysis workflows and AWS Batch to run the workflow processes.\n\n[Biotech Blueprint by AWS](https://aws.amazon.com/quickstart/biotech-blueprint/nextflow/)\n\n#### Running Nextflow by Google Cloud\n\nGoogle Cloud Nextflow step-by-step guide to launching Nextflow Pipelines in Google Cloud.\n\n[Nextflow on Google Cloud ](https://cloud.google.com/life-sciences/docs/tutorials/nextflow)\n\n#### Awesome Nextflow\n\nA collections of Nextflow based pipelines and other resources.\n\n[Awesome Nextflow](https://github.com/nextflow-io/awesome-nextflow)\n\n### Community and support\n\n- Nextflow [Gitter channel](https://gitter.im/nextflow-io/nextflow)\n- Nextflow [Forums](https://groups.google.com/forum/#!forum/nextflow)\n- [nf-core Slack](https://nfcore.slack.com/)\n- Twitter [@nextflowio](https://twitter.com/nextflowio?lang=en)\n- [Seqera Labs](https://www.seqera.io) technical support &amp; consulting\n\nNextflow is a community-driven project. The list of links below has been collated from a diverse collection of resources and experts to guide you in learning Nextflow. If you have any suggestions, please make a pull request to this page on GitHub.\n\nAlso stay tuned for our upcoming post, where we will discuss the ultimate Nextflow development environment.",
    "images": [],
    "author": "Evan Floden & Alain Coletta",
    "tags": "nextflow,learning,workshop"
  },
  {
    "slug": "2021/5-more-tips-for-nextflow-user-on-hpc",
    "title": "Five more tips for Nextflow user on HPC",
    "date": "2021-06-15T00:00:00.000Z",
    "content": "In May we blogged about [Five Nextflow Tips for HPC Users](/blog/2021/5_tips_for_hpc_users.html) and now we continue the series with five additional tips for deploying Nextflow with on HPC batch schedulers.\n\n### 1. Use the scratch directive\n\nTo allow the pipeline tasks to share data with each other, Nextflow requires a shared file system path as a working directory. When using this model, a common recommendation is to use the node's local scratch storage as the job working directory to avoid unnecessary use of the network shared file system and achieve better performance.\n\nNextflow implements this best-practice which can be enabled by adding the following setting in your `nextflow.config` file.\n\n```\nprocess.scratch = true\n```\n\nWhen using this option, Nextflow:\n\n- Creates a unique directory in the computing node's local `/tmp` or the path assigned by your cluster via the `TMPDIR` environment variable.\n- Creates a [symlink](https://en.wikipedia.org/wiki/Symbolic_link) for each input file required by the job execution.\n- Runs the job in the local scratch path.\n  Copies the job output files into the job shared work directory assigned by Nextflow.\n\n### 2. Use -bg option to launch the execution in the background\n\nIn some circumstances, you may need to run your Nextflow pipeline in the background without losing the execution output. In this scenario use the `-bg` command line option as shown below.\n\n```\nnextflow run <pipeline> -bg &gt; my-file.log\n```\n\nThis can be very useful when launching the execution from an SSH connected terminal and ensures that any connection issues don't stop the pipeline. You can use `ps` and `kill` to find and stop the execution.\n\n### 3. Disable interactive logging\n\nNextflow has rich terminal logging which uses ANSI escape codes to update the pipeline execution counters interactively. However, this is not very useful when submitting the pipeline execution as a cluster job or in the background. In this case, disable the rich ANSI logging using the command line option `-ansi-log false` or the environment variable `NXF_ANSI_LOG=false`.\n\n### 4. Cluster native options\n\nNextlow has portable directives for common resource requests such as [cpus](https://www.nextflow.io/docs/latest/process.html#cpus), [memory](https://www.nextflow.io/docs/latest/process.html#memory) and [disk](https://www.nextflow.io/docs/latest/process.html#disk) allocation.\n\nThese directives allow you to specify the request for a certain number of computing resources e.g CPUs, memory, or disk and Nextflow converts these values to the native setting of the target execution platform specified in the pipeline configuration.\n\nHowever, there can be settings that are only available on some specific cluster technology or vendors.\n\nThe [clusterOptions](https://www.nextflow.io/docs/latest/process.html#clusterOptions) directive allows you to specify any option of your resource manager for which there isn't direct support in Nextflow.\n\n### 5. Retry failing jobs increasing resource allocation\n\nA common scenario is that instances of the same process may require different computing resources. For example, requesting an amount of memory that is too low for some processes will result in those tasks failing. You could specify a higher limit which would accommodate the task with the highest memory utilization, but you then run the risk of decreasing your job’s execution priority.\n\nNextflow provides a mechanism that allows you to modify the amount of computing resources requested in the case of a process failure and attempt to re-execute it using a higher limit. For example:\n\n```\nprocess foo {\n\n  memory { 2.GB * task.attempt }\n  time { 1.hour * task.attempt }\n\n  errorStrategy { task.exitStatus in 137..140 ? 'retry' : 'terminate' }\n  maxRetries 3\n\n  script:\n  \"\"\"\n  your_job_command --here\n  \"\"\"\n}\n```\n\nIn the above example the memory and execution time limits are defined dynamically. The first time the process is executed the task.attempt is set to 1, thus it will request 2 GB of memory and one hour of maximum execution time.\n\nIf the task execution fails, reporting an exit status in the range between 137 and 140, the task is re-submitted (otherwise it terminates immediately). This time the value of task.attempt is 2, thus increasing the amount of the memory to four GB and the time to 2 hours, and so on.\n\nNOTE: These exit statuses are not standard and can change depending on the resource manager you are using. Consult your cluster administrator or scheduler administration guide for details on the exit statuses used by your cluster in similar error conditions.\n\n### Conclusion\n\nNextflow aims to give you control over every aspect of your workflow. These Nextflow options allow you to shape how Nextflow submits your processes to your executor, that can make your workflow more robust by avoiding the overloading of the executor. Some systems have hard limits which if you do not take into account, no processes will be executed. Being aware of these configuration values and how to use them is incredibly helpful when working with larger workflows.\n</pipeline>",
    "images": [],
    "author": "Kevin Sayers",
    "tags": "nextflow,hpc"
  },
  {
    "slug": "2021/5_tips_for_hpc_users",
    "title": "5 Nextflow Tips for HPC Users",
    "date": "2021-05-13T00:00:00.000Z",
    "content": "Nextflow is a powerful tool for developing scientific workflows for use on HPC systems. It provides a simple solution to deploy parallelized workloads at scale using an elegant reactive/functional programming model in a portable manner.\n\nIt supports the most popular workload managers such as Grid Engine, Slurm, LSF and PBS, among other out-of-the-box executors, and comes with sensible defaults for each. However, each HPC system is a complex machine with its own characteristics and constraints. For this reason you should always consult your system administrator before running a new piece of software or a compute intensive pipeline that spawns a large number of jobs.\n\nIn this series of posts, we will be sharing the top tips we have learned along the way that should help you get results faster while keeping in the good books of your sys admins.\n\n### 1. Don't forget the executor\n\nNextflow, by default, spawns parallel task executions in the computer on which it is running. This is generally useful for development purposes, however, when using an HPC system you should specify the executor matching your system. This instructs Nextflow to submit pipeline tasks as jobs into your HPC workload manager. This can be done adding the following setting to the `nextflow.config` file in the launching directory, for example:\n\n```\nprocess.executor = 'slurm'\n```\n\nWith the above setting Nextflow will submit the job executions to your Slurm cluster spawning a `sbatch` command for each job in your pipeline. Find the executor matching your system at [this link](https://www.nextflow.io/docs/latest/executor.html).\nEven better, to prevent the undesired use of the local executor in a specific environment, define the _default_ executor to be used by Nextflow using the following system variable:\n\n```\nexport NXF_EXECUTOR=slurm\n```\n\n### 2. Nextflow as a job\n\nQuite surely your sys admin has already warned you that the login/head node should only be used to submit job executions and not run compute intensive tasks.\nWhen running a Nextflow pipeline, the driver application submits and monitors the job executions on your cluster (provided you have correctly specified the executor as stated in point 1), and therefore it should not run compute intensive tasks.\n\nHowever, it's never a good practice to launch a long running job in the login node, and therefore a good practice consists of running Nextflow itself as a cluster job. This can be done by wrapping the `nextflow run` command in a shell script and submitting it as any other job. An average pipeline may require 2 CPUs and 2 GB of resources allocation.\n\nNote: the queue where the Nextflow driver job is submitted should allow the spawning of the pipeline jobs to carry out the pipeline execution.\n\n### 3. Use the queueSize directive\n\nThe `queueSize` directive is part of the executor configuration in the `nextflow.config` file, and defines how many processes are queued at a given time. By default, Nextflow will submit up to 100 jobs at a time for execution. Increase or decrease this setting depending your HPC system quota and throughput. For example:\n\n```\nexecutor {\n    name = 'slurm'\n    queueSize = 50\n}\n```\n\n### 4. Specify the max heap size\n\nThe Nextflow runtime runs on top of the Java virtual machine which, by design, tries to allocate as much memory as is available. This is not a good practice in HPC systems which are designed to share compute resources across many users and applications.\nTo avoid this, specify the maximum amount of memory that can be used by the Java VM using the -Xms and -Xmx Java flags. These can be specified using the `NXF_OPTS` environment variable.\n\nFor example:\n\n```\nexport NXF_OPTS=\"-Xms500M -Xmx2G\"\n```\n\nThe above setting instructs Nextflow to allocate a Java heap in the range of 500 MB and 2 GB of RAM.\n\n### 5. Limit the Nextflow submit rate\n\nNextflow attempts to submit the job executions as quickly as possible, which is generally not a problem. However, in some HPC systems the submission throughput is constrained or it should be limited to avoid degrading the overall system performance.\nTo prevent this problem you can use `submitRateLimit` to control the Nextflow job submission throughput. This directive is part of the `executor` configuration scope, and defines the number of tasks that can be submitted per a unit of time. The default for the `submitRateLimit` is unlimited.\nYou can specify the `submitRateLimit` like this:\n\n```\nexecutor {\n    submitRateLimit = '10 sec'\n}\n```\n\nYou can also more explicitly specify it as a rate of # processes / time unit:\n\n```\nexecutor {\n    submitRateLimit = '10/2min'\n}\n```\n\n### Conclusion\n\nNextflow aims to give you control over every aspect of your workflow. These options allow you to shape how Nextflow communicates with your HPC system. This can make workflows more robust while avoiding overloading the executor. Some systems have hard limits, and if you do not take them into account, it will stop any jobs from being scheduled.\n\nStay tuned for part two where we will discuss background executions, retry strategies, maxForks and other tips.",
    "images": [],
    "author": "Kevin Sayers",
    "tags": "nextflow,hpc"
  },
  {
    "slug": "2021/configure-git-repositories-with-nextflow",
    "title": "Configure Git private repositories with Nextflow",
    "date": "2021-10-21T00:00:00.000Z",
    "content": "Git has become the de-facto standard for source-code version control system and has seen increasing adoption across the spectrum of software development.\n\nNextflow provides builtin support for Git and most popular Git hosting platforms such\nas GitHub, GitLab and Bitbucket between the others, which streamline managing versions\nand track changes in your pipeline projects and facilitate the collaboration across\ndifferent users.\n\nIn order to access public repositories Nextflow does not require any special configuration, just use the _http_ URL of the pipeline project you want to run\nin the run command, for example:\n\n```\nnextflow run https://github.com/nextflow-io/hello\n```\n\nHowever to allow Nextflow to access private repositories you will need to specify\nthe repository credentials, and the server hostname in the case of self-managed\nGit server installations.\n\n## Configure access to private repositories\n\nThis is done through a file name `scm` placed in the `$HOME/.nextflow/` directory, containing the credentials and other details for accessing a particular Git hosting solution. You can refer to the Nextflow documentation for all the [SCM configuration file](https://www.nextflow.io/docs/edge/sharing.html) options.\n\nAll of these platforms have their own authentication mechanisms for Git operations which are captured in the `$HOME/.nextflow/scm` file with the following syntax:\n\n```groovy\nproviders {\n\n  '<provider-name-1>' {\n    user = value\n    password = value\n    ...\n  }\n\n  '<provider-name-2>' {\n    user = value\n    password = value\n    ...\n  }\n\n}\n```\n\nNote: Make sure to enclose the provider name with `'` if it contains a `-` or a\nblank character.\n\nAs of the 21.09.0-edge release, Nextflow integrates with the following Git providers:\n\n## GitHub\n\n[GitHub](https://github.com) is one of the most well known Git providers and is home to some of the most popular open-source Nextflow pipelines from the [nf-core](https://github.com/nf-core/) community project.\n\nIf you wish to use Nextflow code from a **public** repository hosted on GitHub.com, then you don't need to provide credentials (`user` and `password`) to pull code from the repository. However, if you wish to interact with a private repository or are running into GitHub API rate limits for public repos, then you must provide elevated access to Nextflow by specifying your credentials in the `scm` file.\n\nIt is worth noting that [GitHub recently phased out Git password authentication](https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/#what-you-need-to-do-today) and now requires that users supply a more secure GitHub-generated _Personal Access Token_ for authentication. With Nextflow, you can specify your _personal access token_ in the `password` field.\n\n```groovy\nproviders {\n\n  github {\n    user = 'me'\n    password = 'my-personal-access-token'\n  }\n\n}\n```\n\nTo generate a `personal-access-token` for the GitHub platform, follow the instructions provided [here](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token). Ensure that the token has at a minimum all the permissions in the `repo` scope.\n\nOnce you have provided your username and _personal access token_, as shown above, you can test the integration by pulling the repository code.\n\n```\nnextflow pull https://github.com/user_name/private_repo\n```\n\n## Bitbucket Cloud\n\n[Bitbucket](https://bitbucket.org/) is a publicly accessible Git solution hosted by Atlassian. Please note that if you are using an on-premises Bitbucket installation, you should follow the instructions for _Bitbucket Server_ in the following section.\n\nIf your Nextflow code is in a public Bitbucket repository, then you don't need to specify your credentials to pull code from the repository. However, if you wish to interact with a private repository, you need to provide elevated access to Nextflow by specifying your credentials in the `scm` file.\n\nPlease note that Bitbucket Cloud requires your `app password` in the `password` field, which is different from your login password.\n\n```groovy\nproviders {\n\n  bitbucket {\n    user = 'me'\n    password = 'my-app-password'\n  }\n\n}\n```\n\nTo generate an `app password` for the Bitbucket platform, follow the instructions provided [here](https://support.atlassian.com/bitbucket-cloud/docs/app-passwords/). Ensure that the token has at least `Repositories: Read` permission.\n\nOnce these settings are saved in `$HOME/.nextflow/scm`, you can test the integration by pulling the repository code.\n\n```\nnextflow pull https://bitbucket.org/user_name/private_repo\n```\n\n## Bitbucket Server\n\n[Bitbucket Server](https://www.atlassian.com/software/bitbucket/enterprise) is a Git hosting solution from Atlassian which is meant for teams that require a self-managed solution. If Nextflow code resides in an open Bitbucket repository, then you don't need to provide credentials to pull code from this repository. However, if you wish to interact with a private repository, you need to give elevated access to Nextflow by specifying your credentials in the `scm` file.\n\nFor example, if you'd like to call your hosted Bitbucket server as `mybitbucketserver`, then you'll need to add the following snippet in your `~/$HOME/.nextflow/scm` file.\n\n```groovy\nproviders {\n\n  mybitbucketserver {\n    platform = 'bitbucketserver'\n    server = 'https://your.bitbucket.host.com'\n    user = 'me'\n    password = 'my-password' // OR \"my-token\"\n  }\n\n}\n```\n\nTo generate a _personal access token_ for Bitbucket Server, refer to the [Bitbucket Support documentation](https://confluence.atlassian.com/bitbucketserver/managing-personal-access-tokens-1005339986.html) from Atlassian.\n\nOnce the configuration is saved, you can test the integration by pulling code from a private repository and specifying the `mybitbucketserver` Git provider using the `-hub` option.\n\n```\nnextflow pull https://your.bitbucket.host.com/user_name/private_repo -hub mybitbucketserver\n```\n\nNOTE: It is worth noting that [Atlassian is phasing out the Server offering](https://www.atlassian.com/migration/assess/journey-to-cloud) in favor of cloud product [bitbucket.org](https://bitbucket.org).\n\n## GitLab\n\n[GitLab](https://gitlab.com) is a popular Git provider that offers features covering various aspects of the DevOps cycle.\n\nIf you wish to run a Nextflow pipeline from a public GitLab repository, there is no need to provide credentials to pull code. However, if you wish to interact with a private repository, then you must give elevated access to Nextflow by specifying your credentials in the `scm` file.\n\nPlease note that you need to specify your _personal access token_ in the `password` field.\n\n```groovy\nproviders {\n\n  mygitlab {\n    user = 'me'\n    password = 'my-password' // or 'my-personal-access-token'\n    token = 'my-personal-access-token'\n  }\n\n}\n```\n\nIn addition, you can specify the `server` fields for your self-hosted instance of GitLab, by default [https://gitlab.com](https://gitlab.com) is assumed as the server.\n\nTo generate a `personal-access-token` for the GitLab platform follow the instructions provided [here](https://docs.gitlab.com/ee/user/profile/personal_access_tokens.html). Please ensure that the token has at least `read_repository`, `read_api` permissions.\n\nOnce the configuration is saved, you can test the integration by pulling the repository code using the `-hub` option.\n\n```\nnextflow pull https://gitlab.com/user_name/private_repo -hub mygitlab\n```\n\n## Gitea\n\n[Gitea server](https://gitea.com/) is an open source Git-hosting solution that can be self-hosted. If you have your Nextflow code in an open Gitea repository, there is no need to specify credentials to pull code from this repository. However, if you wish to interact with a private repository, you can give elevated access to Nextflow by specifying your credentials in the `scm` file.\n\nFor example, if you'd like to call your hosted Gitea server `mygiteaserver`, then you'll need to add the following snippet in your `~/$HOME/.nextflow/scm` file.\n\n```groovy\nproviders {\n\n  mygiteaserver {\n    platform = 'gitea'\n    server = 'https://gitea.host.com'\n    user = 'me'\n    password = 'my-password'\n  }\n\n}\n```\n\nTo generate a _personal access token_ for your Gitea server, please refer to the [official guide](https://docs.gitea.io/en-us/api-usage/).\n\nOnce the configuration is set, you can test the integration by pulling the repository code and specifying `mygiteaserver` as the Git provider using the `-hub` option.\n\n```\nnextflow pull https://git.host.com/user_name/private_repo -hub mygiteaserver\n```\n\n## Azure Repos\n\n[Azure Repos](https://azure.microsoft.com/en-us/services/devops/repos/) is a part of Microsoft Azure Cloud Suite. Nextflow integrates natively Azure Repos via the usual `~/$HOME/.nextflow/scm` file.\n\nIf you'd like to use the `myazure` alias for the `azurerepos` provider, then you'll need to add the following snippet in your `~/$HOME/.nextflow/scm` file.\n\n```groovy\nproviders {\n\n  myazure {\n    server = 'https://dev.azure.com'\n    platform = 'azurerepos'\n    user = 'me'\n    token = 'my-api-token'\n  }\n\n}\n```\n\nTo generate a _personal access token_ for your Azure Repos integration, please refer to the [official guide](https://docs.microsoft.com/en-us/azure/devops/organizations/accounts/use-personal-access-tokens-to-authenticate?view=azure-devops&amp;tabs=preview-page) on Azure.\n\nOnce the configuration is set, you can test the integration by pulling the repository code and specifying `myazure` as the Git provider using the `-hub` option.\n\n```\nnextflow pull https://dev.azure.com/org_name/DefaultCollection/_git/repo_name -hub myazure\n```\n\n## Conclusion\n\nGit is a popular, widely used software system for source code management. The native integration of Nextflow with various Git hosting solutions is an important feature to facilitate reproducible workflows that enable collaborative development and deployment of Nextflow pipelines.\n\nStay tuned for more integrations as we continue to improve our support for various source code management solutions!\n</provider-name-2></provider-name-1>",
    "images": [],
    "author": "Abhinav Sharma",
    "tags": "git,github"
  },
  {
    "slug": "2021/introducing-nextflow-for-azure-batch",
    "title": "Introducing Nextflow for Azure Batch",
    "date": "2021-02-22T00:00:00.000Z",
    "content": "When the Nextflow project was created, one of the main drivers was to enable reproducible data pipelines that could be deployed across a wide range of execution platforms with minimal effort as well as to empower users to scale their data analysis while facilitating the migration to the cloud.\n\nThroughout the years, the computing services provided by cloud vendors have evolved in a spectacular manner. Eight years ago, the model was focused on launching virtual machines in the cloud, then came containers and then the idea of serverless computing which changed everything again. However, the power of the Nextflow abstraction consists of hiding the complexity of the underlying platform. Through the concept of executors, emerging technologies and new platforms can be easily adapted with no changes required to user pipelines.\n\nWith this in mind, we could not be more excited to announce that over the past months we have been working with Microsoft to implement built-in support for [Azure Batch](https://azure.microsoft.com/en-us/services/batch/) into Nextflow. Today we are delighted to make it available to all users as a beta release.\n\n### How does it work\n\nAzure Batch is a cloud-based computing service that allows the execution of highly scalable, container based, workloads in the Azure cloud.\n\nThe support for Nextflow comes in the form of a plugin which implements a new executor, not surprisingly named `azurebatch`, which offloads the execution of the pipeline jobs to corresponding Azure Batch jobs.\n\nEach job run consists in practical terms of a container execution which ships the job dependencies and carries out the job computation. As usual, each job is assigned a unique working directory allocated into a [Azure Blob](https://azure.microsoft.com/en-us/services/storage/blobs/) container.\n\n### Let's get started!\n\nThe support for Azure Batch requires the latest release of Nextflow from the _edge_ channel (version 21.02-edge or later). If you don't have this, you can install it using these commands:\n\n```\nexport NXF_EDGE=1\ncurl get.nextflow.io | bash\n./nextflow -self-update\n```\n\nNote for Windows users, as Nextflow is \\*nix based tool you will need to run it using the [Windows subsystem for Linux](https://docs.microsoft.com/en-us/windows/wsl/install-win10). Also make sure Java 8 or later is installed in the Linux environment.\n\nOnce Nextflow is installed, to run your data pipelines with Azure Batch, you will need to create an Azure Batch account in the region of your choice using the Azure Portal. In a similar manner, you will need an Azure Blob container.\n\nWith the Azure Batch and Blob storage container configured, your `nextflow.config` file should be set up similar to the example below:\n\n```\nplugins {\n  id 'nf-azure'\n}\n\nprocess {\n  executor = 'azurebatch'\n}\n\nazure {\n  batch {\n    location = 'westeurope'\n    accountName = '<your batch=\"\" account=\"\" name=\"\">'\n    accountKey = '<your batch=\"\" account=\"\" key=\"\">'\n    autoPoolMode = true\n  }\n  storage {\n    accountName = \"<your storage=\"\" account=\"\" name=\"\">\"\n    accountKey = \"<your storage=\"\" account=\"\" key=\"\">\"\n  }\n}\n```\n\nUsing this configuration snippet, Nextflow will automatically create the virtual machine pool(s) required to deploy the pipeline execution in the Azure Batch service.\n\nNow you will be able to launch the pipeline execution using the following command:\n\n```\nnextflow run <pipeline name=\"\"> -w az://my-container/work\n```\n\nReplace `<pipeline name=\"\">` with a pipeline name e.g. nextflow-io/rnaseq-nf and `my-container` with a blob container in the storage account as defined in the above configuration.\n\nFor more details regarding the Nextflow configuration setting for Azure Batch\nrefers to the Nextflow documentation at [this link](/docs/edge/azure.html).\n\n### Conclusion\n\nThe support for Azure Batch further expands the wide range of computing platforms supported by Nextflow and empowers Nextflow users to deploy their data pipelines in the cloud provider of their choice. Above all, it allows researchers to scale, collaborate and share their work without being locked into a specific platform.\n\nWe thank Microsoft, and in particular [Jer-Ming Chia](https://www.linkedin.com/in/jermingchia/) who works in the HPC and AI team for having supported and sponsored this open source contribution to the Nextflow framework.\n</pipeline></pipeline></your></your></your></your>",
    "images": [],
    "author": "Paolo Di Tommaso",
    "tags": "nextflow,azure"
  },
  {
    "slug": "2021/nextflow-developer-environment",
    "title": "6 Tips for Setting Up Your Nextflow Dev Environment",
    "date": "2021-03-04T00:00:00.000Z",
    "content": "_This blog follows up the Learning Nextflow in 2020 blog [post](https://www.nextflow.io/blog/2020/learning-nextflow-in-2020.html)._\n\nThis guide is designed to walk you through a basic development setup for writing Nextflow pipelines.\n\n### 1. Installation\n\nNextflow runs on any Linux compatible system and MacOS with Java installed. Windows users can rely on the [Windows Subsystem for Linux](https://docs.microsoft.com/en-us/windows/wsl/install-win10). Installing Nextflow is straightforward. You just need to download the `nextflow` executable. In your terminal type the following commands:\n\n```\n$ curl get.nextflow.io | bash\n$ sudo mv nextflow /usr/local/bin\n```\n\nThe first line uses the curl command to download the nextflow executable, and the second line moves the executable to your PATH. Note `/usr/local/bin` is the default for MacOS, you might want to choose `~/bin` or `/usr/bin` depending on your PATH definition and operating system.\n\n### 2. Text Editor or IDE?\n\nNextflow pipelines can be written in any plain text editor. I'm personally a bit of a Vim fan, however, the advent of the modern IDE provides a more immersive development experience.\n\nMy current choice is Visual Studio Code which provides a wealth of add-ons, the most obvious of these being syntax highlighting. With [VSCode installed](https://code.visualstudio.com/download), you can search for the Nextflow extension in the marketplace.\n\n![VSCode with Nextflow Syntax Highlighting](/img/vscode-nf-highlighting.png)\n\nOther syntax highlighting has been made available by the community including:\n\n- [Atom](https://atom.io/packages/language-nextflow)\n- [Vim](https://github.com/LukeGoodsell/nextflow-vim)\n- [Emacs](https://github.com/Emiller88/nextflow-mode)\n\n### 3. The Nextflow REPL console\n\nThe Nextflow console is a REPL (read-eval-print loop) environment that allows one to quickly test part of a script or segments of Nextflow code in an interactive manner. This can be particularly useful to quickly evaluate channels and operators behaviour and prototype small snippets that can be included in your pipeline scripts.\n\nStart the Nextflow console with the following command:\n\n```\n$ nextflow console\n```\n\n![Nextflow REPL console](/img/nf-repl-console.png)\n\nUse the `CTRL+R` keyboard shortcut to run (`⌘+R`on the Mac) and to evaluate your code. You can also evaluate by selecting code and use the **Run selection**.\n\n### 4. Containerize all the things\n\nContainers are a key component of developing scalable and reproducible pipelines. We can build Docker images that contain an OS, all libraries and the software we need for each process. Pipelines are typically developed using Docker containers and tooling as these can then be used on many different container engines such as Singularity and Podman.\n\nOnce you have [downloaded and installed Docker](https://docs.docker.com/engine/install/), try pull a public docker image:\n\n```\n$ docker pull quay.io/nextflow/rnaseq-nf\n```\n\nTo run a Nextflow pipeline using the latest tag of the image, we can use:\n\n```\nnextflow run nextflow-io/rnaseq-nf -with-docker quay.io/nextflow/rnaseq-nf:latest\n```\n\nTo learn more about building Docker containers, see the [Seqera Labs tutorial](https://seqera.io/training/#_manage_dependencies_containers) on managing dependencies with containers.\n\nAdditionally, you can install the VSCode marketplace addon for Docker to manage and interactively run and test the containers and images on your machine. You can even connect to remote registries such as Dockerhub, Quay.io, AWS ECR, Google Cloud and Azure Container registries.\n\n![VSCode with Docker Extension](/img/vs-code-with-docker-extension.png)\n\n### 5. Use Tower to monitor your pipelines\n\nWhen developing real-world pipelines, it can become inevitable that pipelines will require significant resources. For long-running workflows, monitoring becomes all the more crucial. With [Nextflow Tower](https://tower.nf), we can invoke any Nextflow pipeline execution from the CLI and use the integrated dashboard to follow the workflow run.\n\nSign-in to Tower using your GitHub credentials, obtain your token from the Getting Started page and export them into your terminal, `~/.bashrc`, or include them in your nextflow.config.\n\n```\n$ export TOWER_ACCESS_TOKEN=my-secret-tower-key\n```\n\nWe can then add the `-with-tower` child-option to any Nextflow run command. A URL with the monitoring dashboard will appear.\n\n```\n$ nextflow run nextflow-io/rnaseq-nf -with-tower\n```\n\n### 6. nf-core tools\n\n[nf-core](https://nf-co.re/) is a community effort to collect a curated set of analysis pipelines built using Nextflow. The pipelines continue to come on in leaps and bounds and nf-core tools is a python package for helping with developing nf-core pipelines. It includes options for listing, creating, and even downloading pipelines for offline usage.\n\nThese tools are particularly useful for developers contributing to the community pipelines on [GitHub](https://github.com/nf-core/) with linting and syncing options that keep pipelines up-to-date against nf-core guidelines.\n\n`nf-core tools` is a python package that can be installed in your development environment from Bioconda or PyPi.\n\n```\n$ conda install nf-core\n```\n\nor\n\n```\n$ pip install nf-core\n```\n\n![nf-core tools](/img/nf-core-tools.png)\n\n### Conclusion\n\nDeveloper workspaces are evolving rapidly. While your own development environment may be highly dependent on personal preferences, community contributions are keeping Nextflow users at the forefront of the modern developer experience.\n\nSolutions such as [GitHub Codespaces](https://github.com/features/codespaces) and [Gitpod](https://www.gitpod.io/) are now offering extendible, cloud-based options that may well be the future. I’m sure we can all look forward to a one-click, pre-configured, cloud-based, Nextflow developer environment sometime soon!",
    "images": [],
    "author": "Evan Floden",
    "tags": "nextflow,development,learning"
  },
  {
    "slug": "2021/nextflow-sql-support",
    "title": "Introducing Nextflow support for SQL databases",
    "date": "2021-09-16T00:00:00.000Z",
    "content": "The recent tweet introducing the [Nextflow support for SQL databases](https://twitter.com/PaoloDiTommaso/status/1433120149888974854) raised a lot of positive reaction. In this post, I want to describe more in detail how this extension works.\n\nNextflow was designed with the idea to streamline the deployment of complex data pipelines in a scalable, portable and reproducible manner across different computing platforms. To make this all possible, it was decided the resulting pipeline and the runtime should be self-contained i.e. to not depend on separate services such as database servers.\n\nThis makes the resulting pipelines easier to configure, deploy, and allows for testing them using [CI services](https://en.wikipedia.org/wiki/Continuous_integration), which is a critical best practice for delivering high-quality and stable software.\n\nAnother important consequence is that Nextflow pipelines do not retain the pipeline state on separate storage. Said in a different way, the idea was - and still is - to promote stateless pipeline execution in which the computed results are only determined by the pipeline inputs and the code itself, which is consistent with the _functional_ dataflow paradigm on which Nextflow is based.\n\nHowever, the ability to access SQL data sources can be very useful in data pipelines, for example, to ingest input metadata or to store task executions logs.\n\n### How does it work?\n\nThe support for SQL databases in Nextflow is implemented as an optional plugin component. This plugin provides two new operations into your Nextflow script:\n\n1. `fromQuery` performs a SQL query against the specified database and returns a Nextflow channel emitting them. This channel can be used in your pipeline as any other Nextflow channel to trigger the process execution with the corresponding values.\n2. `sqlInsert` takes the values emitted by a Nextflow channel and inserts them into a database table.\n\nThe plugin supports out-of-the-box popular database servers such as MySQL, PostgreSQL and MariaDB. It should be noted that the technology is based on the Java JDBC database standard, therefore it could easily support any database technology implementing a driver for this standard interface.\n\nDisclaimer: This plugin is a preview technology. Some features, syntax and configuration settings can change in future releases.\n\n### Let's get started!\n\nThe use of the SQL plugin requires the use of Nextflow 21.08.0-edge or later. If are using an older version, check [this page](https://www.nextflow.io/docs/latest/getstarted.html#stable-edge-releases) on how to update to the latest edge release.\n\nTo enable the use of the database plugin, add the following snippet in your pipeline configuration file.\n\n```\nplugins {\n  id 'nf-sqldb@0.1.0'\n}\n```\n\nIt is then required to specify the connection _coordinates_ of the database service you want to connect to in your pipeline. This is done by adding a snippet similar to the following in your configuration file:\n\n```\nsql {\n    db {\n        'my-db' {\n              url = 'jdbc:mysql://localhost:3306/demo'\n              user = 'my-user'\n              password = 'my-password'\n            }\n    }\n}\n```\n\nIn the above example, replace `my-db` with a name of your choice (this name will be used in the script to reference the corresponding database connection coordinates). Also, provide a `url`, `user` and `password` matching your database server.\n\nYour script should then look like the following:\n\n```\nnextflow.enable.dsl=2\n\nprocess myProcess {\n  input:\n    tuple val(sample_id), path(sample_in)\n  output:\n    tuple val(sample_id), path('sample.out')\n\n  \"\"\"\n  your_command --input $sample_id &gt; sample.out\n  \"\"\"\n}\n\nworkflow {\n\n  query = 'select SAMPLE_ID, SAMPLE_FILE from SAMPLES'\n  channel.sql.fromQuery(query, db: 'my-db') \\\n    | myProcess \\\n    | sqlInsert(table: 'RESULTS', db: 'my-db')\n\n}\n```\n\nThe above example shows how to perform a simple database query, pipe the results to a fictitious process named `myProcess` and finally store the process outputs into a database table named `RESULTS`.\n\nIt is worth noting that Nextflow allows the use of any number of database instances in your pipeline, simply defining them in the configuration file using the syntax shown above. This could be useful to fetch database data from one data source and store the results into a different one.\n\nAlso, this makes it straightforward to write [ETL](https://en.wikipedia.org/wiki/Extract,_transform,_load) scripts that span across multiple data sources.\n\nFind more details about the SQL plugin for Nextflow at [this link](https://github.com/nextflow-io/nf-sqldb).\n\n## What about the self-contained property?\n\nYou may wonder if adding this capability breaks the self-contained property of Nextflow pipelines which allows them to be run in a single command and to be tested with continuous integration services e.g. GitHub Action.\n\nThe good news is that it does not ... or at least it should not if used properly.\n\nIn fact, the SQL plugin includes the [H2](http://www.h2database.com/html/features.html) embedded in-memory SQL database that is used by default when no other database is provided in the Nextflow configuration file and can be used for developing and testing your pipeline without the need for a separate database service.\n\nTip: Other than this, H2 also provides the capability to access and query CSV/TSV files as SQL tables. Read more about this feature at [this link](http://www.h2database.com/html/tutorial.html?highlight=csv&amp;search=csv#csv).\n\n### Conclusion\n\nThe use of this plugin adds to Nextflow the capability to query and store data into the SQL databases. Currently, the most popular SQL technologies are supported such as MySQL, PostgreSQL and MariaDB. In the future, support for other database technologies e.g. MongoDB, DynamoDB could be added.\n\nNotably, the support for SQL data-stores has been implemented preserving the core Nextflow capabilities to allow portable and self-contained pipeline scripts that can be developed locally, tested through CI services, and deployed at scale into production environments.\n\nIf you have any questions or suggestions, please feel free to comment in the project discussion group at [this link](https://github.com/nextflow-io/nf-sqldb/discussions).\n\nCredits to [Francesco Strozzi](https://twitter.com/fstrozzi) &amp; [Raoul J.P. Bonnal](https://twitter.com/bonnalr) for having contributed to this work 🙏.",
    "images": [],
    "author": "Paolo Di Tommaso",
    "tags": "nextflow,plugins,sql"
  },
  {
    "slug": "2021/setup-nextflow-on-windows",
    "title": "Setting up a Nextflow environment on Windows 10",
    "date": "2021-10-13T00:00:00.000Z",
    "content": "For Windows users, getting access to a Linux-based Nextflow development and runtime environment used to be hard. Users would need to run virtual machines, access separate physical servers or cloud instances, or install packages such as [Cygwin](http://www.cygwin.com/) or [Wubi](https://wiki.ubuntu.com/WubiGuide). Fortunately, there is now an easier way to deploy a complete Nextflow development environment on Windows.\n\nThe Windows Subsystem for Linux (WSL) allows users to build, manage and execute Nextflow pipelines on a Windows 10 laptop or desktop without needing a separate Linux machine or cloud VM. Users can build and test Nextflow pipelines and containerized workflows locally, on an HPC cluster, or their preferred cloud service, including AWS Batch and Azure Batch.\n\nThis document provides a step-by-step guide to setting up a Nextflow development environment on Windows 10.\n\n## High-level Steps\n\nThe steps described in this guide are as follows:\n\n- Install Windows PowerShell\n- Configure the Windows Subsystem for Linux (WSL2)\n- Obtain and Install a Linux distribution (on WSL2)\n- Install Windows Terminal\n- Install and configure Docker\n- Download and install an IDE (VS Code)\n- Install and test Nextflow\n- Configure X-Windows for use with the Nextflow Console\n- Install and Configure GIT\n\n## Install Windows PowerShell\n\nPowerShell is a cross-platform command-line shell and scripting language available for Windows, Linux, and macOS. If you are an experienced Windows user, you are probably already familiar with PowerShell. PowerShell is worth taking a few minutes to download and install.\n\nPowerShell is a big improvement over the Command Prompt in Windows 10. It brings features to Windows that Linux/UNIX users have come to expect, such as command-line history, tab completion, and pipeline functionality.\n\n- You can obtain PowerShell for Windows from GitHub at the URL https://github.com/PowerShell/PowerShell.\n- Download and install the latest stable version of PowerShell for Windows x64 - e.g., [powershell-7.1.3-win-x64.msi](https://github.com/PowerShell/PowerShell/releases/download/v7.1.3/PowerShell-7.1.3-win-x64.msi).\n- If you run into difficulties, Microsoft provides detailed instructions [here](https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-windows?view=powershell-7.1).\n\n## Configure the Windows Subsystem for Linux (WSL)\n\n### Enable the Windows Subsystem for Linux\n\nMake sure you are running Windows 10 Version 1903 with Build 18362 or higher. You can check your Windows version by select WIN-R (using the Windows key to run a command) and running the utility `winver`.\n\nFrom within PowerShell, run the Windows Deployment Image and Service Manager (DISM) tool as an administrator to enable the Windows Subsystem for Linux. To run PowerShell with administrator privileges, right-click on the PowerShell icon from the Start menu or desktop and select \"_Run as administrator_\".\n\n```powershell\nPS C:\\WINDOWS\\System32&gt; dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart\nDeployment Image Servicing and Management tool\nVersion: 10.0.19041.844\nImage Version: 10.0.19041.1083\n\nEnabling feature(s)\n[==========================100.0%==========================]\nThe operation completed successfully.\n```\n\nYou can learn more about DISM [here](https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/what-is-dism).\n\n### Step 2: Enable the Virtual Machine Feature\n\nWithin PowerShell, enable Virtual Machine Platform support using DISM. If you have trouble enabling this feature, make sure that virtual machine support is enabled in your machine's BIOS.\n\n```powershell\nPS C:\\WINDOWS\\System32&gt; dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart\nDeployment Image Servicing and Management tool\nVersion: 10.0.19041.844\nImage Version: 10.0.19041.1083\nEnabling feature(s)\n[==========================100.0%==========================]\nThe operation completed successfully.\n```\n\nAfter enabling the Virtual Machine Platform support, **restart your machine**.\n\n### Step 3: Download the Linux Kernel Update Package\n\nNextflow users will want to take advantage of the latest features in WSL 2. You can learn about differences between WSL 1 and WSL 2 [here](https://docs.microsoft.com/en-us/windows/wsl/compare-versions). Before you can enable support for WSL 2, you'll need to download the kernel update package at the link below:\n\n[WSL2 Linux kernel update package for x64 machines](https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi)\n\nOnce downloaded, double click on the kernel update package and select \"Yes\" to install it with elevated permissions.\n\n### STEP 4: Set WSL2 as your Default Version\n\nFrom within PowerShell:\n\n```powershell\nPS C:\\WINDOWS\\System32&gt; wsl --set-default-version 2\nFor information on key differences with WSL 2 please visit https://aka.ms/wsl2\n```\n\nIf you run into difficulties with any of these steps, Microsoft provides detailed installation instructions [here](https://docs.microsoft.com/en-us/windows/wsl/install-win10#manual-installation-steps).\n\n## Obtain and Install a Linux Distribution on WSL\n\nIf you normally install Linux on VM environments such as VirtualBox or VMware, this probably sounds like a lot of work. Fortunately, Microsoft provides Linux OS distributions via the Microsoft Store that work with the Windows Subsystem for Linux.\n\n- Use this link to access and download a Linux Distribution for WSL through the Microsoft Store - https://aka.ms/wslstore.\n\n  ![Linux Distributions at the Microsoft Store](/img/ms-store.png)\n\n- We selected the Ubuntu 20.04 LTS release. You can use a different distribution if you choose. Installation from the Microsoft Store is automated. Once the Linux distribution is installed, you can run a shell on Ubuntu (or your installed OS) from the Windows Start menu.\n- When you start Ubuntu Linux for the first time, you will be prompted to provide a UNIX username and password. The username that you select can be distinct from your Windows username. The UNIX user that you create will automatically have `sudo` privileges. Whenever a shell is started, it will default to this user.\n- After setting your username and password, update your packages on Ubuntu from the Linux shell using the following command:\n\n  ```bash\n  sudo apt update &amp;&amp; sudo apt upgrade\n  ```\n\n- This is also a good time to add any additional Linux packages that you will want to use.\n\n  ```bash\n  sudo apt install net-tools\n  ```\n\n## Install Windows Terminal\n\nWhile not necessary, it is a good idea to install [Windows Terminal](https://github.com/microsoft/terminal) at this point. When working with Nextflow, it is handy to interact with multiple command lines at the same time. For example, users may want to execute flows, monitor logfiles, and run Docker commands in separate windows.\n\nWindows Terminal provides an X-Windows-like experience on Windows. It helps organize your various command-line environments - Linux shell, Windows Command Prompt, PowerShell, AWS or Azure CLIs.\n\n![Windows Terminal](/img/windows-terminal.png)\n\nInstructions for downloading and installing Windows Terminal are available at: https://docs.microsoft.com/en-us/windows/terminal/get-started.\n\nIt is worth spending a few minutes getting familiar with available commands and shortcuts in Windows Terminal. Documentation is available at https://docs.microsoft.com/en-us/windows/terminal/command-line-arguments.\n\nSome Windows Terminal commands you'll need right away are provided below:\n\n- Split the active window vertically: <kbd>SHIFT</kbd> <kbd>ALT</kbd> <kbd>=</kbd>\n- Split the active window horizontally: <kbd>SHIFT</kbd> <kbd>ALT</kbd> <kbd>–</kbd>\n- Resize the active window: <kbd>SHIFT</kbd> <kbd>ALT</kbd> `<arrow keys=\"\">`\n- Open a new window under the current tab: <kbd>ALT</kbd> <kbd>v</kbd> (_the new tab icon along the top of the Windows Terminal interface_)\n\n## Installing Docker on Windows\n\nThere are two ways to install Docker for use with the WSL on Windows. One method is to install Docker directly on a hosted WSL Linux instance (Ubuntu in our case) and have the docker daemon run on the Linux kernel as usual. An installation recipe for people that choose this \"native Linux\" approach is provided [here](https://dev.to/bowmanjd/install-docker-on-windows-wsl-without-docker-desktop-34m9).\n\nA second method is to run [Docker Desktop](https://www.docker.com/products/docker-desktop) on Windows. While Docker is more commonly used in Linux environments, it can be used with Windows also. The Docker Desktop supports containers running on Windows and Linux instances running under WSL. Docker Desktop provides some advantages for Windows users:\n\n- The installation process is automated\n- Docker Desktop provides a Windows GUI for managing Docker containers and images (including Linux containers running under WSL)\n- Microsoft provides Docker Desktop integration features from within Visual Studio Code via a VS Code extension\n- Docker Desktop provides support for auto-installing a single-node Kubernetes cluster\n- The Docker Desktop WSL 2 back-end provides an elegant Linux integration such that from a Linux user's perspective, Docker appears to be running natively on Linux.\n\nAn explanation of how the Docker Desktop WSL 2 Back-end works is provided [here](https://www.docker.com/blog/new-docker-desktop-wsl2-backend/).\n\n### Step 1: Install Docker Desktop on Windows\n\n- Download and install Docker Desktop for Windows from the following link: https://desktop.docker.com/win/stable/amd64/Docker%20Desktop%20Installer.exe\n- Follow the on-screen prompts provided by the Docker Desktop Installer. The installation process will install Docker on Windows and install the Docker back-end components so that Docker commands are accessible from within WSL.\n- After installation, Docker Desktop can be run from the Windows start menu. The Docker Desktop user interface is shown below. Note that Docker containers launched under WSL can be managed from the Windows Docker Desktop GUI or Linux command line.\n- The installation process is straightforward, but if you run into difficulties, detailed instructions are available [here](https://docs.docker.com/docker-for-windows/install/).\n\n  ![Nextflow Visual Studio Code Extension](/img/docker-images.png)\n\n  The Docker Engineering team provides an architecture diagram explaining how Docker on Windows interacts with WSL. Additional details are available [here](https://code.visualstudio.com/blogs/2020/03/02/docker-in-wsl2).\n\n  ![Nextflow Visual Studio Code Extension](/img/docker-windows-arch.png)\n\n### Step 2: Verify the Docker installation\n\nNow that Docker is installed, run a Docker container to verify that Docker and the Docker Integration Package on WSL 2 are working properly.\n\n- Run a Docker command from the Linux shell as shown below below. This command downloads a **centos** image from Docker Hub and allows us to interact with the container via an assigned pseudo-tty. Your Docker container may exit with exit code 139 when you run this and other Docker containers. If so, don't worry – an easy fix to this issue is provided shortly.\n\n  ```console\n  $ docker run -ti centos:6\n  [root@02ac0beb2d2c /]# hostname\n  02ac0beb2d2c\n  ```\n\n- You can run Docker commands in other Linux shell windows via the Windows Terminal environment to monitor and manage Docker containers and images. For example, running `docker ps` in another window shows the running CentOS Docker container.\n\n  ```console\n  $ docker ps\n  CONTAINER ID IMAGE   COMMAND   CREATED    STATUS    NAMES\n  f5dad42617f1 centos:6 \"/bin/bash\" 2 minutes ago Up 2 minutes \thappy_hopper\n  ```\n\n### Step 3: Dealing with exit code 139\n\nYou may encounter exit code `139` when running Docker containers. This is a known problem when running containers with specific base images within Docker Desktop. Good explanations of the problem and solution are provided [here](https://dev.to/damith/docker-desktop-container-crash-with-exit-code-139-on-windows-wsl-fix-438) and [here](https://unix.stackexchange.com/questions/478387/running-a-centos-docker-image-on-arch-linux-exits-with-code-139).\n\nThe solution is to add two lines to a `.wslconfig` file in your Windows home directory. The `.wslconfig` file specifies kernel options that apply to all Linux distributions running under WSL 2.\n\nSome of the Nextflow container images served from Docker Hub are affected by this bug since they have older base images, so it is a good idea to apply this fix.\n\n- Edit the `.wslconfig` file in your Windows home directory. You can do this using PowerShell as shown:\n\n  ```powershell\n  PS C:\\Users\\<username> notepad .wslconfig\n  ```\n\n- Add these two lines to the `.wslconfig` file and save it:\n\n  ```ini\n  [wsl2]\n  kernelCommandLine = vsyscall=emulate\n  ```\n\n- After this, **restart your machine** to force a restart of the Docker and WSL 2 environment. After making this correction, you should be able to launch containers without seeing exit code `139`.\n\n## Install Visual Studio Code as your IDE (optional)\n\nDevelopers can choose from a variety of IDEs depending on their preferences. Some examples of IDEs and developer-friendly editors are below:\n\n- Visual Studio Code - https://code.visualstudio.com/Download (Nextflow VSCode Language plug-in [here](https://github.com/nextflow-io/vscode-language-nextflow/blob/master/vsc-extension-quickstart.md))\n- Eclipse - https://www.eclipse.org/\n- VIM - https://www.vim.org/ (VIM plug-in for Nextflow [here](https://github.com/LukeGoodsell/nextflow-vim))\n- Emacs - https://www.gnu.org/software/emacs/download.html (Nextflow syntax highlighter [here](https://github.com/Emiller88/nextflow-mode))\n- JetBrains PyCharm - https://www.jetbrains.com/pycharm/\n- IntelliJ IDEA - https://www.jetbrains.com/idea/\n- Atom – https://atom.io/ (Nextflow Atom support available [here](https://atom.io/packages/language-nextflow))\n- Notepad++ - https://notepad-plus-plus.org/\n\nWe decided to install Visual Studio Code because it has some nice features, including:\n\n- Support for source code control from within the IDE (Git)\n- Support for developing on Linux via its WSL 2 Video Studio Code Backend\n- A library of extensions including Docker and Kubernetes support and extensions for Nextflow, including Nextflow language support and an [extension pack for the nf-core community](https://github.com/nf-core/vscode-extensionpack).\n\nDownload Visual Studio Code from https://code.visualstudio.com/Download and follow the installation procedure. The installation process will detect that you are running WSL. You will be invited to download and install the Remote WSL extension.\n\n- Within VS Code and other Windows tools, you can access the Linux file system under WSL 2 by accessing the path `\\\\wsl$\\<linux-environment>`. In our example, the path from Windows to access files from the root of our Ubuntu Linux instance is: [**\\\\wsl$\\Ubuntu-20.04**](file://wsl$/Ubuntu-20.04).\n\nNote that the reverse is possible also – from within Linux, `/mnt/c` maps to the Windows C: drive. You can inspect `/etc/mtab` to see the mounted file systems available under Linux.\n\n- It is a good idea to install Nextflow language support in VS Code. You can do this by selecting the Extensions icon from the left panel of the VS Code interface and searching the extensions library for Nextflow as shown. The Nextflow language support extension is on GitHub at https://github.com/nextflow-io/vscode-language-nextflow\n\n  ![Nextflow Visual Studio Code Extension](/img/nf-vscode-ext.png)\n\n## Visual Studio Code Remote Development\n\nVisual Studio Code Remote Development supports development on remote environments such as containers or remote hosts. For Nextflow users, it is important to realize that VS Code sees the Ubuntu instance we installed on WSL as a remote environment. The Diagram below illustrates how remote development works. From a VS Code perspective, the Linux instance in WSL is considered a remote environment.\n\nWindows users work within VS Code in the Windows environment. However, source code, developer tools, and debuggers all run Linux on WSL, as illustrated below.\n\n![The Remote Development Environment in VS Code](/img/vscode-remote-dev.png)\n\nAn explanation of how VS Code Remote Development works is provided [here](https://code.visualstudio.com/docs/remote/remote-overview).\n\nVS Code users see the Windows filesystem, plug-ins specific to VS Code on Windows, and access Windows versions of tools such as Git. If you prefer to develop in Linux, you will want to select WSL as the remote environment.\n\nTo open a new VS Code Window running in the context of the WSL Ubuntu-20.04 environment, click the green icon at the lower left of the VS Code window and select _\"New WSL Window using Distro ..\"_ and select `Ubuntu 20.04`. You'll notice that the environment changes to show that you are working in the WSL: `Ubuntu-20.04` environment.\n\n![Selecting the Remote Dev Environment within VS Code](/img/remote-dev-side-by-side.png)\n\nSelecting the Extensions icon, you can see that different VS Code Marketplace extensions run in different contexts. The Nextflow Language extension installed in the previous step is globally available. It works when developing on Windows or developing on WSL: Ubuntu-20.04.\n\nThe Extensions tab in VS Code differentiates between locally installed plug-ins and those installed under WSL.\n\n![Local vs. Remote Extensions in VS Code](/img/vscode-extensions.png)\n\n## Installing Nextflow\n\nWith Linux, Docker, and an IDE installed, now we can install Nextflow in our WSL 2 hosted Linux environment. Detailed instructions for installing Nextflow are available at https://www.nextflow.io/docs/latest/getstarted.html#installation\n\n### Step 1: Make sure Java is installed (under WSL)\n\nJava is a prerequisite for running Nextflow. Instructions for installing Java on Ubuntu are available [here](https://linuxize.com/post/install-java-on-ubuntu-18-04/). To install the default OpenJDK, follow the instructions below in a Linux shell window:\n\n- Update the _apt_ package index:\n\n  ```bash\n  sudo apt update\n  ```\n\n- Install the latest default OpenJDK package\n\n  ```bash\n  sudo apt install default-jdk\n  ```\n\n- Verify the installation\n\n  ```bash\n  java -version\n  ```\n\n### Step 2: Make sure curl is installed\n\n`curl` is a convenient way to obtain Nextflow. `curl` is included in the default Ubuntu repositories, so installation is straightforward.\n\n- From the shell:\n\n  ```bash\n  sudo apt update\n  sudo apt install curl\n  ```\n\n- Verify that `curl` works:\n\n  ```console\n  $ curl\n  curl: try 'curl --help' or 'curl --manual' for more information\n  ```\n\n### STEP 3: Download and install Nextflow\n\n- Use `curl` to retrieve Nextflow into a temporary directory and then install it in `/usr/bin` so that the Nextflow command is on your path:\n\n  ```bash\n  mkdir temp\n  cd temp\n  curl -s https://get.nextflow.io | bash\n  sudo cp nextflow /usr/bin\n  ```\n\n- Make sure that Nextflow is executable:\n\n  ```bash\n  sudo chmod 755 /usr/bin/nextflow\n  ```\n\n  or if you prefer:\n\n  ```bash\n  sudo chmod +x /usr/bin/nextflow\n  ```\n\n### Step 4: Verify the Nextflow installation\n\n- Make sure Nextflow runs:\n\n  ```console\n  $ nextflow -version\n\n    N E X T F L O W\n    version 21.04.2 build 5558\n    created 12-07-2021 07:54 UTC (03:54 EDT)\n    cite doi:10.1038/nbt.3820\n    http://nextflow.io\n  ```\n\n- Run a simple Nextflow pipeline. The example below downloads and executes a sample hello world pipeline from GitHub - https://github.com/nextflow-io/hello.\n\n  ```console\n  $ nextflow run hello\n\n  N E X T F L O W ~ version 21.04.2\n  Launching `nextflow-io/hello` [distracted_pare] - revision: ec11eb0ec7 [master]\n  executor &gt; local (4)\n  [06/c846d8] process &gt; sayHello (3) [100%] 4 of 4 ✔\n  Ciao world!\n\n  Hola world!\n\n  Bonjour world!\n\n  Hello world!\n  ```\n\n### Step 5: Run a Containerized Workflow\n\nTo validate that Nextflow works with containerized workflows, we can run a slightly more complicated example. A sample workflow involving NCBI Blast is available at https://github.com/nextflow-io/blast-example. Rather than installing Blast on our local Linux instance, it is much easier to pull a container preloaded with Blast and other software that the pipeline depends on.\n\nThe `nextflow.config` file for the Blast example (below) specifies that process logic is encapsulated in the container `nextflow/examples` available from Docker Hub (https://hub.docker.com/r/nextflow/examples).\n\n- On GitHub: [nextflow-io/blast-example/nextflow.config](https://github.com/nextflow-io/blast-example/blob/master/nextflow.config)\n\n  ```groovy\n  manifest {\n    nextflowVersion = '&gt;= 20.01.0'\n  }\n\n  process {\n    container = 'nextflow/examples'\n  }\n  ```\n\n- Run the _blast-example_ pipeline that resides on GitHub directly from WSL and specify Docker as the container runtime using the command below:\n\n  ```console\n  $ nextflow run blast-example -with-docker\n  N E X T F L O W ~ version 21.04.2\n  Launching `nextflow-io/blast-example` [sharp_raman] - revision: 25922a0ae6 [master]\n  executor &gt; local (2)\n  [aa/a9f056] process &gt; blast (1)  [100%] 1 of 1 ✔\n  [b3/c41401] process &gt; extract (1) [100%] 1 of 1 ✔\n  matching sequences:\n  &gt;lcl|1ABO:B unnamed protein product\n  MNDPNLFVALYDFVASGDNTLSITKGEKLRVLGYNHNGEWCEAQTKNGQGWVPSNYITPVNS\n  &gt;lcl|1ABO:A unnamed protein product\n  MNDPNLFVALYDFVASGDNTLSITKGEKLRVLGYNHNGEWCEAQTKNGQGWVPSNYITPVNS\n  &gt;lcl|1YCS:B unnamed protein product\n  PEITGQVSLPPGKRTNLRKTGSERIAHGMRVKFNPLPLALLLDSSLEGEFDLVQRIIYEVDDPSLPNDEGITALHNAVCA\n  GHTEIVKFLVQFGVNVNAADSDGWTPLHCAASCNNVQVCKFLVESGAAVFAMTYSDMQTAADKCEEMEEGYTQCSQFLYG\n  VQEKMGIMNKGVIYALWDYEPQNDDELPMKEGDCMTIIHREDEDEIEWWWARLNDKEGYVPRNLLGLYPRIKPRQRSLA\n  &gt;lcl|1IHD:C unnamed protein product\n  LPNITILATGGTIAGGGDSATKSNYTVGKVGVENLVNAVPQLKDIANVKGEQVVNIGSQDMNDNVWLTLAKKINTDCDKT\n  ```\n\n- Nextflow executes the pipeline directly from the GitHub repository and automatically pulls the nextflow/examples container from Docker Hub if the image is unavailable locally. The pipeline then executes the two containerized workflow steps (blast and extract). The pipeline then collects the sequences into a single file and prints the result file content when pipeline execution completes.\n\n## Configuring an XServer for the Nextflow Console\n\nPipeline developers will probably want to use the Nextflow Console at some point. The Nextflow Console's REPL (read-eval-print loop) environment allows developers to quickly test parts of scripts or Nextflow code segments interactively.\n\nThe Nextflow Console is launched from the Linux command line. However, the Groovy-based interface requires an X-Windows environment to run. You can set up X-Windows with WSL using the procedure below. A good article on this same topic is provided [here](https://medium.com/javarevisited/using-wsl-2-with-x-server-linux-on-windows-a372263533c3).\n\n- Download an X-Windows server for Windows. In this example, we use the _VcXsrv Windows X Server_ available from source forge at https://sourceforge.net/projects/vcxsrv/.\n\n- Accept all the defaults when running the automated installer. The X-server will end up installed in `c:\\Program Files\\VcXsrv`.\n\n- The automated installation of VcXsrv will create an _\"XLaunch\"_ shortcut on your desktop. It is a good idea to create your own shortcut with a customized command line so that you don't need to interact with the XLaunch interface every time you start the X-server.\n\n- Right-click on the Windows desktop to create a new shortcut, give it a meaningful name, and insert the following for the shortcut target:\n\n  ```powershell\n  \"C:\\Program Files\\VcXsrv\\vcxsrv.exe\" :0 -ac -terminate -lesspointer -multiwindow -clipboard -wgl -dpi auto\n  ```\n\n- Inspecting the new shortcut properties, it should look something like this:\n\n  ![X-Server (vcxsrc) Properties](/img/xserver.png)\n\n- Double-click on the new shortcut desktop icon to test it. Unfortunately, the X-server runs in the background. When running the X-server in multiwindow mode (which we recommend), it is not obvious whether the X-server is running.\n\n- One way to check that the X-server is running is to use the Microsoft Task Manager and look for the XcSrv process running in the background. You can also verify it is running by using the `netstat` command from with PowerShell on Windows to ensure that the X-server is up and listening on the appropriate ports. Using `netstat`, you should see output like the following:\n\n  ```powershell\n  PS C:\\WINDOWS\\system32&gt; **netstat -abno | findstr 6000**\n   TCP  0.0.0.0:6000      0.0.0.0:0       LISTENING    35176\n   TCP  127.0.0.1:6000     127.0.0.1:56516    ESTABLISHED   35176\n   TCP  127.0.0.1:6000     127.0.0.1:56517    ESTABLISHED   35176\n   TCP  127.0.0.1:6000     127.0.0.1:56518    ESTABLISHED   35176\n   TCP  127.0.0.1:56516    127.0.0.1:6000     ESTABLISHED   35176\n   TCP  127.0.0.1:56517    127.0.0.1:6000     ESTABLISHED   35176\n   TCP  127.0.0.1:56518    127.0.0.1:6000     ESTABLISHED   35176\n   TCP  172.28.192.1:6000   172.28.197.205:46290  TIME_WAIT    0\n   TCP  [::]:6000       [::]:0         LISTENING    35176\n  ```\n\n- At this point, the X-server is up and running and awaiting a connection from a client.\n\n- Within Ubuntu in WSL, we need to set up the environment to communicate with the X-Windows server. The shell variable DISPLAY needs to be set pointing to the IP address of the X-server and the instance of the X-windows server.\n\n- The shell script below will set the DISPLAY variable appropriately and export it to be available to X-Windows client applications launched from the shell. This scripting trick works because WSL sees the Windows host as the nameserver and this is the same IP address that is running the X-Server. You can echo the $DISPLAY variable after setting it to verify that it is set correctly.\n\n  ```console\n  $ export DISPLAY=$(cat /etc/resolv.conf | grep nameserver | awk '{print $2}'):0.0\n  $ echo $DISPLAY\n  172.28.192.1:0.0\n  ```\n\n- Add this command to the end of your `.bashrc` file in the Linux home directory to avoid needing to set the DISPLAY variable every time you open a new window. This way, if the IP address of the desktop or laptop changes, the DISPLAY variable will be updated accordingly.\n\n  ```bash\n  cd ~\n  vi .bashrc\n  ```\n\n  ```bash\n  # set the X-Windows display to connect to VcXsrv on Windows\n  export DISPLAY=$(cat /etc/resolv.conf | grep nameserver | awk '{print $2}'):0.0\n  \".bashrc\" 120L, 3912C written\n  ```\n\n- Use an X-windows client to make sure that the X- server is working. Since X-windows clients are not installed by default, download an xterm client as follows via the Linux shell:\n\n  ```bash\n  sudo apt install xterm\n  ```\n\n- Assuming that the X-server is up and running on Windows, and the Linux DISPLAY variable is set correctly, you're ready to test X-Windows.\n\n  Before testing X-Windows, do yourself a favor and temporarily disable the Windows Firewall. The Windows Firewall will very likely block ports around 6000, preventing client requests on WSL from connecting to the X-server. You can find this under Firewall &amp; network protection on Windows. Clicking the \"Private Network\" or \"Public Network\" options will show you the status of the Windows Firewall and indicate whether it is on or off.\n\n  Depending on your installation, you may be running a specific Firewall. In this example, we temporarily disable the McAfee LiveSafe Firewall as shown:\n\n  ![Ensure that the Firewall is not interfering](/img/firewall.png)\n\n- With the Firewall disabled, you can attempt to launch the xterm client from the Linux shell:\n\n  ```bash\n  xterm &amp;\n  ```\n\n- If everything is working correctly, you should see the new xterm client appear under Windows. The xterm is executing on Ubuntu under WSL but displays alongside other Windows on the Windows desktop. This is what is meant by \"multiwindow\" mode.\n\n  ![Launch an xterm to verify functionality](/img/xterm.png)\n\n- Now that you know X-Windows is working correctly turn the Firewall back on, and adjust the settings to allow traffic to and from the required port. Ideally, you want to open only the minimal set of ports and services required. In the case of the McAfee Firewall, getting X-Windows to work required changing access to incoming and outgoing ports to _\"Open ports to Work and Home networks\"_ for the `vcxsrv.exe` program only as shown:\n\n  ![Allowing access to XServer traffic](/img/xserver_setup.png)\n\n- With the X-server running, the `DISPLAY` variable set, and the Windows Firewall configured correctly, we can now launch the Nextflow Console from the shell as shown:\n\n  ```bash\n  nextflow console\n  ```\n\n  The command above opens the Nextflow REPL console under X-Windows.\n\n  ![Nextflow REPL Console under X-Windows](/img/repl_console.png)\n\nInside the Nextflow console, you can enter Groovy code and run it interactively, a helpful feature when developing and debugging Nextflow pipelines.\n\n# Installing Git\n\nCollaborative source code management systems such as BitBucket, GitHub, and GitLab are used to develop and share Nextflow pipelines. To be productive with Nextflow, you will want to install Git.\n\nAs explained earlier, VS Code operates in different contexts. When running VS Code in the context of Windows, VS Code will look for a local copy of Git. When using VS Code to operate against the remote WSL environment, a separate installation of Git installed on Ubuntu will be used. (Note that Git is installed by default on Ubuntu 20.04)\n\nDevelopers will probably want to use Git both from within a Windows context and a Linux context, so we need to make sure that Git is present in both environments.\n\n### Step 1: Install Git on Windows (optional)\n\n- Download the install the 64-bit Windows version of Git from https://git-scm.com/downloads.\n\n- Click on the Git installer from the Downloads directory, and click through the default installation options. During the install process, you will be asked to select the default editor to be used with Git. (VIM, Notepad++, etc.). Select Visual Studio Code (assuming that this is the IDE that you plan to use for Nextflow).\n\n  ![Installing Git on Windows](/img/git-install.png)\n\n- The Git installer will prompt you for additional settings. If you are not sure, accept the defaults. When asked, adjust the `PATH` variable to use the recommended option, making the Git command line available from Git Bash, the Command Prompt, and PowerShell.\n\n- After installation Git Bash, Git GUI, and GIT CMD will appear as new entries under the Start menu. If you are running Git from PowerShell, you will need to open a new Windows to force PowerShell to reset the path variable. By default, Git installs in C:\\Program Files\\Git.\n\n- If you plan to use Git from the command line, GitHub provides a useful cheatsheet [here](https://training.github.com/downloads/github-git-cheat-sheet.pdf).\n\n- After installing Git, from within VS Code (in the context of the local host), select the Source Control icon from the left pane of the VS Code interface as shown. You can open local folders that contain a git repository or clone repositories from GitHub or your preferred source code management system.\n\n  ![Using Git within VS Code](/img/git-vscode.png)\n\n- Documentation on using Git with Visual Studio Code is provided at https://code.visualstudio.com/docs/editor/versioncontrol\n\n### Step 2: Install Git on Linux\n\n- Open a Remote VS Code Window on **\\*WSL: Ubuntu 20.04\\*** (By selecting the green icon on the lower-left corner of the VS code interface.)\n\n- Git should already be installed in `/usr/bin`, but you can validate this from the Ubuntu shell:\n\n  ```console\n  $ git --version\n  git version 2.25.1\n  ```\n\n- To get started using Git with VS Code Remote on WSL, select the _Source Control icon_ on the left panel of VS code. Assuming VS Code Remote detects that Git is installed on Linux, you should be able to _Clone a Repository_.\n\n- Select \"Clone Repository,\" and when prompted, clone the GitHub repo for the Blast example that we used earlier - https://github.com/nextflow-io/blast-example. Clone this repo into your home directory on Linux. You should see _blast-example_ appear as a source code repository within VS code as shown:\n\n  ![Using Git within VS Code](/img/git-linux-1.png)\n\n- Select the _Explorer_ panel in VS Code to see the cloned _blast-example_ repo. Now we can explore and modify the pipeline code using the IDE.\n\n  ![Using Git within VS Code](/img/git-linux-2.png)\n\n- After making modifications to the pipeline, we can execute the _local copy_ of the pipeline either from the Linux shell or directly via the Terminal window in VS Code as shown:\n\n  ![Using Git within VS Code](/img/git-linux-3.png)\n\n- With the Docker VS Code extension, users can select the Docker icon from the left code to view containers and images associated with the Nextflow pipeline.\n\n- Git commands are available from within VS Code by selecting the _Source Control_ icon on the left panel and selecting the three dots (…) to the right of SOURCE CONTROL. Some operations such as pushing or committing code will require that VS Code be authenticated with your GitHub credentials.\n\n  ![Using Git within VS Code](/img/git-linux-4.png)\n\n## Summary\n\nWith WSL2, Windows 10 is an excellent environment for developing and testing Nextflow pipelines. Users can take advantage of the power and convenience of a Linux command line environment while using Windows-based IDEs such as VS-Code with full support for containers.\n\nPipelines developed in the Windows environment can easily be extended to compute environments in the cloud.\n\nWhile installing Nextflow itself is straightforward, installing and testing necessary components such as WSL, Docker, an IDE, and Git can be a little tricky. Hopefully readers will find this guide helpful.\n</linux-environment></username></arrow>",
    "images": [],
    "author": "Evan Floden",
    "tags": "windows,learning"
  },
  {
    "slug": "2022/caching-behavior-analysis",
    "title": "Analyzing caching behavior of pipelines",
    "date": "2022-11-10T00:00:00.000Z",
    "content": "The ability to resume an analysis (i.e. caching) is one of the core strengths of Nextflow. When developing pipelines, this allows us to avoid re-running unchanged processes by simply appending `-resume` to the `nextflow run` command. Sometimes, tasks may be repeated for reasons that are unclear. In these cases it can help to look into the caching mechanism, to understand why a specific process was re-run.\n\nWe have previously written about Nextflow's [resume functionality](https://www.nextflow.io/blog/2019/demystifying-nextflow-resume.html) as well as some [troubleshooting strategies](https://www.nextflow.io/blog/2019/troubleshooting-nextflow-resume.html) to gain more insights on the caching behavior.\n\nIn this post, we will take a more hands-on approach and highlight some strategies which we can use to understand what is causing a particular process (or processes) to re-run, instead of using the cache from previous runs of the pipeline. To demonstrate the process, we will introduce a minor change into one of the process definitions in the the [nextflow-io/rnaseq-nf](https://github.com/nextflow-io/rnaseq-nf) pipeline and investigate how it affects the overall caching behavior when compared to the initial execution of the pipeline.\n\n### Local setup for the test\n\nFirst, we clone the [nextflow-io/rnaseq-nf](https://github.com/nextflow-io/rnaseq-nf) pipeline locally:\n\n```bash\n$ git clone https://github.com/nextflow-io/rnaseq-nf\n$ cd rnaseq-nf\n```\n\nIn the examples below, we have used Nextflow `v22.10.0`, Docker `v20.10.8` and `Java v17 LTS` on MacOS.\n\n### Pipeline flowchart\n\nThe flowchart below can help in understanding the design of the pipeline and the dependencies between the various tasks.\n\n![rnaseq-nf](/img/rnaseq-nf.base.png)\n\n### Logs from initial (fresh) run\n\nAs a reminder, Nextflow generates a unique task hash, e.g. 22/7548fa… for each task in a workflow. The hash takes into account the complete file path, the last modified timestamp, container ID, content of script directive among other factors. If any of these change, the task will be re-executed. Nextflow maintains a list of task hashes for caching and traceability purposes. You can learn more about task hashes in the article [Troubleshooting Nextflow resume](https://nextflow.io/blog/2019/troubleshooting-nextflow-resume.html).\n\nTo have something to compare to, we first need to generate the initial hashes for the unchanged processes in the pipeline. We save these in a file called `fresh_run.log` and use them later on as \"ground-truth\" for the analysis. In order to save the process hashes we use the `-dump-hashes` flag, which prints them to the log.\n\n**TIP:** We rely upon the [`-log` option](https://www.nextflow.io/docs/latest/cli.html#execution-logs) in the `nextflow` command line interface to be able to supply a custom log file name instead of the default `.nextflow.log`.\n\n```console\n$ nextflow -log fresh_run.log run ./main.nf -profile docker -dump-hashes\n\n[...truncated…]\nexecutor &gt;  local (4)\n[d5/57c2bb] process &gt; RNASEQ:INDEX (ggal_1_48850000_49020000) [100%] 1 of 1 ✔\n[25/433b23] process &gt; RNASEQ:FASTQC (FASTQC on ggal_gut)      [100%] 1 of 1 ✔\n[03/23372f] process &gt; RNASEQ:QUANT (ggal_gut)                 [100%] 1 of 1 ✔\n[38/712d21] process &gt; MULTIQC                                 [100%] 1 of 1 ✔\n[...truncated…]\n```\n\n### Edit the `FastQC` process\n\nAfter the initial run of the pipeline, we introduce a change in the `fastqc.nf` module, hard coding the number of threads which should be used to run the `FASTQC` process via Nextflow's [`cpus` directive](https://www.nextflow.io/docs/latest/process.html#cpus).\n\nHere's the output of `git diff` on the contents of `modules/fastqc/main.nf` file:\n\n```diff\n--- a/modules/fastqc/main.nf\n+++ b/modules/fastqc/main.nf\n@@ -4,6 +4,7 @@ process FASTQC {\n     tag \"FASTQC on $sample_id\"\n     conda 'bioconda::fastqc=0.11.9'\n     publishDir params.outdir, mode:'copy'\n+    cpus 2\n\n     input:\n     tuple val(sample_id), path(reads)\n@@ -13,6 +14,6 @@ process FASTQC {\n\n     script:\n     \"\"\"\n-    fastqc.sh \"$sample_id\" \"$reads\"\n+    fastqc.sh \"$sample_id\" \"$reads\" -t ${task.cpus}\n     \"\"\"\n }\n```\n\n### Logs from the follow up run\n\nNext, we run the pipeline again with the `-resume` option, which instructs Nextflow to rely upon the cached results from the previous run and only run the parts of the pipeline which have changed. As before, we instruct Nextflow to dump the process hashes, this time in a file called `resumed_run.log`.\n\n```console\n$ nextflow -log resumed_run.log run ./main.nf -profile docker -dump-hashes -resume\n\n[...truncated…]\nexecutor &gt;  local\n[d5/57c2bb] process &gt; RNASEQ:INDEX (ggal_1_48850000_49020000) [100%] 1 of 1, cached: 1 ✔\n[55/15b609] process &gt; RNASEQ:FASTQC (FASTQC on ggal_gut)      [100%] 1 of 1 ✔\n[03/23372f] process &gt; RNASEQ:QUANT (ggal_gut)                 [100%] 1 of 1, cached: 1 ✔\n[f3/f1ccb4] process &gt; MULTIQC                                 [100%] 1 of 1 ✔\n[...truncated…]\n```\n\n## Analysis of cache hashes\n\nFrom the summary of the command line output above, we can see that the `RNASEQ:FASTQC (FASTQC on ggal_gut)` and `MULTIQC` processes were re-run while the others were cached. To understand why, we can examine the hashes generated by the processes from the logs of the `fresh_run` and `resumed_run`.\n\nFor the analysis, we need to keep in mind that:\n\n1. The time-stamps are expected to differ and can be safely ignored to narrow down the `grep` pattern to the Nextflow `TaskProcessor` class.\n\n2. The _order_ of the log entries isn't fixed, due to the nature of the underlying parallel computation dataflow model used by Nextflow. For example, in our example below, `FASTQC` ran first in `fresh_run.log` but wasn’t the first logged process in `resumed_run.log`.\n\n### Find the process level hashes\n\nWe can use standard Unix tools like `grep`, `cut` and `sort` to address these points and filter out the relevant information:\n\n1. Use `grep` to isolate log entries with `cache hash` string\n2. Remove the prefix time-stamps using `cut -d ‘-’ -f 3`\n3. Remove the caching mode related information using `cut -d ';' -f 1`\n4. Sort the lines based on process names using `sort` to have a standard order before comparison\n5. Use `tee` to print the resultant strings to the terminal and simultaneously save to a file\n\nNow, let’s apply these transformations to the `fresh_run.log` as well as `resumed_run.log` entries.\n\n- `fresh_run.log`\n\n```console\n$ cat ./fresh_run.log | grep 'INFO.*TaskProcessor.*cache hash' | cut -d '-' -f 3 | cut -d ';' -f 1 | sort | tee  ./fresh_run.tasks.log\n\n [MULTIQC] cache hash: 167d7b39f7efdfc49b6ff773f081daef\n [RNASEQ:FASTQC (FASTQC on ggal_gut)] cache hash: 47e8c58d92dbaafba3c2ccc4f89f53a4\n [RNASEQ:INDEX (ggal_1_48850000_49020000)] cache hash: ac8be293e1d57f3616cdd0adce34af6f\n [RNASEQ:QUANT (ggal_gut)] cache hash: d8b88e3979ff9fe4bf64b4e1bfaf4038\n```\n\n- `resumed_run.log`\n\n```console\n$ cat ./resumed_run.log | grep 'INFO.*TaskProcessor.*cache hash' | cut -d '-' -f 3 | cut -d ';' -f 1 | sort | tee  ./resumed_run.tasks.log\n\n [MULTIQC] cache hash: d3f200c56cf00b223282f12f06ae8586\n [RNASEQ:FASTQC (FASTQC on ggal_gut)] cache hash: 92478eeb3b0ff210ebe5a4f3d99aed2d\n [RNASEQ:INDEX (ggal_1_48850000_49020000)] cache hash: ac8be293e1d57f3616cdd0adce34af6f\n [RNASEQ:QUANT (ggal_gut)] cache hash: d8b88e3979ff9fe4bf64b4e1bfaf4038\n```\n\n### Inference from process top-level hashes\n\nComputing a hash is a multi-step process and various factors contribute to it such as the inputs of the process, platform, time-stamps of the input files and more ( as explained in [Demystifying Nextflow resume](https://www.nextflow.io/blog/2019/demystifying-nextflow-resume.html) blog post) . The change we made in the task level CPUs directive and script section of the `FASTQC` process triggered a re-computation of hashes:\n\n```diff\n--- ./fresh_run.tasks.log\n+++ ./resumed_run.tasks.log\n@@ -1,4 +1,4 @@\n- [MULTIQC] cache hash: dccabcd012ad86e1a2668e866c120534\n- [RNASEQ:FASTQC (FASTQC on ggal_gut)] cache hash: 94be8c84f4bed57252985e6813bec401\n+ [MULTIQC] cache hash: c5a63560338596282682cc04ff97e436\n+ [RNASEQ:FASTQC (FASTQC on ggal_gut)] cache hash: 54aa712db7c8248e7f31d5fb6535ff9d\n  [RNASEQ:INDEX (ggal_1_48850000_49020000)] cache hash: 356aaa7524fb071f258480ba07c67b3c\n  [RNASEQ:QUANT (ggal_gut)] cache hash: 169ced0fc4b047eaf91cd31620b22540\n\n```\n\nEven though we only introduced changes in `FASTQC`, the `MULTIQC` process was re-run since it relies upon the output of the `FASTQC` process. Any task that has its cache hash invalidated triggers a rerun of all downstream steps:\n\n![rnaseq-nf after modification](/img/rnaseq-nf.modified.png)\n\n### Understanding why `FASTQC` was re-run\n\nWe can see the full list of `FASTQC` process hashes within the `fresh_run.log` file\n\n```console\n\n[...truncated…]\nNov-03 20:19:13.827 [Actor Thread 6] INFO  nextflow.processor.TaskProcessor - [RNASEQ:FASTQC (FASTQC on ggal_gut)] cache hash: 54aa712db7c8248e7f31d5fb6535ff9d; mode: STANDARD; entries:\n  1a0e496fef579b22998f099981b494f9 [java.util.UUID] a11bf24f-638a-42d6-8b50-48d3be637d54\n  195c7faea83c75f2340eb710d8486d2a [java.lang.String] RNASEQ:FASTQC\n  2bea0eee5e384bd6082a173772e939eb [java.lang.String] \"\"\"\n    fastqc.sh \"$sample_id\" \"$reads\" -t ${task.cpus}\n    \"\"\"\n\n  8e58c0cec3bde124d5d932c7f1579395 [java.lang.String] quay.io/nextflow/rnaseq-nf:v1.1\n  7ec7cbd71ff757f5fcdbaa760c9ce6de [java.lang.String] sample_id\n  16b4905b1545252eb7cbfe7b2a20d03d [java.lang.String] ggal_gut\n  553096c532e666fb42214fdf0520fe4a [java.lang.String] reads\n  6a5d50e32fdb3261e3700a30ad257ff9 [nextflow.util.ArrayBag] [FileHolder(sourceObj:/home/abhinav/rnaseq-nf/data/ggal/ggal_gut_1.fq, storePath:/home/abhinav/rnaseq-nf/data/ggal/ggal_gut_1.fq, stageName:ggal_gut_1.fq), FileHolder(sourceObj:/home/abhinav/rnaseq-nf/data/ggal/ggal_gut_2.fq, storePath:/home/abhinav/rnaseq-nf/data/ggal/ggal_gut_2.fq, stageName:ggal_gut_2.fq)]\n  4f9d4b0d22865056c37fb6d9c2a04a67 [java.lang.String] $\n  16fe7483905cce7a85670e43e4678877 [java.lang.Boolean] true\n  80a8708c1f85f9e53796b84bd83471d3 [java.util.HashMap$EntrySet] [task.cpus=2]\n  f46c56757169dad5c65708a8f892f414 [sun.nio.fs.UnixPath] /home/abhinav/rnaseq-nf/bin/fastqc.sh\n[...truncated…]\n\n```\n\nWhen we isolate and compare the log entries for `FASTQC` between `fresh_run.log` and `resumed_run.log`, we see the following diff:\n\n```diff\n--- ./fresh_run.fastqc.log\n+++ ./resumed_run.fastqc.log\n@@ -1,8 +1,8 @@\n-INFO  nextflow.processor.TaskProcessor - [RNASEQ:FASTQC (FASTQC on ggal_gut)] cache hash: 94be8c84f4bed57252985e6813bec401; mode: STANDARD; entries:\n+INFO  nextflow.processor.TaskProcessor - [RNASEQ:FASTQC (FASTQC on ggal_gut)] cache hash: 54aa712db7c8248e7f31d5fb6535ff9d; mode: STANDARD; entries:\n   1a0e496fef579b22998f099981b494f9 [java.util.UUID] a11bf24f-638a-42d6-8b50-48d3be637d54\n   195c7faea83c75f2340eb710d8486d2a [java.lang.String] RNASEQ:FASTQC\n-  43e5a23fc27129f92a6c010823d8909b [java.lang.String] \"\"\"\n-    fastqc.sh \"$sample_id\" \"$reads\"\n+  2bea0eee5e384bd6082a173772e939eb [java.lang.String] \"\"\"\n+    fastqc.sh \"$sample_id\" \"$reads\" -t ${task.cpus}\n\n```\n\nObservations from the diff:\n\n1. We can see that the content of the script has changed, highlighting the new `$task.cpus` part of the command.\n2. There is a new entry in the `resumed_run.log` showing that the content of the process level directive `cpus` has been added.\n\nIn other words, the diff from log files is confirming our edits.\n\n### Understanding why `MULTIQC` was re-run\n\nNow, we apply the same analysis technique for the `MULTIQC` process in both log files:\n\n```diff\n--- ./fresh_run.multiqc.log\n+++ ./resumed_run.multiqc.log\n@@ -1,4 +1,4 @@\n-INFO  nextflow.processor.TaskProcessor - [MULTIQC] cache hash: dccabcd012ad86e1a2668e866c120534; mode: STANDARD; entries:\n+INFO  nextflow.processor.TaskProcessor - [MULTIQC] cache hash: c5a63560338596282682cc04ff97e436; mode: STANDARD; entries:\n   1a0e496fef579b22998f099981b494f9 [java.util.UUID] a11bf24f-638a-42d6-8b50-48d3be637d54\n   cd584abbdbee0d2cfc4361ee2a3fd44b [java.lang.String] MULTIQC\n   56bfc44d4ed5c943f30ec98b22904eec [java.lang.String] \"\"\"\n@@ -9,8 +9,9 @@\n\n   8e58c0cec3bde124d5d932c7f1579395 [java.lang.String] quay.io/nextflow/rnaseq-nf:v1.1\n   14ca61f10a641915b8c71066de5892e1 [java.lang.String] *\n-  cd0e6f1a382f11f25d5cef85bd87c3f4 [nextflow.util.ArrayBag] [FileHolder(sourceObj:/home/abhinav/rnaseq-nf/work/03/23372f156e80deb4d7183c5f509274/ggal_gut, storePath:/home/abhinav/rnaseq-nf/work/03/23372f156e80deb4d7183c5f509274/ggal_gut, stageName:ggal_gut), FileHolder(sourceObj:/home/abhinav/rnaseq-nf/work/25/433b23af9e98294becade95db6bd76/fastqc_ggal_gut_logs, storePath:/home/abhinav/rnaseq-nf/work/25/433b23af9e98294becade95db6bd76/fastqc_ggal_gut_logs, stageName:fastqc_ggal_gut_logs)]\n+  18966b473f7bdb07f4f7f4c8445be1f5 [nextflow.util.ArrayBag] [FileHolder(sourceObj:/home/abhinav/rnaseq-nf/work/03/23372f156e80deb4d7183c5f509274/ggal_gut, storePath:/home/abhinav/rnaseq-nf/work/03/23372f156e80deb4d7183c5f509274/ggal_gut, stageName:ggal_gut), FileHolder(sourceObj:/home/abhinav/rnaseq-nf/work/55/15b60995682daf79ecb64bcbb8e44e/fastqc_ggal_gut_logs, storePath:/home/abhinav/rnaseq-nf/work/55/15b60995682daf79ecb64bcbb8e44e/fastqc_ggal_gut_logs, stageName:fastqc_ggal_gut_logs)]\n   d271b8ef022bbb0126423bf5796c9440 [java.lang.String] config\n   5a07367a32cd1696f0f0054ee1f60e8b [nextflow.util.ArrayBag] [FileHolder(sourceObj:/home/abhinav/rnaseq-nf/multiqc, storePath:/home/abhinav/rnaseq-nf/multiqc, stageName:multiqc)]\n   4f9d4b0d22865056c37fb6d9c2a04a67 [java.lang.String] $\n   16fe7483905cce7a85670e43e4678877 [java.lang.Boolean] true\n```\n\nHere, the highlighted diffs show the directory of the input files, changing as a result of `FASTQC` being re-run; as a result `MULTIQC` has a new hash and has to be re-run as well.\n\n## Conclusion\n\nDebugging the caching behavior of a pipeline can be tricky, however a systematic analysis can help to uncover what is causing a particular process to be re-run.\n\nWhen analyzing large datasets, it may be worth using the `-dump-hashes` option by default for all pipeline runs, avoiding needing to run the pipeline again to obtain the hashes in the log file in case of problems.\n\nWhile this process works, it is not trivial. We would love to see some community-driven tooling for a better cache-debugging experience for Nextflow, perhaps an `nf-cache` plugin? Stay tuned for an upcoming blog post describing how to extend and add new functionality to Nextflow using plugins.",
    "images": [],
    "author": "Abhinav Sharma",
    "tags": "nextflow,cache"
  },
  {
    "slug": "2022/czi-mentorship-round-1",
    "title": "Nextflow and nf-core mentorship, Round 1",
    "date": "2022-09-18T00:00:00.000Z",
    "content": "## Introduction\n\n<div class=\"pull-right\" style=\" max-width: 350px; border: 1px solid #ededed; margin-left: 2rem; padding: 2rem;\">\n    <img src=\"/img/mentorships-round1-wordcloud.png\" alt=\"Word cloud\">\n    \n\n*Word cloud of scientific interest keywords, averaged across all applications.*\n\n</div>\n\nOur recent [The State of the Workflow 2022: Community Survey Results](https://seqera.io/blog/state-of-the-workflow-2022-results/) showed that Nextflow and nf-core have a strong global community with a high level of engagement in several countries. As the community continues to grow, we aim to prioritize inclusivity for everyone through active outreach to groups with low representation.\n\nThanks to funding from our Chan Zuckerberg Initiative Diversity and Inclusion grant we established an international Nextflow and nf-core mentoring program with the aim of empowering those from underrepresented groups. With the first round of the mentorship now complete, we look back at the success of the program so far.\n\nFrom almost 200 applications, five pairs of mentors and mentees were selected for the first round of the program. Over the following four months they met weekly to work on Nextflow based projects. We attempted to pair mentors and mentees based on their time zones and scientific interests. Project tasks were left up to the individuals and so tailored to the mentee's scientific interests and schedules.\n\nPeople worked on things ranging from setting up Nextflow and nf-core on their institutional clusters to developing and implementing Nextflow and nf-core pipelines for next-generation sequencing data. Impressively, after starting the program knowing very little about Nextflow and nf-core, mentees finished the program being able to confidently develop and implement scalable and reproducible scientific workflows.\n\n![Map of mentor / mentee pairs](/img/mentorships-round1-map.png)<br>\n_The mentorship program was worldwide._\n\n## Ndeye Marième Top (mentee) &amp; John Juma (mentor)\n\nFor the mentorship, Marième wanted to set up Nextflow and nf-core on the servers at the Institut Pasteur de Dakar in Senegal and learn how to develop / contribute to a pipeline. Her mentor was John Juma, from the ILRI/SANBI in Kenya.\n\nTogether, Marème overcame issues with containers and server privileges and developed her local config, learning about how to troubleshoot and where to find help along the way. By the end of the mentorship she was able to set up the [nf-core/viralrecon](https://nf-co.re/viralrecon) pipeline for the genomic surveillance analysis of SARS-Cov2 sequencing data from Senegal as well as 17 other countries in West Africa, ready for submission to [GISAID](https://gisaid.org/). She also got up to speed with the [nf-core/mag](https://nf-co.re/mag) pipeline for metagenomic analysis.\n\n&gt; *\"Having someone experienced who can guide you in my learning process. My mentor really helped me understand and focus on the practical aspects since my main concern was having the pipelines correctly running in my institution.\"* - Marième Top (mentee)\n\n&gt; *\"The program was awesome. I had a chance to impart nextflow principles to someone I have never met before. Fully virtual, the program instilled some sense of discipline in terms of setting and meeting objectives.\"* - John Juma (mentor)\n\n## Philip Ashton (mentee) &amp; Robert Petit (mentor)\n\nPhilip wanted to move up the Nextflow learning curve and set up nf-core workflows at Kamuzu University of Health Sciences in Malawi. His mentor was Robert Petit from the Wyoming Public Health Laboratory in the USA. Robert has developed the [Bactopia](https://bactopia.github.io/) pipeline for the analysis of bacterial pipeline and it was Philip’s aim to get this running for his group in Malawi.\n\nRobert helped Philip learn Nextflow, enabling him to independently deploy DSL2 pipelines and process genomes using Nextflow Tower. Philip is already using his new found skills to answer important public health questions in Malawi and is now passing his knowledge to other staff and students at his institute. Even though the mentorship program has finished, Philip and Rob will continue a collaboration and have plans to deploy pipelines that will benefit public health in the future.\n\n&gt; *\"I tried to learn nextflow independently some time ago, but abandoned it for the more familiar snakemake. Thanks to Robert’s mentorship I’m now over the learning curve and able to deploy nf-core pipelines and use cloud resources more efficiently via Nextflow Tower\"* - Phil Ashton (mentee)\n\n&gt; *\"I found being a mentor to be a rewarding experience and a great opportunity to introduce mentees into the Nextflow/nf-core community. Phil and I were able to accomplish a lot in the span of a few months, and now have many plans to collaborate in the future.\"* - Robert Petit (mentor)\n\n## Kalayanee Chairat (mentee) &amp; Alison Meynert (mentor)\n\nKalayanee’s goal for the mentorship program was to set up and run Nextflow and nf-core pipelines at the local infrastructure at the King Mongkut’s University of Technology Thonburi in Thailand. Kalayanee was mentored by Alison Meynert, from the University of Edinburgh in the United Kingdom.\n\nWorking with Alison, Kalayanee learned about Nextflow and nf-core and the requirements for working with Slurm and Singularity. Together, they created a configuration profile that Kalayanee and others at her institute can use - they have plans to submit this to [nf-core/configs](https://github.com/nf-core/configs) as an institutional profile. Now she is familiar with these tools, Kalayanee is using [nf-core/sarek](https://nf-co.re/sarek) and [nf-core/rnaseq](https://nf-co.re/rnaseq) to analyze 100s of samples of her own next-generation sequencing data on her local HPC environment.\n\n&gt; *\"The mentorship program is a great start to learn to use and develop analysis pipelines built using Nextflow. I gained a lot of knowledge through this program. I am also very lucky to have Dr. Alison Meynert as my mentor. She is very knowledgeable, kind and willing to help in every step.\"* - Kalayanee Chairat (mentee)\n\n&gt; *\"It was a great experience for me to work with my mentee towards her goal. The process solidified some of my own topical knowledge and I learned new things along the way as well.\"* - Alison Meynert (mentor)\n\n## Edward Lukyamuzi (mentee) &amp; Emilio Garcia-Rios (mentor)\n\nFor the mentoring program Edward’s goal was to understand the fundamental components of a Nextflow script and write a Nextflow pipeline for analyzing mosquito genomes. Edward was mentored by Emilio Garcia-Rios, from the EMBL-EBI in the United Kingdom.\n\nEdward learned the fundamental concepts of Nextflow, including channels, processes and operators. Edward works with sequencing data from the mosquito genome - with help from Emilio he wrote a Nextflow pipeline with an accompanying Dockerfile for the alignment of reads and genotyping of SNPs. Edward will continue to develop his pipeline and wants to become more involved with the Nextflow and nf-core community by attending the nf-core hackathons. Edward is also very keen to help others learn Nextflow and expressed an interest in being part of this program again as a mentor.\n\n&gt; *\"Learning Nextflow can be a steep curve. Having a partner to give you a little push might be what facilitates adoption of Nextflow into your daily routine.\"* - Edward Lukyamuzi (mentee)\n\n&gt; *\"I would like more people to discover and learn the benefits using Nextflow has. Being a mentor in this program can help me collaborate with other colleagues and be a mentor in my institute as well.\"* - Emilio Garcia-Rios (mentor)\n\n## Suchitra Thapa (mentee) &amp; Maxime Borry (mentor)\n\nSuchitra started the program to learn about running Nextflow pipelines but quickly moved on to pipeline development and deployment on the cloud. Suchitra and Maxime encountered some technical challenges during the mentorship, including difficulties with internet connectivity and access to computational platforms for analysis. Despite this, with help from Maxime, Suchitra applied her newly acquired skills and made substantial progress converting the [metaphlankrona](https://github.com/suchitrathapa/metaphlankrona) pipeline for metagenomic analysis of microbial communities from Nextflow DSL1 to DSL2 syntax.\n\nSuchitra will be sharing her work and progress on the pipeline as a poster at the [Nextflow Summit 2022](https://summit.nextflow.io/speakers/suchitra-thapa/).\n\n&gt; *\"This mentorship was one of the best organized online learning opportunities that I have attended so far. With time flexibility and no deadline burden, you can easily fit this mentorship into your busy schedule. I would suggest everyone interested to definitely go for it.\"* - Suchitra Thapa (mentee)\n\n&gt; *\"This mentorship program was a very fruitful and positive experience, and the satisfaction to see someone learning and growing their bioinformatics skills is very rewarding.\"* - Maxime Borry (mentor)\n\n## Conclusion\n\nFeedback from the first round of the mentorship program was overwhelmingly positive. Both mentors and mentees found the experience to be a rewarding opportunity and were grateful for taking part. Everyone who participated in the program said that they would encourage others to be a part of it in the future.\n\n&gt; \"This is an exciting program that can help us make use of curated pipelines to advance open science. I don't mind repeating the program!\" - John Juma (mentor)\n\n![Screenshot of final zoom meetup](/img/mentorships-round1-zoom.png)\n\nAs the Nextflow and nf-core communities continue to grow, the mentorship program will have long-term benefits beyond those that are immediately measurable. Mentees from the program are already acting as positive role models and contributing new perspectives to the wider community. Additionally, some mentees are interested in being mentors in the future and will undoubtedly support others as our communities continue to grow.\n\nWe were delighted with the high quality of this year’s mentors and mentees. Stay tuned for information about the next round of the Nextflow and nf-core mentorship program. Applications for round 2 will open on October 1, 2022. See [https://nf-co.re/mentorships](https://nf-co.re/mentorships) for details.\n\n[Mentorship Round 2 - Details](https://nf-co.re/mentorships)",
    "images": [
      "/img/mentorships-round1-wordcloud.png"
    ],
    "author": "Chris Hakkaart",
    "tags": "nextflow,nf-core,czi,mentorship,training"
  },
  {
    "slug": "2022/deploy-nextflow-pipelines-with-google-cloud-batch",
    "title": "Deploy Nextflow Pipelines with Google Cloud Batch!",
    "date": "2022-07-13T00:00:00.000Z",
    "content": "A key feature of Nextflow is the ability to abstract the implementation of data analysis pipelines so they can be deployed in a portable manner across execution platforms.\n\nAs of today, Nextflow supports a rich variety of HPC schedulers and all major cloud providers. Our goal is to support new services as they emerge to enable Nextflow users to take advantage of the latest technology and deploy pipelines on the compute environments that best fit their requirements.\n\nFor this reason, we are delighted to announce that Nextflow now supports [Google Cloud Batch](https://cloud.google.com/batch), a new fully managed batch service just announced for beta availability by Google Cloud.\n\n### A New On-Ramp to the Google Cloud\n\nGoogle Cloud Batch is a comprehensive cloud service suitable for multiple use cases, including HPC, AI/ML, and data processing. While it is similar to the Google Cloud Life Sciences API, used by many Nextflow users today, Google Cloud Batch offers a broader set of capabilities. As with Google Cloud Life Sciences, Google Cloud Batch automatically provisions resources, manages capacity, and allows batch workloads to run at scale. It offers several advantages, including:\n\n- The ability to re-use VMs across jobs steps to reduce overhead and boost performance.\n- Granular control over task execution, compute, and storage resources.\n- Infrastructure, application, and task-level logging.\n- Improved task parallelization, including support for multi-node MPI jobs, with support for array jobs, and subtasks.\n- Improved support for spot instances, which provides a significant cost saving when compared to regular instance.\n- Streamlined data handling and provisioning.\n\nA nice feature of Google Cloud Batch API, that fits nicely with Nextflow, is its built-in support for data ingestion from Google Cloud Storage buckets. A batch job can _mount_ a storage bucket and make it directly accessible to a container running a Nextflow task. This feature makes data ingestion and sharing resulting data sets more efficient and reliable than other solutions.\n\n### Getting started with Google Cloud Batch\n\nSupport for the Google Cloud Batch requires the latest release of Nextflow from the edge channel (version `22.07.1-edge` or later). If you don't already have it, you can install this release using these commands:\n\n```\nexport NXF_EDGE=1\ncurl get.nextflow.io | bash\n./nextflow -self-update\n```\n\nMake sure your Google account is allowed to access the Google Cloud Batch service by checking the [API &amp; Service](https://console.cloud.google.com/apis/dashboard) dashboard.\n\nCredentials for accessing the service are picked up by Nextflow from your environment using the usual [Google Application Default Credentials](https://github.com/googleapis/google-auth-library-java#google-auth-library-oauth2-http) mechanism. That is, either via the `GOOGLE_APPLICATION_CREDENTIALS` environment variable, or by using the following command to set up the environment:\n\n```\ngcloud auth application-default login\n```\n\nAfter authenticating yourself to Google Cloud, create a `nextflow.config` file and specify `google-batch` as the Nextflow executor. You will also need to specify the Google Cloud project where execution will occur and the Google Cloud Storage working directory for pipeline execution.\n\n```\ncat &lt;<eot> nextflow.config\nprocess.executor = 'google-batch'\nworkDir = 'gs://YOUR-GOOGLE-BUCKET/scratch'\ngoogle.project = 'YOUR GOOGLE PROJECT ID'\nEOT\n```\n\nIn the above snippet replace `<your_google_bucket>` with a Google Storage bucket of your choice where to store the pipeline output data and `<your_google_project_id>` with your Google project Id where the computation will be deployed.\n\nWith this information, you are ready to start. You can verify that the integration is working by running the Nextflow “hello” pipeline as shown below:\n\n```\nnextflow run https://github.com/nextflow-io/hello\n```\n\n### Migrating Google Cloud Life Sciences pipelines to Google Cloud Batch\n\nGoogle Cloud Life Sciences users can easily migrate their pipelines to Google Cloud Batch by making just a few edits to their pipeline configuration settings. Simply replace the `google-lifesciences` executor with `google-batch`.\n\nFor each setting having the prefix `google.lifeScience.`, there is a corresponding `google.batch.` setting. Simply update these configuration settings to reflect the new service.\n\nThe usual process directives such as: [cpus](https://www.nextflow.io/docs/latest/process.html#cpus), [memory](https://www.nextflow.io/docs/latest/process.html#memory), [time](https://www.nextflow.io/docs/latest/process.html#time), [machineType](https://www.nextflow.io/docs/latest/process.html#machinetype) are natively supported by Google Cloud Batch, and should not be modified.\n\nFind out more details in the [Nextflow documentation](https://www.nextflow.io/docs/edge/google.html#cloud-batch).\n\n### 100% Open, Built to Scale\n\nThe Google Cloud Batch executor for Nextflow is offered as an open source contribution to the Nextflow project. The integration was developed by Google in collaboration with [Seqera Labs](https://seqera.io/). This is a validation of Google Cloud’s ongoing commitment to open source software (OSS) and a testament to the health and vibrancy of the Nextflow project. We wish to thank the entire Google Cloud Batch team, and Shamel Jacobs in particular, for their support of this effort.\n\n### Conclusion\n\nSupport for Google Cloud Batch further expands the wide range of computing platforms supported by Nextflow. It empowers Nextflow users to easily access cost-effective resources, and take full advantage of the rich capabilities of the Google Cloud. Above all, it enables researchers to easily scale and collaborate, improving their productivity, and resulting in better research outcomes.\n</your_google_project_id></your_google_bucket></eot>",
    "images": [],
    "author": "Paolo Di Tommaso",
    "tags": "nextflow,google,cloud"
  },
  {
    "slug": "2022/evolution-of-nextflow-runtime",
    "title": "Evolution of the Nextflow runtime",
    "date": "2022-03-24T00:00:00.000Z",
    "content": "Software development is a constantly evolving process that requires continuous adaptation to keep pace with new technologies, user needs, and trends. Likewise, changes are needed in order to introduce new capabilities and guarantee a sustainable development process.\n\nNextflow is no exception. This post will summarise the major changes in the evolution of the framework over the next 12 to 18 months.\n\n### Java baseline version\n\nNextflow runs on top of Java (or, more precisely, the Java virtual machine). So far, Java 8 has been the minimal version required to run Nextflow. However, this version was released 8 years ago and is going to reach its end-of-life status at the end of [this month](https://endoflife.date/java). For this reason, as of version 22.01.x-edge and the upcoming stable release 22.04.0, Nextflow will require Java version 11 or later for its execution. This also allows the introduction of new capabilities provided by the modern Java runtime.\n\nTip: If you are confused about how to install or upgrade Java on your computer, consider using [Sdkman](https://sdkman.io/). It’s a one-liner install tool that allows easy management of Java versions.\n\n### DSL2 as default syntax\n\nNextflow DSL2 has been introduced nearly [2 years ago](https://www.nextflow.io/blog/2020/dsl2-is-here.html) (how time flies!) and definitely represented a major milestone for the project. Established pipeline collections such as those in [nf-core](https://nf-co.re/pipelines) have migrated their pipelines to DSL2 syntax.\n\nThis is a confirmation that the DSL2 syntax represents a natural evolution for the project and is not considered to be just an experimental or alternative syntax.\n\nFor this reason, as for Nextflow version 22.03.0-edge and the upcoming 22.04.0 stable release, DSL2 syntax is going to be the **default** syntax version used by Nextflow, if not otherwise specified.\n\nIn practical terms, this means it will no longer be necessary to add the declaration `nextflow.enable.dsl = 2` at the top of your script or use the command line option `-dsl2 ` to enable the use of this syntax.\n\nIf you still want to continue to use DSL1 for your pipeline scripts, you will need to add the declaration `nextflow.enable.dsl = 1` at the top of your pipeline script or use the command line option `-dsl1`.\n\nTo make this transition as smooth as possible, we have also added the possibility to declare the DSL version in the Nextflow configuration file, using the same syntax shown above.\n\nFinally, if you wish to keep the current DSL behaviour and not make any changes in your pipeline scripts, the following variable can be defined in your system environment:\n\n```\nexport NXF_DEFAULT_DSL=1\n```\n\n### DSL1 end-of-life phase\n\nMaintaining two separate DSL implementations in the same programming environment is not sustainable and, above all, does not make much sense. For this reason, along with making DSL2 the default Nextflow syntax, DSL1 will enter into a 12-month end-of-life phase, at the end of which it will be removed. Therefore version 22.04.x and 22.10.x will be the last stable versions providing the ability to run DSL1 scripts.\n\nThis is required to keep evolving the framework and to create a more solid implementation of Nextflow grammar. Maintaining compatibility with the legacy syntax implementation and data structures is a challenging task that prevents the evolution of the new syntax.\n\nBear in mind, this does **not** mean it will not be possible to use DSL1 starting from 2023. All existing Nextflow runtimes will continue to be available, and it will be possible to for any legacy pipeline to run using the required version available from the GitHub [releases page](https://github.com/nextflow-io/nextflow/releases), or by specifying the version using the NXF_VER variable, e.g.\n\n```\nNXF_VER: 21.10.6 nextflow run <my dsl1=\"\" pipeline=\"\">\n```\n\n### New configuration format\n\nThe configuration file is a key component of the Nextflow framework since it allows workflow developers to decouple the pipeline logic from the execution parameters and infrastructure deployment settings.\n\nThe current Nextflow configuration file mechanism is extremely powerful, but it also has some serious drawbacks due to its _dynamic_ nature that makes it very hard to keep stable and maintainable over time.\n\nFor this reason, we are planning to re-engineer the current configuration component and replace it with a better configuration component with two major goals: 1) continue to provide a rich and human-readable configuration system (so, no YAML or JSON), 2) have a well-defined syntax with a solid foundation that guarantees predictable configurations, simpler troubleshooting and more sustainable maintenance.\n\nCurrently, the most likely options are [Hashicorp HCL](https://github.com/hashicorp/hcl) (as used by Terraform and other Hashicorp tools) and [Lightbend HOCON](https://github.com/lightbend/config). You can read more about this feature at [this link](https://github.com/nextflow-io/nextflow/issues/2723).\n\n### Ignite executor deprecation\n\nThe executor for [Apache Ignite](https://www.nextflow.io/docs/latest/ignite.html) was an early attempt to provide Nextflow with a self-contained, distributed cluster for the deployment of pipelines into HPC environments. However, it had very little adoption over the years, which was not balanced by the increasing complexity of its maintenance.\n\nFor this reason, it was decided to deprecate it and remove it from the default Nextflow distribution. The module is still available in the form of a separate project plugin and available at [this link](https://github.com/nextflow-io/nf-ignite), however, it will not be actively maintained.\n\n### Conclusion\n\nThis post is focused on the most fundamental changes we are planning to make in the following months.\n\nWith the adoption of Java 11, the full migration of DSL1 to DSL2 and the re-engineering of the configuration system, our purpose is to consolidate the Nextflow technology and lay the foundation for all the new exciting developments and features on which we are working on. Stay tuned for future blogs about each of them in upcoming posts.\n\nIf you want to learn more about the upcoming changes reach us out on [Slack at this link](https://app.slack.com/client/T03L6DM9G).\n</my>",
    "images": [],
    "author": "Paolo Di Tommaso",
    "tags": "nextflow,dsl2"
  },
  {
    "slug": "2022/learn-nextflow-in-2022",
    "title": "Learning Nextflow in 2022",
    "date": "2022-01-21T00:00:00.000Z",
    "content": "A lot has happened since we last wrote about how best to learn Nextflow, over a year ago. Several new resources have been released including a new Nextflow [Software Carpentries](https://carpentries-incubator.github.io/workflows-nextflow/index.html) course and an excellent write-up by [23andMe](https://medium.com/23andme-engineering/introduction-to-nextflow-4d0e3b6768d1).\n\nWe have collated some links below from a diverse collection of resources to help you on your journey to learn Nextflow. Nextflow is a community-driven project - if you have any suggestions, please make a pull request to [this page on GitHub](https://github.com/nextflow-io/website/tree/master/content/blog/2022/learn-nextflow-in-2022.md).\n\nWithout further ado, here is the definitive guide for learning Nextflow in 2022. These resources will support anyone in the journey from total beginner to Nextflow expert.\n\n### Prerequisites\n\nBefore you start writing Nextflow pipelines, we recommend that you are comfortable with using the command-line and understand the basic concepts of scripting languages such as Python or Perl. Nextflow is widely used for bioinformatics applications, and scientific data analysis. The examples and guides below often focus on applications in these areas. However, Nextflow is now adopted in a number of data-intensive domains such as image analysis, machine learning, astronomy and geoscience.\n\n### Time commitment\n\nWe estimate that it will take at least 20 hours to complete the material. How quickly you finish will depend on your background and how deep you want to dive into the content. Most of the content is introductory but there are some more advanced dataflow and configuration concepts outlined in the workshop and pattern sections.\n\n### Contents\n\n- Why learn Nextflow?\n- Introduction to Nextflow from 23andMe\n- An RNA-Seq hands-on tutorial\n- Nextflow workshop from Seqera Labs\n- Software Carpentries Course\n- Managing Pipelines in the Cloud\n- The nf-core tutorial\n- Advanced implementation patterns\n- Awesome Nextflow\n- Further resources\n\n### 1. Why learn Nextflow?\n\nNextflow is an open-source workflow framework for writing and scaling data-intensive computational pipelines. It is designed around the Linux philosophy of simple yet powerful command-line and scripting tools that, when chained together, facilitate complex data manipulations. Combined with support for containerization, support for major cloud providers and on-premise architectures, Nextflow simplifies the writing and deployment of complex data pipelines on any infrastructure.\n\nThe following are some high-level motivations on why people choose to adopt Nextflow:\n\n1. Integrating Nextflow in your analysis workflows helps you implement **reproducible** pipelines. Nextflow pipelines follow FAIR guidelines with version-control and containers to manage all software dependencies.\n2. Avoid vendor lock-in by ensuring portability. Nextflow is **portable**; the same pipeline written on a laptop can quickly scale to run on an HPC cluster, Amazon and Google cloud services, and Kubernetes. The code stays constant across varying infrastructures allowing collaboration and avoiding lock-in.\n3. It is **scalable** allowing the parallelization of tasks using the dataflow paradigm without having to hard-code the pipeline to a specific platform architecture.\n4. It is **flexible** and supports scientific workflow requirements like caching processes to prevent re-computation, and workflow reports to better understand the workflows’ executions.\n5. It is **growing fast** and has **long-term support** available from Seqera Labs. Developed since 2013 by the same team, the Nextflow ecosystem is expanding rapidly.\n6. It is **open source** and licensed under Apache 2.0. You are free to use it, modify it and distribute it.\n\n### 2. Introduction to Nextflow by 23andMe\n\nThis informative post begins with the basic concepts of Nextflow and builds towards how Nextflow is used at 23andMe. It includes a detailed use case for how 23andMe run their imputation pipeline in the cloud, processing over 1 million individuals per day with over 10,000 CPUs in a single compute environment.\n\n👉 [Nextflow at 23andMe](https://medium.com/23andme-engineering/introduction-to-nextflow-4d0e3b6768d1)\n\n### 3. A simple RNA-Seq hands-on tutorial\n\nThis hands-on tutorial from Seqera Labs will guide you through implementing a proof-of-concept RNA-seq pipeline. The goal is to become familiar with basic concepts, including how to define parameters, using channels to pass data around and writing processes to perform tasks. It includes all scripts, input data and resources and is perfect for getting a taste of Nextflow.\n\n👉 [Tutorial link on GitHub](https://github.com/seqeralabs/nextflow-tutorial)\n\n### 4. Nextflow workshop from Seqera Labs\n\nHere you’ll dive deeper into Nextflow’s most prominent features and learn how to apply them. The full workshop includes an excellent section on containers, how to build them and how to use them with Nextflow. The written materials come with examples and hands-on exercises. Optionally, you can also follow with a series of videos from a live training workshop.\n\nThe workshop includes topics on:\n\n- Environment Setup\n- Basic NF Script and Concepts\n- Nextflow Processes\n- Nextflow Channels\n- Nextflow Operators\n- Basic RNA-Seq pipeline\n- Containers &amp; Conda\n- Nextflow Configuration\n- On-premise &amp; Cloud Deployment\n- DSL 2 &amp; Modules\n- [GATK hands-on exercise](https://seqera.io/training/handson/)\n\n👉 [Workshop](https://seqera.io/training) &amp; [YouTube playlist](https://www.youtube.com/playlist?list=PLPZ8WHdZGxmUv4W8ZRlmstkZwhb_fencI).\n\n### 5. Software Carpentry workshop\n\nThe [Nextflow Software Carpentry](https://carpentries-incubator.github.io/workflows-nextflow/index.html) workshop (in active development) motivates the use of Nextflow and [nf-core](https://nf-co.re/) as development tools for building and sharing reproducible data science workflows. The intended audience are those with little programming experience, and the course provides a foundation to comfortably write and run Nextflow and nf-core workflows. Adapted from the Seqera training material above, the workshop has been updated by Software Carpentries instructors within the nf-core community to fit [The Carpentries](https://carpentries.org/) style of training. The Carpentries emphasize feedback to improve teaching materials so we would like to hear back from you about what you thought was both well-explained and what needs improvement. Pull requests to the course material are very welcome.\n\nThe workshop can be opened on [Gitpod](https://gitpod.io/#https://github.com/carpentries-incubator/workflows-nextflow) where you can try the exercises in an online computing environment at your own pace, with the course material in another window alongside.\n\n👉 You can find the course in [The Carpentries incubator](https://carpentries-incubator.github.io/workflows-nextflow/index.html).\n\n### 6. Managing Pipelines in the Cloud - GenomeWeb Webinar\n\nThis on-demand webinar features Phil Ewels from SciLifeLab and nf-core, Brendan Boufler from Amazon Web Services and Evan Floden from Seqera Labs. The wide ranging dicussion covers the significance of scientific workflow, examples of Nextflow in production settings and how Nextflow can be integrated with other processes.\n\n👉 [Watch the webinar](https://seqera.io/webinars-and-podcasts/managing-bioinformatics-pipelines-in-the-cloud-to-do-more-science/)\n\n### 7. Nextflow implementation patterns\n\nThis advanced section discusses recurring patterns and solutions to many common implementation requirements. Code examples are available with notes to follow along, as well as a GitHub repository.\n\n👉 [Nextflow Patterns](http://nextflow-io.github.io/patterns/index.html) &amp; [GitHub repository](https://github.com/nextflow-io/patterns).\n\n### 8. nf-core tutorials\n\nA tutorial covering the basics of using and creating nf-core pipelines. It provides an overview of the nf-core framework including:\n\n- How to run nf-core pipelines\n- What are the most commonly used nf-core tools\n- How to make new pipelines using the nf-core template\n- What are nf-core shared modules\n- How to add nf-core shared modules to a pipeline\n- How to make new nf-core modules using the nf-core module template\n- How nf-core pipelines are reviewed and ultimately released\n\n👉 [nf-core usage tutorials](https://nf-co.re/usage/usage_tutorials)\nand [nf-core developer tutorials](https://nf-co.re/developers/developer_tutorials)\n\n### 9. Awesome Nextflow\n\nA collections of awesome Nextflow pipelines.\n\n👉 [Awesome Nextflow](https://github.com/nextflow-io/awesome-nextflow) on GitHub\n\n### 10. Further resources\n\nThe following resources will help you dig deeper into Nextflow and other related projects like the nf-core community who maintain curated pipelines and a very active Slack channel. There are plenty of Nextflow tutorials and videos online, and the following list is no way exhaustive. Please let us know if we are missing anything.\n\n#### Nextflow docs\n\nThe reference for the Nextflow language and runtime. These docs should be your first point of reference while developing Nextflow pipelines. The newest features are documented in edge documentation pages released every month with the latest stable releases every three months.\n\n👉 Latest [stable](https://www.nextflow.io/docs/latest/index.html) &amp; [edge](https://www.nextflow.io/docs/edge/index.html) documentation.\n\n#### Seqera Labs docs\n\nAn index of documentation, deployment guides, training materials and resources for all things Nextflow and Tower.\n\n👉 [Seqera Labs docs](https://seqera.io/docs)\n\n#### nf-core\n\nnf-core is a growing community of Nextflow users and developers. You can find curated sets of biomedical analysis pipelines written in Nextflow and built by domain experts. Each pipeline is stringently reviewed and has been implemented according to best practice guidelines. Be sure to sign up to the Slack channel.\n\n👉 [nf-core website](https://nf-co.re) and [nf-core Slack](https://nf-co.re/join)\n\n#### Nextflow Tower\n\nNextflow Tower is a platform to easily monitor, launch and scale Nextflow pipelines on cloud providers and on-premise infrastructure. The documentation provides details on setting up compute environments, monitoring pipelines and launching using either the web graphic interface, CLI or API.\n\n👉 [Nextflow Tower](https://tower.nf) and [user documentation](http://help.tower.nf).\n\n#### Nextflow Biotech Blueprint by AWS\n\nA quickstart for deploying a genomics analysis environment on Amazon Web Services (AWS) cloud, using Nextflow to create and orchestrate analysis workflows and AWS Batch to run the workflow processes.\n\n👉 [Biotech Blueprint by AWS](https://aws.amazon.com/quickstart/biotech-blueprint/nextflow/)\n\n#### Nextflow Data Pipelines on Azure Batch\n\nNextflow on Azure requires at minimum two Azure services, Azure Batch and Azure Storage. Follow the guides below to set up both services on Azure, and to get your storage and batch account names and keys.\n\n👉 [Azure Blog](https://techcommunity.microsoft.com/t5/azure-compute-blog/running-nextflow-data-pipelines-on-azure-batch/ba-p/2150383) and [GitHub repository](https://github.com/microsoft/Genomics-Quickstart/blob/main/03-Nextflow-Azure/README.md).\n\n#### Running Nextflow by Google Cloud\n\nA step-by-step guide to launching Nextflow Pipelines in Google Cloud.\n\n👉 [Nextflow on Google Cloud](https://cloud.google.com/life-sciences/docs/tutorials/nextflow)\n\n#### Bonus: Nextflow Tutorial - Variant Calling Edition\n\nThis [Nextflow Tutorial - Variant Calling Edition](https://sateeshperi.github.io/nextflow_varcal/nextflow/) has been adapted from the [Nextflow Software Carpentry training material](https://carpentries-incubator.github.io/workflows-nextflow/index.html) and [Data Carpentry: Wrangling Genomics Lesson](https://datacarpentry.org/wrangling-genomics/). Learners will have the chance to learn Nextflow and nf-core basics, to convert a variant-calling bash-script into a Nextflow workflow and to modularize the pipeline using DSL2 modules and sub-workflows.\n\nThe workshop can be opened on [Gitpod](https://gitpod.io/#https://github.com/sateeshperi/nextflow_tutorial.git) where you can try the exercises in an online computing environment at your own pace, with the course material in another window alongside.\n\n👉 You can find the course in [Nextflow Tutorial - Variant Calling Edition](https://sateeshperi.github.io/nextflow_varcal/nextflow/).\n\n### Community and support\n\n- Nextflow [Gitter channel](https://gitter.im/nextflow-io/nextflow)\n- Nextflow [Forums](https://groups.google.com/forum/#!forum/nextflow)\n- Nextflow Twitter [@nextflowio](https://twitter.com/nextflowio?lang=en)\n- [nf-core Slack](https://nfcore.slack.com/)\n- [Seqera Labs](https://www.seqera.io) and [Nextflow Tower](https://tower.nf)\n\n### Credits\n\nSpecial thanks to Mahesh Binzer-Panchal for reviewing the latest revision of this post and contributing the Software Carpentry workshop section.",
    "images": [],
    "author": "Evan Floden",
    "tags": "learn,workshop,webinar"
  },
  {
    "slug": "2022/nextflow-is-moving-to-slack",
    "title": "Nextflow’s community is moving to Slack!",
    "date": "2022-02-22T00:00:00.000Z",
    "content": "<div class=\"text-muted\" style=\"margin-bottom:2em\">\n*\n“Software communities don’t just write code together. They brainstorm feature ideas, help new users get their bearings, and collaborate on best ways to use the software.…conversations need their own place\" - [GitHub Satellite Blog 2020](https://github.blog/2020-05-06-new-from-satellite-2020-github-codespaces-github-discussions-securing-code-in-private-repositories-and-more)\n*\n</div>\n\nThe Nextflow community channel on Gitter has grown substantially over the last few years and today has more than 1,300 members.\n\nI still remember when a [former colleague](https://twitter.com/helicobacter1) proposed the idea of opening a Nextflow channel on Gitter. At the time, I didn't know anything about Gitter, and my initial response was : \"would that not be a waste of time?\".\n\nFortunately, I took him up on his suggestion and the Gitter channel quickly became an important resource for all Nextflow developers and a key factor to its success.\n\n### Where the future lies\n\nAs the Nextflow community continues to grow, we realize that we have reached the limit of the discussion experience on Gitter. The lack of internal channels and the poor support for threads make the discussion unpleasant and difficult to follow. Over the last few years, Slack has proven to deliver a much better user experience and it is also touted as one of the most used platforms for discussion.\n\nFor these reasons, we felt that it is time to say goodbye to the beloved Nextflow Gitter channel and would like to welcome the community into the brand-new, official Nextflow workspace on Slack!\n\nYou can join today using [this link](https://www.nextflow.io/slack-invite.html)!\n\nOnce you have joined, you will be added to a selection of generic channels. However, we have also set up various additional channels for discussion around specific Nextflow topics, and for infrastructure-related topics. Please feel free to join whichever channels are appropriate to you.\n\nAlong the same lines, the Nextflow discussion forum is moving from [Google Groups](https://groups.google.com/forum/#!forum/nextflow) to the [Discussion forum](https://github.com/nextflow-io/nextflow/discussions) in the Nextflow GitHub repository. We hope this will provide a much better experience for Nextflow users by having a more direct connection with the codebase and issue repository.\n\nThe old Gitter channel and Google Groups will be kept active for reference and historical purposes, however we are actively promoting all members to move to the new channels.\n\nIf you have any questions or problems signing up then please feel free to let us know at info@nextflow.io.\n\nAs always, we thank you for being a part of the Nextflow community and for your ongoing support in driving its development and making workflows cool!\n\nSee you on Slack!\n\n### Credits\n\nThis was also made possible thanks to sponsorship from the [Chan Zuckerberg Initiative](https://chanzuckerberg.com/eoss/proposals/nextflow-and-nf-core/), the [Slack for Nonprofits program](https://slack.com/intl/en-gb/about/slack-for-good) and support from [Seqera Labs](https://www.seqera.io).",
    "images": [],
    "author": "Paolo Di Tommaso",
    "tags": "community, slack, github"
  },
  {
    "slug": "2022/nextflow-summit-2022-recap",
    "title": "Nextflow Summit 2022 Recap",
    "date": "2022-11-03T00:00:00.000Z",
    "content": "## Three days of Nextflow goodness in Barcelona\n\nAfter a three-year COVID-related hiatus from in-person events, Nextflow developers and users found their way to Barcelona this October for the 2022 Nextflow Summit. Held at Barcelona’s iconic Agbar tower, this was easily the most successful Nextflow community event yet!\n\nThe week-long event kicked off with 50 people participating in a hackathon organized by nf-core beginning on October 10th. The [hackathon](https://nf-co.re/events/2022/hackathon-october-2022) tackled several cutting-edge projects with developer teams focused on various aspects of nf-core including documentation, subworkflows, pipelines, DSL2 conversions, modules, and infrastructure. The Nextflow Summit began mid-week attracting nearly 600 people, including 165 attending in person and another 433 remotely. The [YouTube live streams](https://summit.nextflow.io/stream/) have now collected over two and half thousand views. Just prior to the summit, three virtual Nextflow training events were also run with separate sessions for the Americas, EMEA, and APAC in which 835 people participated.\n\n## An action-packed agenda\n\nThe three-day Nextflow Summit featured 33 talks delivered by speakers from academia, research, healthcare providers, biotechs, and cloud providers. This year’s speakers came from the following organizations:\n\n- Amazon Web Services\n- Center for Genomic Regulation\n- Centre for Molecular Medicine and Therapeutics, University of British Columbia\n- Chan Zukerberg Biohub\n- Curative\n- DNA Nexus\n- Enterome\n- Google\n- Janelia Research Campus\n- Microsoft\n- Oxford Nanopore\n- Quadram Institute BioScience\n- Seqera Labs\n- Quantitative Biology Center, University of Tübingen\n- Quilt Data\n- UNC Lineberger Comprehensive Cancer Center\n- Università degli Studi di Macerata\n- University of Maryland\n- Wellcome Sanger Institute\n- Wyoming Public Health Laboratory\n\n## Some recurring themes\n\nWhile there were too many excellent talks to cover individually, a few themes surfaced throughout the summit. Not surprisingly, SARS-Cov-2 was a thread that wound through several talks. Tony Zeljkovic from Curative led a discussion about [unlocking automated bioinformatics for large-scale healthcare](https://www.youtube.com/watch?v=JZMaRYzZxGU&amp;list=PLPZ8WHdZGxmUdAJlHowo7zL2pN3x97d32&amp;index=8), and Thanh Le Viet of Quadram Institute Bioscience discussed [large-scale SARS-Cov-2 genomic surveillance at QIB](https://www.youtube.com/watch?v=6jQr9dDaais&amp;list=PLPZ8WHdZGxmUdAJlHowo7zL2pN3x97d32&amp;index=30). Several speakers discussed best practices for building portable, modular pipelines. Other common themes were data provenance &amp; traceability, data management, and techniques to use compute and storage more efficiently. There were also a few talks about the importance of dataflows in new application areas outside of genomics and bioinformatics.\n\n## Data provenance tracking\n\nIn the Thursday morning keynote, Rob Patro﹘Associate Professor at the University of Maryland Dept. of Computer Science and CTO and co-founder of Ocean Genomics﹘described in his talk “[What could be next(flow)](https://www.youtube.com/watch?v=vNrKFT5eT8U&amp;list=PLPZ8WHdZGxmUdAJlHowo7zL2pN3x97d32&amp;index=6),” how far the Nextflow community had come in solving problems such as reproducibility, scalability, modularity, and ease of use. He then challenged the community with some complex issues still waiting in the wings. He focused on data provenance as a particularly vexing challenge explaining how tremendous effort currently goes into manual metadata curation.\n\nRob offered suggestions about how Nextflow might evolve, and coined the term “augmented execution contexts” (AECs) drawing from his work on provenance tracking – answering questions such as “what are these files, and where did they come from.” This thinking is reflected in [tximeta](https://github.com/mikelove/tximeta), a project co-developed with Mike Love of UNC. Rob also proposed ideas around automating data format conversions analogous to type casting in programming languages explaining how such conversions might be built into Nextflow channels to make pipelines more interoperable.\n\nIn his talk with the clever title “[one link to rule them all](https://www.youtube.com/watch?v=dttkcuP3OBc&amp;list=PLPZ8WHdZGxmUdAJlHowo7zL2pN3x97d32&amp;index=13),” Aneesh Karve of Quilt explained how every pipeline run is a function of the code, environment, and data, and went on to show how Quilt could help dramatically simplify data management with dataset versioning, accessibility, and verifiability. Data provenance and traceability were also front and center when Yih-Chii Hwang of DNAnexus described her team’s work around [bringing GxP compliance to Nextflow workflows](https://www.youtube.com/watch?v=RIwpJTDlLiE&amp;list=PLPZ8WHdZGxmUdAJlHowo7zL2pN3x97d32&amp;index=21).\n\n## Data management and storage\n\nOther speakers also talked about challenges related to data management and performance. Angel Pizarro of AWS gave an interesting talk comparing the [price/performance of different AWS cloud storage options](https://www.youtube.com/watch?v=VXtYCAqGEQQ&amp;list=PLPZ8WHdZGxmUdAJlHowo7zL2pN3x97d32&amp;index=12). [Hatem Nawar](https://www.youtube.com/watch?v=jB91uqUqsRM&amp;list=PLPZ8WHdZGxmUdAJlHowo7zL2pN3x97d32&amp;index=9) (Google) and [Venkat Malladi](https://www.youtube.com/watch?v=GAIL8ZAMJPQ&amp;list=PLPZ8WHdZGxmUdAJlHowo7zL2pN3x97d32&amp;index=20) (Microsoft) also talked about cloud economics and various approaches to data handling in their respective clouds. Data management was also a key part of Evan Floden’s discussion about Nextflow Tower where he discussed Tower Datasets, as well as the various cloud storage options accessible through Nextflow Tower. Finally, Nextflow creator Paolo Di Tommaso unveiled new work being done in Nextflow to simplify access to data residing in object stores in his talk “[Nextflow and the future of containers](https://www.youtube.com/watch?v=PTbiCVq0-sE&amp;list=PLPZ8WHdZGxmUdAJlHowo7zL2pN3x97d32&amp;index=14)”.\n\n## Compute optimization\n\nAnother recurring theme was improving compute efficiency. Several talks discussed using containers more effectively, leveraging GPUs &amp; FPGAs for added performance, improving virtual machine instance type selection, and automating resource requirements. Mike Smoot of Illumina talked about Nextflow, Kubernetes, and DRAGENs and how Illumina’s FPGA-based Bio-IT Platform can dramatically accelerate analysis. Venkat Malladi discussed efforts to suggest optimal VM types based on different standardized nf-core labels in the Azure cloud (process_low, process_medium, process_high, etc.) Finally, Evan Floden discussed [Nextflow Tower](https://www.youtube.com/watch?v=yJpN3fRSClA&amp;list=PLPZ8WHdZGxmUdAJlHowo7zL2pN3x97d32&amp;index=22) and unveiled an exciting new [resource optimization feature](https://seqera.io/blog/optimizing-resource-usage-with-nextflow-tower/) that can intelligently tune pipeline resource requests to radically reduce cloud costs and improve run speed. Overall, the Nextflow community continues to make giant strides in improving efficiency and managing costs in the cloud.\n\n## Beyond genomics\n\nWhile most summit speakers focused on genomics, a few discussed data pipelines in other areas, including statistical modeling, analysis, and machine learning. Nicola Visonà from Università degli Studi di Macerata gave a fascinating talk about [using agent-based models to simulate the first industrial revolution](https://www.youtube.com/watch?v=PlKJ0IDV_ds&amp;list=PLPZ8WHdZGxmUdAJlHowo7zL2pN3x97d32&amp;index=27). Similarly, Konrad Rokicki from the Janelia Research Campus explained how Janelia are using [Nextflow for petascale bioimaging data](https://www.youtube.com/watch?v=ZjSzx1I76z0&amp;list=PLPZ8WHdZGxmUdAJlHowo7zL2pN3x97d32&amp;index=18) and why bioimage processing remains a large domain area with an unmet need for reproducible workflows.\n\n## Summit Announcements\n\nThis year’s summit also saw several exciting announcements from Nextflow developers. Paolo Di Tommaso, during his talk on [the future of containers](https://www.youtube.com/watch?v=PTbiCVq0-sE&amp;list=PLPZ8WHdZGxmUdAJlHowo7zL2pN3x97d32&amp;index=14), announced the availability of [Nextflow 22.10.0](https://github.com/nextflow-io/nextflow/releases/tag/v22.10.0). In addition to various bug fixes, the latest Nextflow release introduces an exciting new technology called Wave that allows containers to be built on the fly from Dockerfiles or Conda recipes saved within a Nextflow pipeline. Wave also helps to simplify containerized pipeline deployment with features such as “container augmentation”; enabling developers to inject new container scripts and functionality on the fly without needing to rebuild the base containers such as a cloud-native [Fusion file system](https://www.nextflow.io/docs/latest/fusion.html). When used with Nextflow Tower, Wave also simplifies authentication to various public and private container registries. The latest Nextflow release also brings improved support for Kubernetes and enhancements to documentation, along with many other features.\n\nSeveral other announcements were made during [Evan Floden’s talk](https://www.youtube.com/watch?v=yJpN3fRSClA&amp;list=PLPZ8WHdZGxmUdAJlHowo7zL2pN3x97d32&amp;index=22&amp;t=127s), such as:\n\n- MultiQC is joining the Seqera Labs family of products\n- Fusion – a distributed virtual file system for cloud-native data pipelines\n- Nextflow Tower support for Google Cloud Batch\n- Nextflow Tower resource optimization\n- Improved Resource Labels support in Tower with integrations for cost accounting with all major cloud providers\n- A new Nextflow Tower dashboard coming soon, providing visibility across workspaces\n\n## Thank you to our sponsors\n\nThe summit organizers wish to extend a sincere thank you to the event sponsors: AWS, Google Cloud, Seqera Labs, Quilt Data, Oxford Nanopore Technologies, and Element BioSciences. In addition, the [Chan Zuckerberg Initiative](https://chanzuckerberg.com/eoss/) continues to play a key role with their EOSS grants funding important work related to Nextflow and the nf-core community. The success of this year’s summit reminds us of the tremendous value of community and the critical impact of open science software in improving the quality, accessibility, and efficiency of scientific research.\n\n## Learning more\n\nFor anyone who missed the summit, you can still watch the sessions or view the training sessions at your convenience:\n\n- Watch post-event recordings of the [Nextflow Summit on YouTube](https://www.youtube.com/playlist?list=PLPZ8WHdZGxmUdAJlHowo7zL2pN3x97d32)\n- View replays of the recent online [Nextflow and nf-core training](https://nf-co.re/events/2022/training-october-2022)\n\nFor additional detail on the summit and the preceding nf-core events, also check out an excellent [summary of the event](https://mribeirodantas.xyz/blog/index.php/2022/10/27/nextflow-and-nf-core-hot-news/) written by Marcel Ribeiro-Dantas in his blog, the [Dataist Storyteller](https://mribeirodantas.xyz/blog/index.php/2022/10/27/nextflow-and-nf-core-hot-news/)!\n\n_In this event, we're showcasing some of the results of the project 'Optimization of computational resources for HPC workloads in the cloud using ML/AI' by Seqera Labs S.L. This project has been funded by the European Regional Development Fund (ERDF) of the European Union, coordinated and managed by RED.es, with the aim of carrying out the development of technological entrepreneurship and technological demand, within the framework of the Strategic Action on Digital Economy and Society of the State Program for R&amp;D&amp;I oriented towards societal challenges._\n\n![grant logos](/img/blog-2022-11-03--img1.png)",
    "images": [],
    "author": "Noel Ortiz",
    "tags": "nextflow,tower,cloud"
  },
  {
    "slug": "2022/nextflow-summit-call-for-abstracts",
    "title": "Nextflow Summit 2022",
    "date": "2022-06-17T00:00:00.000Z",
    "content": "[As recently announced](https://twitter.com/nextflowio/status/1534903352810676224), we are super excited to host a new Nextflow community event late this year! The Nextflow Summit will take place **October 12-14, 2022** at the iconic Torre Glòries in Barcelona, with an associated [nf-core hackathon](https://nf-co.re/events/2022/hackathon-october-2022) beforehand.\n\n### Call for abstracts\n\nToday we’re excited to open the call for abstracts! We’re looking for talks and posters about anything and everything happening in the Nextflow world. Specifically, we’re aiming to shape the program into four key areas:\n\n- Nextflow: central tool / language / plugins\n- Community: pipelines / applications / use cases\n- Ecosystem: infrastructure / environments\n- Software: containers / tool packaging\n\nSpeaking at the summit will primarily be in-person, but we welcome posters from remote attendees. Posters will be submitted digitally and available online during and after the event. Talks will be streamed live and be available after the event.\n\n[Apply for a talk or poster](https://seqera.typeform.com/summit-22-talks)\n\n### Key dates\n\nRegistration for the event will happen separately, with key dates as follows (subject to change):\n\n- Jun 17: Call for abstracts opens\n- July 1: Registration opens\n- July 22: Call for abstracts closes\n- July 29: Accepted speakers notified\n- Sept 9: Registration closes\n- Oct 10-12: Hackathon\n- Oct 12-14: Summit\n\nAbstracts will be read and speakers notified on a rolling basis, so apply soon!\n\nThe Nextflow Summit will start Weds, Oct 12, 5:00 PM CEST and close Fri, Oct 14, 1:00 PM CEST.\n\n### Travel bursaries\n\nThanks to funding from the Chan Zuckerberg Initiative [EOSS Diversity &amp; Inclusion grant](https://chanzuckerberg.com/eoss/proposals/nextflow-and-nf-core/), we are offering 5 bursaries for travel and accommodation. These will only be available to those who have applied to present a talk or poster and will cover up to $1500 USD, plus registration costs.\n\nIf you’re interested, please select this option when filling the abstracts application form and we will be in touch with more details.\n\n### Stay in the loop\n\nMore information about the summit will be available soon, as we continue to plan the event. Please visit [https://summit.nextflow.io](https://summit.nextflow.io) for details and to sign up to the email list for event updates.\n\n[Subscribe for updates](https://share.hsforms.com/1F2Q5F0hSSiyNfuKo6tt-lw3zq3j)\n\nWe will be tweeting about the event using the [#NextflowSummit](http://twitter.com/hashtag/NextflowSummit) hashtag on Twitter. See you in Barcelona!",
    "images": [],
    "author": "Phil Ewels",
    "tags": "nextflow,summit,event,hackathon"
  },
  {
    "slug": "2022/rethinking-containers-for-cloud-native-pipelines",
    "title": "Rethinking containers for cloud native pipelines",
    "date": "2022-10-13T00:00:00.000Z",
    "content": "Containers have become an essential part of well-structured data analysis pipelines. They encapsulate applications and dependencies in portable, self-contained packages that can be easily distributed. Containers are also key to enabling predictable and [reproducible results](https://www.nature.com/articles/nbt.3820).\n\nNextflow was one of the first workflow technologies to fully embrace [containers](https://www.nextflow.io/blog/2014/using-docker-in-hpc-cluster.html) for data analysis pipelines. Community curated container collections such as [BioContainers](https://biocontainers.pro/) also helped speed container adoption.\n\nHowever, the increasing complexity of data analysis pipelines and the need to deploy them across different clouds and platforms pose new challenges. Today, workflows may comprise dozens of distinct container images. Pipeline developers must manage and maintain these containers and ensure that their functionality precisely aligns with the requirements of every pipeline task.\n\nAlso, multi-cloud deployments and the increased use of private container registries further increase complexity for developers. Building and maintaining containers, pushing them to multiple registries, and dealing with platform-specific authentication schemes are tedious, time consuming, and a source of potential errors.\n\n## Wave – a game changer\n\nFor these reasons, we decided to fundamentally rethink how containers are deployed and managed in Nextflow. Today we are thrilled to announce Wave — a container provisioning and augmentation service that is fully integrated with the Nextflow and Nextflow Tower ecosystems.\n\nInstead of viewing containers as separate artifacts that need to be integrated into a pipeline, Wave allows developers to manage containers as part of the pipeline itself. This approach helps simplify development, improves reliability, and makes pipelines easier to maintain. It can even improve pipeline performance.\n\n## How container provisioning works with Wave\n\nInstead of creating container images, pushing them to registries, and referencing them using Nextflow's [container](https://www.nextflow.io/docs/latest/process.html#container) directive, Wave allows developers to simply include a Dockerfile in the directory where a process is defined.\n\nWhen a process runs, the new Wave plug-in for Nextflow takes the Dockerfile and submits it to the Wave service. Wave then builds a container on-the-fly, pushes it to a destination container registry, and returns the container used for the actual process execution. The Wave service also employs caching at multiple levels to ensure that containers are built only once or when there is a change in the corresponding Dockerfile.\n\nThe registry where images are stored can be specified in the Nextflow config file, along with the other pipeline settings. This means containers can be served from cloud registries closer to where pipelines execute, delivering better performance and reducing network traffic.\n\n![Wave diagram](/img/wave-diagram.png)\n\n## Nextflow, Wave, and Conda – a match made in heaven\n\n[Conda](https://conda.io/) is an excellent package manager, fully [supported in Nextflow](https://www.nextflow.io/blog/2018/conda-support-has-landed.html) as an alternative to using containers to manage software dependencies in pipelines. However, until now, Conda could not be easily used in cloud-native computing platforms such as AWS Batch or Kubernetes.\n\nWave provides developers with a powerful new way to leverage Conda in Nextflow by using a [conda](https://www.nextflow.io/docs/latest/process.html#conda) directive as an alternative way to provision containers in their pipelines. When Wave encounters the `conda` directive in a process definition, and no container or Dockerfile is present, Wave automatically builds a container based on the Conda recipe using the strategy described above. Wave makes this process exceptionally fast (at least compared to vanilla Conda) by leveraging with the [Micromamba](https://github.com/mamba-org/mamba) project under the hood.\n\n## Support for private registries\n\nA long-standing problem with containers in Nextflow was the lack of support for private container registries. Wave solves this problem by acting as an authentication proxy between the Docker client requesting the container and a target container repository. Wave relies on [Nextflow Tower](https://seqera.io/tower/) to authenticate user requests to container registries.\n\nTo access private container registries from a Nextflow pipeline, developers can simply specify their Tower access token in the pipeline configuration file and store their repository credentials in [Nextflow Tower](https://help.tower.nf/22.2/credentials/overview/) page in your account. Wave will automatically and securely use these credentials to authenticate to the private container registry.\n\n## But wait, there's more! Container augmentation!\n\nBy automatically building and provisioning containers, Wave dramatically simplifies how containers are handled in Nextflow. However, there are cases where organizations are required to use validated containers for security or policy reasons rather than build their own images, but still they need to provide additional functionality, like for example, adding site-specific scripts or logging agents while keeping the base container layers intact.\n\nNextflow allows for the definition of pipeline level (and more recently module level) scripts executed in the context of the task execution environment. These scripts can be made accessible to the container environment by mounting a host volume. However, this approach only works when using a local or shared file system.\n\nWave solves these problems by dynamically adding one or more layers to an existing container image during the container image download phase from the registry. Developers can use container augmentation to inject an arbitrary payload into any container without re-building it. Wave then recomputes the image's final manifest adding new layers and checksums on-the-fly, so that the final downloaded image reflects the added content.\n\nWith container augmentation, developers can include a directory called `resources` in pipeline [module directories](https://www.nextflow.io/docs/latest/dsl2.html#module-directory). When the corresponding containerized task is executed, Wave automatically mirrors the content of the resources directory in the root path of the container where it can be accessed by scripts running within the container.\n\n## A sneak preview of Fusion file system\n\nOne of the main motivations for implementing Wave is that we wanted to have the ability to easily package a Fusion client in containers to make this important functionality readily available in Nextflow pipelines.\n\nFusion implements a virtual distributed file system and presents a thin-client allowing data hosted in AWS S3 buckets to be accessed via the standard POSIX filesystem interface expected by the pipeline tools. This client runs in the task container and is added automatically via the Wave augmentation capability. This makes Fusion functionality available for pipeline execution at runtime.\n\nThis means the Nextflow pipeline can use an AWS S3 bucket as the work directory, and pipeline tasks can access the S3 bucket natively as a local file system path. This is an important innovation as it avoids the additional step of copying files in and out of object storage. Fusion takes advantage for the Nextflow tasks segregation and idempotent execution model to optimise and speedup file access operations.\n\n## Getting started\n\nWave requires Nextflow version 22.10.0 or later and can be enabled by using the `-with-wave` command line option or by adding the following snippet in your nextflow.config file:\n\n```\nwave {\n  enabled = true\n  strategy = 'conda,container'\n}\n\ntower {\n  accessToken = \"<your tower=\"\" access=\"\" token=\"\">\"\n}\n```\n\nThe use of the Tower access token is not mandatory, however, it's required to enable the access to private repositories. The use of authentication also allows higher service rate limits compared to anonymous users. You can run a Nextflow pipeline such as rnaseq-nf with Wave, as follows:\n\n```\nnextflow run nextflow-io/rnaseq-nf -with-wave\n```\n\nThe configuration in the nextflow.config snippet above will enable the provisioning of Wave containers created starting from the `conda` requirements specified in the pipeline processes.\n\nYou can find additional information and examples in the Nextflow [documentation](https://www.nextflow.io/docs/latest/wave.html) and in the Wave [showcase project](https://github.com/seqeralabs/wave-showcase).\n\n## Availability\n\nThe Wave container provisioning service is available free of charge as technology preview to all Nextflow and Tower users. Wave supports all major container registries including [Docker Hub](https://hub.docker.com/), [Quay.io](https://quay.io/), [AWS Elastic Container Registry](https://aws.amazon.com/ecr/), [Google Artifact Registry](https://cloud.google.com/artifact-registry) and [Azure Container Registry](https://azure.microsoft.com/en-us/products/container-registry/).\n\nDuring the preview period, anonymous users can build up to 10 container images per day and pull 100 containers per hour. Tower authenticated users can build 100 container images per hour and pull 1000 containers per minute. After the preview period, we plan to make the Wave service available free of charge to academic users and open-source software (OSS) projects.\n\n## Conclusion\n\nSoftware containers greatly simplify the deployment of complex data analysis pipelines. However, there still have been many challenges preventing organizations from fully unlocking the potential of this exciting technology. For too long, containers have been viewed as a replacement for package managers, but they serve a different purpose.\n\nIn our view, it's time to re-consider containers as monolithic artifacts that are assembled separately from pipeline code. Instead, containers should be viewed simply as an execution substrate facilitating the deployment of the pipeline software dependencies defined via a proper package manager such as Conda.\n\nWave, Nextflow, and Nextflow Tower combine to fully automate the container lifecycle including management, provisioning and dependencies of complex data pipelines on-demand while removing unnecessary error-prone manual steps.\n</your>",
    "images": [],
    "author": "Paolo Di Tommaso",
    "tags": "nextflow,tower,cloud"
  },
  {
    "slug": "2022/turbocharging-nextflow-with-fig",
    "title": "Turbo-charging the Nextflow command line with Fig!",
    "date": "2022-09-22T00:00:00.000Z",
    "content": "Nextflow is a powerful workflow manager that supports multiple container technologies, cloud providers and HPC job schedulers. It shouldn't be a surprise that wide ranging functionality leads to a complex interface, but comes with the drawback of many subcommands and options to remember. For a first-time user (and sometimes even for some long-time users) it can be difficult to remember everything. This is not a new problem for the command-line; even very common applications such as grep and tar are famous for having a bewildering array of options.\n\n![xkcd charge making fun of tar tricky command line arguments](/img/xkcd_tar_charge.png)\nhttps://xkcd.com/1168/\n\nMany tools have sprung up to make the command-line more user friendly, such as tldr pages and rich-click. [Fig](https://fig.io) is one such tool that adds powerful autocomplete functionality to your terminal. Fig gives you graphical popups with color-coded contexts more dynamic than shaded text for recent commands or long blocks of text after pressing tab.\n\nFig is compatible with most terminals, shells and IDEs (such as the VSCode terminal), is fully supported in MacOS, and has beta support for Linux and Windows. In MacOS, you can simply install it with `brew install --cask fig` and then running the `fig` command to set it up.\n\nWe have now added Nextflow for Fig. Thanks to Figs open source core we were able to contribute specifications in Typescript that will now be automatically added for anyone installing or updating Fig. Now, with Fig, when you start typing your Nextflow commands, you’ll see autocomplete suggestions based on what you are typing and what you have typed in the past, such as your favorite options.\n\n![GIF with a demo of nextflow log/list subcommands](/img/nxf-log-list-params.gif)\n\nThe Fig autocomplete functionality can also be adjusted to suit our preferences. Suggestions can be displayed in alphabetical order or as a list of your most recent commands. Similarly, suggestions can be displayed all the time or only when you press tab.\n\nThe Fig specification that we've written not only suggests commands and options, but dynamic inputs too. For example, finding previous run names when resuming or cleaning runs is tedious and error prone. Similarly, pipelines that you’ve already downloaded with `nextflow pull` will be autocompleted if they have been run in the past. You won't have to remember the full names anymore, as Fig generators in the autocomplete allow you to automatically complete the run name after typing a few letters where a run name is expected. Importantly, this also works for pipeline names!\n\n![GIF with a demo of nextflow pull/run/clean/view/config subcommands](/img/nxf-pull-run-clean-view-config.gif)\n\nFig for Nextflow will make you increase your productivity regardless of your user level. If you run multiple pipelines during your day you will immediately see the benefit of Fig. Your productivity will increase by taking advantage of this autocomplete function for run and project names. For Nextflow newcomers it will provide an intuitive way to explore the Nextflow CLI with built-in help text.\n\nWhile Fig won’t replace the need to view help menus and documentation it will undoubtedly save you time and energy searching for commands and copying and pasting run names. Take your coding to the next level using Fig!",
    "images": [],
    "author": "Marcel Ribeiro-Dantas",
    "tags": "nextflow,development,learning"
  },
  {
    "slug": "2023/a-nextflow-docker-murder-mystery-the-mysterious-case-of-the-oom-killer",
    "title": "A Nextflow-Docker Murder Mystery: The mysterious case of the “OOM killer”",
    "date": "2023-06-19T00:00:00.000Z",
    "content": "Most support tickets crossing our desks don’t warrant a blog article. However, occasionally we encounter a genuine mystery—a bug so pervasive and vile that it threatens innocent containers and pipelines everywhere. Such was the case of the **_OOM killer_**.\n\nIn this article, we alert our colleagues in the Nextflow community to the threat. We also discuss how to recognize the killer’s signature in case you find yourself dealing with a similar murder mystery in your own cluster or cloud.\n\n<!-- end-archive-description -->\n\n## To catch a killer\n\nIn mid-2022, Nextflow jobs began to mysteriously die. Containerized tasks were being struck down in the prime of life, seemingly at random. By November, the body count was beginning to mount: Out-of-memory (OOM) errors were everywhere we looked!\n\nIt became clear that we had a serial killer on our hands. Unfortunately, identifying a suspect turned out to be easier said than done. Nextflow is rather good at restarting failed containers after all, giving the killer a convenient alibi and plenty of places to hide. Sometimes, the killings went unnoticed, requiring forensic analysis of log files.\n\nWhile we’ve made great strides, and the number of killings has dropped dramatically, the killer is still out there. In this article, we offer some tips that may prove helpful if the killer strikes in your environment.\n\n## Establishing an MO\n\nFortunately for our intrepid investigators, the killer exhibited a consistent _modus operandi_. Containerized jobs on [Amazon EC2](https://aws.amazon.com/ec2/) were being killed due to out-of-memory (OOM) errors, even when plenty of memory was available on the container host. While we initially thought the killer was native to the AWS cloud, we later realized it could also strike in other locales.\n\nWhat the killings had in common was that they tended to occur when Nextflow tasks copied large files from Amazon S3 to a container’s local file system via the AWS CLI. As some readers may know, Nextflow leverages the AWS CLI behind the scenes to facilitate data movement. The killer’s calling card was an `[Errno 12] Cannot allocate memory` message, causing the container to terminate with an exit status of 1.\n\n```\nNov-08 21:54:07.926 [Task monitor] ERROR nextflow.processor.TaskProcessor - Error executing process &gt; 'NFCORE_SAREK:SAREK:MARKDUPLICATES:BAM_TO_CRAM:SAMTOOLS_STATS_CRAM (004-005_L3.SSHT82)'\nCaused by:\n  Essential container in task exited\n..\nCommand error:\n  download failed: s3://myproject/NFTower-Ref/Homo_sapiens/GATK/GRCh38/Sequence/WholeGenomeFasta/Homo_sapiens_assembly38.fasta to ./Homo_sapiens_assembly38.fasta [Errno 12] Cannot allocate memory\n```\n\nThe problem is illustrated in the diagram below. In theory, Nextflow should have been able to dispatch multiple containerized tasks to a single host. However, tasks were being killed with out-of-memory errors even though plenty of memory was available. Rather than being able to run many containers per host, we could only run two or three and even that was dicey! Needless to say, this resulted in a dramatic loss of efficiency.\n\n<img src=\"/img/a-nextflow-docker-murder-mystery-the-mysterious-case-of-the-oom-killer-1.jpg\">\n\nAmong our crack team of investigators, alarm bells began to ring. We asked ourselves, _“Could the killer be inside the house?”_ Was it possible that Nextflow was nefariously killing its own containerized tasks?\n\nBefore long, reports of similar mysterious deaths began to trickle in from other jurisdictions. It turned out that the killer had struck [Cromwell](https://cromwell.readthedocs.io/en/stable/) also ([see the police report here](https://github.com/aws/aws-cli/issues/5876)). We breathed a sigh of relief that we could rule out Nextflow as the culprit, but we still had a killer on the loose and a series of container murders to solve!\n\n## Recreating the scene of the crime\n\nAs any good detective knows, recreating the scene of the crime is a good place to start. It turned out that our killer had a profile and had been targeting containers processing large datasets since 2020. We came across an excellent [codefresh.io article](https://codefresh.io/blog/docker-memory-usage/) by Saffi Hartal, discussing similar murders and suggesting techniques to lure the killer out of hiding and protect the victims. Unfortunately, the suggested workaround of periodically clearing kernel buffers was impractical in our Nextflow pipeline scenario.\n\nWe borrowed the Python script from [Saffi’s article](https://codefresh.io/blog/docker-memory-usage/) designed to write huge files and simulate the issues we saw with the Linux buffer and page cache. Using this script, we hoped to replicate the conditions at the time of the murders.\n\nUsing separate SSH sessions to the same docker host, we manually launched the Python script from the command line to run in a Docker container, allocating 512MB of memory to each container. This was meant to simulate the behavior of the Nextflow head job dispatching multiple tasks to the same Docker host. We monitored memory usage as each container was started.\n\n```bash\n$ docker run --rm -it -v $PWD/dockertest.py:/dockertest.py --entrypoint /bin/bash --memory=\"512M\" --memory-swap=0 python:3.10.5-slim-bullseye\n```\n\nSure enough, we found that containers began dying with out-of-memory errors. Sometimes we could run a single container, and sometimes we could run two. Containers died even though memory use was well under the cgroups-enforced maximum, as reported by docker stats. As containers ran, we also used the Linux `free` command to monitor memory usage and the combined memory used by kernel buffers and the page cache.\n\n## Developing a theory of the case\n\nFrom our testing, we were able to clear both Nextflow and the AWS S3 copy facility since we could replicate the out-of-memory error in our controlled environment independent of both.\n\nWe had multiple theories of the case: **_Was it Colonel Mustard with an improper cgroups configuration? Was it Professor Plum and the size of the SWAP partition? Was it Mrs. Peacock running a Linux 5.20 kernel?_**\n\n_For the millennials and Gen Zs in the crowd, you can find a primer on the CLUE/Cluedo references [here](https://en.wikipedia.org/wiki/Cluedo)_\n\nTo make a long story short, we identified several suspects and conducted tests to clear each suspect one by one. Tests included the following:\n\n- We conducted tests with EBS vs. NVMe disk volumes to see if the error was related to page caches when using EBS. The problems persisted with NVMe but appeared to be much less severe.\n- We attempted to configure a swap partition as recommended in this [AWS article](https://repost.aws/knowledge-center/ecs-resolve-outofmemory-errors), which discusses similar out-of-memory errors in Amazon ECS (used by AWS Batch). AWS provides good documentation on managing container [swap space](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/container-swap.html) using the `--memory-swap` switch. You can learn more about how Docker manages swap space in the [Docker documentation](https://docs.docker.com/config/containers/resource_constraints/).\n- Creating swap files on the Docker host and making swap available to containers using the switch `--memory-swap=\"1g\"` appeared to help, and we learned a lot in the process. Using this workaround we could reliably run 10 containers simultaneously, whereas previously, we could run only one or two. This was a good workaround for static clusters but wasn’t always helpful in cloud batch environments. Creating the swap partition requires root privileges, and in batch environments, where resources may be provisioned automatically, this could be difficult to implement. It also didn’t explain the root cause of why containers were being killed. You can use the commands below to create a swap partition:\n\n```bash\n$ sudo dd if=/dev/zero of=/mnt/2GiB.swap bs=2048 count=1048576\n$ mkswap /mnt/2GiB.swap\n$ swapon /mnt/2GiB.swap\n```\n\n## A break in the case!\n\nOn Nov 16th, we finally caught a break in the case. A hot tip from Seqera Lab’s own [Jordi Deu-Pons](https://github.com/jordeu), indicated the culprit may be lurking in the Linux kernel. He suggested hard coding limits for two Linux kernel parameters as follows:\n\n```bash\n$ echo \"838860800\" &gt; /proc/sys/vm/dirty_bytes\n$ echo \"524288000\" &gt; /proc/sys/vm/dirty_background_bytes\n```\n\nWhile it may seem like a rather unusual and specific leap of brilliance, our tipster’s hypothesis was inspired by this [kernel bug](https://bugzilla.kernel.org/show_bug.cgi?id=207273) description. With this simple change, the reported memory usage for each container, as reported by docker stats, dropped dramatically. **Suddenly, we could run as many containers simultaneously as physical memory would allow.** It turns out that this was a regression bug that only manifested in newer versions of the Linux kernel.\n\nBy hardcoding these [kernel parameters](https://docs.kernel.org/admin-guide/sysctl/vm.html), we were limiting the number of dirty pages the kernel could hold before writing pages to disk. When these variables were not set, they defaulted to 0, and the default parameters `dirty_ratio` and `dirty_bakground_ratio` took effect instead.\n\nIn high-load conditions (such as data-intensive Nextflow pipeline tasks), processes accumulated dirty pages faster than the kernel could flush them to disk, eventually leading to the out-of-memory condition. By hard coding the dirty pages limit, we forced the kernel to flush the dirty pages to disk, thereby avoiding the bug. This also explained why the problem was less pronounced using NVMe storage, where flushing to disk occurred more quickly, thus mitigating the problem.\n\nFurther testing determined that the bug appeared reliably on the newer [AMI Linux 2 AMI using the 5.10 kernel](https://aws.amazon.com/about-aws/whats-new/2021/11/amazon-linux-2-ami-kernel-5-10/). The bug did not seem to appear when using the older Amazon Linux 2 AMI running the 4.14 kernel version.\n\nWe now had two solid strategies to resolve the problem and thwart our killer:\n\n- Create a swap partition and run containers with the `--memory-swap` flag set.\n- Set `dirty_bytes` and `dirty_background_bytes` kernel variables on the Docker host before launching the jobs.\n\n## The killer is (mostly) brought to justice\n\nAvoiding the Linux 5.10 kernel was obviously not a viable option. The 5.10 kernel includes support for important processor architectures such as Intel® Ice Lake. This bug did not manifest earlier because, by default, AWS Batch was using ECS-optimized AMIs based on the 4.14 kernel. Further testing showed us that the killer could still appear in 4.14 environments, but the bug was harder to trigger.\n\nWe ended up working around the problem for Nextflow Tower users by tweaking the kernel parameters in the compute environment deployed by Tower Forge. This solution works reliably with AMIs based on both the 4.14 and 5.10 kernels. We considered adding a swap partition as this was another potential solution to the problem. However, we were concerned that this could have performance implications, particularly for customers running with EBS gp2 magnetic disk storage.\n\nInterestingly, we also tested the [Fusion v2 file system](https://seqera.io/fusion/) with NVMe disk. Using Fusion, we avoided the bug entirely on both kernel versions without needing to adjust kernel partitions or add a swap partition.\n\n## Some helpful investigative tools\n\nIf you find evidence of foul play in your cloud or cluster, here are some useful investigative tools you can use:\n\n- After manually starting a container, use [docker stats](https://docs.docker.com/engine/reference/commandline/stats/) to monitor the CPU and memory used by each container compared to available memory.\n\n  ```bash\n  $ watch docker stats\n  ```\n\n- The Linux [free](https://linuxhandbook.com/free-command/) utility is an excellent way to monitor memory usage. You can track total, used, and free memory and monitor the combined memory used by kernel buffers and page cache reported in the _buff/cache_ column.\n\n  ```bash\n  $ free -h\n  ```\n\n- After a container was killed, we executed the command below on the Docker host to confirm why the containerized Python script was killed.\n\n  ```bash\n  $ dmesg -T | grep -i ‘killed process’\n  ```\n\n- We used the Linux [htop](https://man7.org/linux/man-pages/man1/htop.1.html) command to monitor CPU and memory usage to check the results reported by Docker and double-check CPU and memory use.\n- You can use the command [systemd-cgtop](https://www.commandlinux.com/man-page/man1/systemd-cgtop.1.html) to validate group settings and ensure you are not running into arbitrary limits imposed by _cgroups_.\n- Related to the _cgroups_ settings described above, you can inspect various memory-related limits directly from the file system. You can also use an alias to make the large numbers associated with _cgroups_ parameters easier to read. For example:\n\n  ```bash\n  $ alias n='numft --to=iec-i'\n  $ cat /sys/fs/cgroup/memory/docker/DOCKER_CONTAINER/memory.limit_in_bytes | n\n  512Mi\n  ```\n\n- You can clear the kernel buffer and page cache that appears in the buff/cache columns reported by the Linux _free_ command using either of these commands:\n\n  ```bash\n  $ echo 1 &gt; /proc/sys/vm/drop_caches\n  $ sysctl -w vm.drop_caches=1\n  ```\n\n## The bottom line\n\nWhile we’ve come a long way in bringing the killer to justice, out-of-memory issues still crop up occasionally. It’s hard to say whether these are copycats, but you may still run up against this bug in a dark alley near you!\n\nIf you run into similar problems, hopefully, some of the suggestions offered above, such as tweaking kernel parameters or adding a swap partition on the Docker host, can help.\n\nFor some users, a good workaround is to use the [Fusion file system](https://seqera.io/blog/breakthrough-performance-and-cost-efficiency-with-the-new-fusion-file-system/) instead of Nextflow’s conventional approach based on the AWS CLI. As explained above, the combination of more efficient data handling in Fusion and fast NVMe storage means that dirty pages are flushed more quickly, and containers are less likely to reach hard limits and exit with an out-of-memory error.\n\nYou can learn more about the Fusion file system by downloading the whitepaper [Breakthrough performance and cost-efficiency with the new Fusion file system](https://seqera.io/whitepapers/breakthrough-performance-and-cost-efficiency-with-the-new-fusion-file-system/). If you encounter similar issues or have ideas to share, join the discussion on the [Nextflow Slack channel](https://join.slack.com/t/nextflow/shared_invite/zt-11iwlxtw5-R6SNBpVksOJAx5sPOXNrZg).",
    "images": [
      "/img/a-nextflow-docker-murder-mystery-the-mysterious-case-of-the-oom-killer-1.jpg"
    ],
    "author": "Graham Wright",
    "tags": "nextflow"
  },
  {
    "slug": "2023/best-practices-deploying-pipelines-with-hpc-workload-managers",
    "title": "Nextflow on BIG IRON: Twelve tips for improving the effectiveness of pipelines on HPC clusters",
    "date": "2023-05-26T00:00:00.000Z",
    "content": "With all the focus on cloud computing, it's easy to forget that most Nextflow pipelines still run on traditional HPC clusters. In fact, according to our latest [State of the Workflow 2023](https://seqera.io/blog/the-state-of-the-workflow-the-2023-nextflow-and-nf-core-community-survey/) community survey, **62.8%** of survey respondents report running Nextflow on HPC clusters, and **75%** use an HPC workload manager.^1^ While the cloud is making gains, traditional clusters aren't going away anytime soon.\n\nTapping cloud infrastructure offers many advantages in terms of convenience and scalability. However, for organizations with the capacity to manage in-house clusters, there are still solid reasons to run workloads locally:\n\n- _Guaranteed access to resources_. Users don't need to worry about shortages of particular instance types, spot instance availability, or exceeding cloud spending caps.\n- _Predictable pricing_. Organizations are protected against price inflation and unexpected rate increases by capitalizing assets and depreciating them over time.\n- _Reduced costs_. Contrary to conventional wisdom, well-managed, highly-utilized, on-prem clusters are often less costly per core hour than cloud-based alternatives.\n- _Better performance and throughput_. While HPC infrastructure in the cloud is impressive, state-of-the-art on-prem clusters are still tough to beat.^2^\n\nThis article provides some helpful tips for organizations running Nextflow on HPC clusters.\n\n## The anatomy of an HPC cluster\n\nHPC Clusters come in many shapes and sizes. Some are small, consisting of a single head node and a few compute hosts, while others are huge, with tens or even hundreds of host computers.\n\nThe diagram below shows the topology of a typical mid-sized HPC cluster. Clusters typically have one or more \"head nodes\" that run workload and/or cluster management software. Cluster managers, such as [Warewulf](https://warewulf.lbl.gov/), [xCAT](https://xcat.org/), [NVIDIA Bright Cluster Manager](https://www.nvidia.com/en-us/data-center/bright-cluster-manager/), [HPE Performance Cluster Manager](https://www.hpe.com/psnow/doc/a00044858enw), or [IBM Spectrum Cluster Foundation](https://www.ibm.com/docs/en/scf/4.2.2?topic=guide-spectrum-cluster-foundation), are typically used to manage software images and provision cluster nodes. Large clusters may have multiple head nodes, with workload management software configured to failover if the master host fails.\n\n<img src=\"/img/nextflow-on-big-iron-twelve-tips-for-improving-the-effectiveness-of-pipelines-on-hpc-clusters-1.jpg\">\n\nLarge clusters may have dedicated job submission hosts (also called login hosts) so that user activity does not interfere with scheduling and management activities on the head node. In smaller environments, users may simply log in to the head node to submit their jobs.\n\nClusters are often composed of different compute hosts suited to particular workloads.^3^ They may also have separate dedicated networks for management, internode communication, and connections to a shared storage subsystem. Users typically have network access only to the head node(s) and job submission hosts and are prevented from connecting to the compute hosts directly.\n\nDepending on the workloads a cluster is designed to support, compute hosts may be connected via a private high-speed 100 GbE or Infiniband-based network commonly used for MPI parallel workloads. Cluster hosts typically have access to a shared file system as well. In life sciences environments, NFS filers are commonly used. However, high-performance clusters may use parallel file systems such as [Lustre](https://www.lustre.org/), [IBM Spectrum Scale](https://www.ibm.com/docs/en/storage-scale?topic=STXKQY/gpfsclustersfaq.html) (formerly GPFS), [BeeGFS](https://www.beegfs.io/c/), or [WEKA](https://www.weka.io/data-platform/solutions/hpc-data-management/).\n\n[Learn about selecting the right storage architecture for your Nextflow pipelines](https://nextflow.io/blog/2023/selecting-the-right-storage-architecture-for-your-nextflow-pipelines.html).\n\n## HPC workload managers\n\nHPC workload managers have been around for decades. Initial efforts date back to the original [Portable Batch System](https://www.chpc.utah.edu/documentation/software/pbs-scheduler.php) (PBS) developed for NASA in the early 1990s. While modern workload managers have become enormously sophisticated, many of their core principles remain unchanged.\n\nWorkload managers are designed to share resources efficiently between users and groups. Modern workload managers support many different scheduling policies and workload types — from parallel jobs to array jobs to interactive jobs to affinity/NUMA-aware scheduling. As a result, schedulers have many \"knobs and dials\" to support various applications and use cases. While complicated, all of this configurability makes them extremely powerful and flexible in the hands of a skilled cluster administrator.\n\n### Some notes on terminology\n\nHPC terminology can be confusing because different terms sometimes refer to the same thing. Nextflow refers to individual steps in a workflow as a \"process\". Sometimes, process steps spawned by Nextflow are also described as \"tasks\". When Nextflow processes are dispatched to an HPC workload manager, however, each process is managed as a \"job\" in the context of the workload manager.\n\nHPC workload managers are sometimes referred to as schedulers. In this text, we use the terms HPC workload manager, workload manager, and scheduler interchangeably.\n\n## Nextflow and HPC workload managers\n\nNextflow supports at least **14 workload managers**, not including popular cloud-based compute services. This number is even higher if one counts variants of popular schedulers. For example, the Grid Engine executor works with Altair® Grid Engine™ as well as older Grid Engine dialects, including Oracle Grid Engine (previously Sun Grid Engine), Open Grid Engine (OGE), and SoGE (son of Grid Engine). Similarly, the PBS integration works successors to the original OpenPBS project, including Altair® PBS Professional®, TORQUE, and Altair's more recent open-source version, OpenPBS.^4^ Workload managers supported by Nextflow are listed below:\n\n<img src=\"/img/nextflow-on-big-iron-twelve-tips-for-improving-the-effectiveness-of-pipelines-on-hpc-clusters-2.jpg\">\n\nBelow we present some helpful tips and best practices when working with HPC workload managers.\n\n## Some best practices\n\n### 1. Select an HPC executor\n\nTo ensure that pipelines are portable across clouds and HPC clusters, Nextflow uses the notion of [executor](https://nextflow.io/docs/latest/executor.html) to insulate pipelines from the underlying compute environment. A Nextflow executor determines the system where a pipeline is run and supervises its execution.\n\nYou can specify the executor to use in the [nextflow.config](https://nextflow.io/docs/latest/config.html?highlight=queuesize#configuration-file) file, inline in your pipeline code, or by setting the shell variable `NXF_EXECUTOR` before running a pipeline.\n\n```groovy\nprocess.executor = 'slurm'\n```\n\nExecutors are defined as part of the process scope in Nextflow, so in theory, each process can have a different executor. You can use the [local](https://www.nextflow.io/docs/latest/executor.html?highlight=local#local) executor to run a process on the same host as the Nextflow head job rather than dispatching it to an HPC cluster.\n\nA complete list of available executors is available in the [Nextflow documentation](https://nextflow.io/docs/latest/executor.html). Below is a handy list of executors for HPC workload managers.\n\n<table class=\"table table-bordered\">\n  <thead>\n    <tr>\n      <th>\n        Workload Manager\n      </th>\n      <th>\n        Executor\n      </th>\n      <th>\n        License\n      </th>\n      <th>\n        Documentation\n      </th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>\n        Slurm\n      </td>\n      <td>\n        [slurm](https://www.nextflow.io/docs/latest/executor.html?highlight=local#slurm)\n      </td>\n      <td>\n        Open source\n      </td>\n      <td>\n        [Slurm](https://slurm.schedmd.com/documentation.html)\n      </td>\n    </tr>\n    <tr>\n      <td>\n        IBM Spectrum LSF\n      </td>\n      <td>\n        [lsf](https://www.nextflow.io/docs/latest/executor.html?highlight=local#lsf)\n      </td>\n      <td>\n        Commercial\n      </td>\n      <td>\n        [IBM Spectrum LSF knowledge center](https://www.ibm.com/docs/en/spectrum-lsf/10.1.0)\n      </td>\n    </tr>\n    <tr>\n      <td>\n        OpenPBS\n      </td>\n      <td>\n        [pbspro](https://www.nextflow.io/docs/latest/executor.html?highlight=local#pbs-pro)\n      </td>\n      <td>\n        Open source\n      </td>\n      <td>\n        [OpenPBS](https://github.com/openpbs/openpbs/tree/master/doc) (docs packaged with software)\n      </td>\n    </tr>\n    <tr>\n      <td>\n        Altair® Grid Engine™\n      </td>\n      <td>\n        [sge](https://www.nextflow.io/docs/latest/executor.html?highlight=local#sge)\n      </td>\n      <td>\n        Commercial\n      </td>\n      <td>\n        [Altair Grid Engine introductory guide](https://2022.help.altair.com/2022.1.0/AltairGridEngine/IntroductionGE.pdf)\n      </td>\n    </tr>\n    <tr>\n      <td>\n        Altair® PBS Professional®\n      </td>\n      <td>\n        [pbspro](https://www.nextflow.io/docs/latest/executor.html?highlight=local#pbs-pro)\n      </td>\n      <td>\n        Commercial\n      </td>\n      <td>\n        [Altair PBS Professional user's guide](https://slurm.schedmd.com/documentation.html)\n      </td>\n    </tr>\n    <tr>\n      <td>\n        Adaptive Computing MOAB\n      </td>\n      <td>\n        [moab](https://www.nextflow.io/docs/latest/executor.html?highlight=local#moab)\n      </td>\n      <td>\n        Commercial\n      </td>\n      <td>\n        [Adaptive Computing Maui Scheduler](http://docs.adaptivecomputing.com/maui/)^5^\n      </td>\n    </tr>\n    <tr>\n      <td>\n        Adaptive Computing TORQUE\n      </td>\n      <td>\n        [pbs](https://www.nextflow.io/docs/latest/executor.html?highlight=local#pbs-torque)\n      </td>\n      <td>\n        Open source\n      </td>\n      <td>\n        [Torque administrators guide](http://docs.adaptivecomputing.com/10-0-0/Torque/torque.htm#topics/torque/1-intro/introduction.htm)\n      </td>\n    </tr>\n    <tr>\n      <td>\n        HTCondor\n      </td>\n      <td>\n        [condor](https://www.nextflow.io/docs/latest/executor.html?highlight=local#htcondor)\n      </td>\n      <td>\n        Open source\n      </td>\n      <td>\n        [HTCondor documentation](https://research.cs.wisc.edu/htcondor/htcondor/documentation/)\n      </td>\n    </tr>\n    <tr>\n      <td>\n        Apache Ignite\n      </td>\n      <td>\n        [ignite](https://www.nextflow.io/docs/latest/executor.html?highlight=local#ignite)\n      </td>\n      <td>\n        Open source\n      </td>\n      <td>\n        [Apache Ignite Documentation](https://ignite.apache.org/docs/latest/)\n      </td>\n    </tr>\n    <tr>\n      <td>\n        HyperQueue\n      </td>\n      <td>\n        [hyperqueue](https://www.nextflow.io/docs/latest/executor.html?highlight=local#hyperqueue)\n      </td>\n      <td>\n        Open source\n      </td>\n      <td>\n        [Docs on GitHub](https://github.com/It4innovations/hyperqueue)\n      </td>\n    </tr>\n  </tbody>\n</table>\n\n### 2. Select a queue\n\nMost HPC workload managers support the notion of queues. In a small cluster with a few users, queues may not be important. However, they are essential in large environments. Cluster administrators typically configure queues to reflect site-specific scheduling and resource-sharing policies. For example, a site may have a short queue that only supports short-running jobs and kills them after 60 seconds. A _night_ queue may only dispatch jobs between midnight and 6:00 AM. Depending on the sophistication of the workload manager, different queues may have different priorities and access to queues may be limited to particular users or groups.\n\nWorkload managers typically have default queues. For example, `normal` is the default queue in LSF, while `all.q` is the default queue in Grid Engine. Slurm supports the notion of partitions that are essentially the same as queues, so Slurm partitions are referred to as queues within Nextflow. You should ask your HPC cluster administrator what queue to use when submitting Nextflow jobs.\n\nLike the executor, queues are part of the process scope. The queue to dispatch jobs to is usually defined once in the `nextflow.config` file and applied to all processes in the workflow as shown below, or it can be set per-process.\n\n```\nprocess {\n    queue = 'myqueue'\n    executor = 'sge'\n}\n```\n\nSome organizations use queues as a mechanism to request particular types of resources. For example, suppose hosts with the latest NVIDIA A100 or K100 GPUs are in high demand. In that case, a cluster administrator may configure a particular queue called `gpu_queue` to dispatch jobs to those hosts and limit access to specific users. For process steps requiring access to GPUs, the administrator may require submitting jobs to this queue. This is why it is important to consult site-specific documentation or ask your cluster administrator which queues are available.\n\n### 3. Specify process-level resource requirements\n\nDepending on the executor, you can pass various resource requirements for each process/job to the workload manager. Like _executors_ and _queues_, these settings are configured at the process level. Not all executors support the same resource directives, but the settings below are common to most HPC workload managers.\n\n[cpus](https://nextflow.io/docs/latest/process.html#process-cpus) – specifies the number of logical CPUs requested for a particular process/job. A logical CPU maps to a physical processor core or thread depending on whether hyperthreading is enabled on the underlying cluster hosts.\n\n[memory](https://nextflow.io/docs/latest/process.html#process-memory) – different process steps/jobs will typically have different memory requirements. It is important to specify memory requirements accurately because the HPC schedulers use this information to decide how many jobs can execute concurrently on a host. If you overstate resource requirements, you are wasting resources on the cluster.\n\n[time](https://nextflow.io/docs/latest/process.html#process-time) – it is helpful to limit how much time a particular process or job is allowed to run. To avoid jobs hanging and consuming resources indefinitely, you can specify a time limit after which a job will be automatically terminated and re-queued. Time limits may also be enforced at the queue level behind the scenes based on workload management policies. If you have long-running jobs, your cluster administrator may ask you to use a particular queue for those Nextflow process steps to prevent jobs from being automatically killed.^6^\n\nWhen writing pipelines, it is a good practice to consolidate per-process resource requirements in the `nextflow.config` file, and use process selectors to indicate what resource requirements apply to what process steps. For example, in the example below, processes will be dispatched to the Slurm cluster by default. Each process will require two cores, 4 GB of memory, and can run for no more than 10 minutes. For the foo and long-running bar jobs, process-specific selectors can override these default settings as shown below:\n\n```groovy\nprocess {\n    executor = 'slurm'\n    queue = 'general'\n    cpus = 2\n    memory = '4 GB'\n    time = '10m'\n\n    withName: foo {\n       cpus = 8\n       memory = '8 GB'\n    }\n\n    withName: bar {\n       queue = 'long'\n       cpus = 32\n       memory = '8 GB'\n       time = '1h 30m'\n    }\n}\n```\n\n### 4. Take advantage of workload manager-specific features\n\nSometimes, organizations may want to take advantage of syntax specific to a particular workload manager. To accommodate this, most Nextflow executors provide a `clusterOptions` setting to inject one or more switches to the job submission command line specific to the selected workload manager ([bsub](https://www.ibm.com/docs/en/spectrum-lsf/10.1.0?topic=bsub-options), [msub](http://docs.adaptivecomputing.com/maui/commands/msub.php), [qsub](https://gridscheduler.sourceforge.net/htmlman/htmlman1/qsub.html), etc).\n\nThese scheduler-specific commands can get very detailed and granular. They can apply to all processes in a workflow or only to specific processes. As an LSF-specific example, suppose a deep learning model training workload is a step in a Nextflow pipeline. The deep learning framework used may be GPU-aware and have specific topology requirements.\n\nIn this example, we specify a job consisting of two tasks where each task runs on a separate host and requires exclusive use of two GPUs. We also impose a resource requirement that we want to schedule the CPU portion of each CUDA job in physical proximity to the GPU to improve performance (on a processor core close to the same PCIe or NVLink connection, for example).\n\n```groovy\nprocess {\n  withName: dl_workload {\n     executor = 'lsf'\n     queue = 'gpu_hosts'\n     memory = '16B'\n     clusterOptions = '-gpu \"num=2:mode=exclusive_process\" -n2 -R \"span[ptile=1] affinity[core(1)]\"'\n  }\n}\n```\n\nIn addition to `clusterOptions`, several other settings in the [executor scope](https://nextflow.io/docs/latest/config.html?highlight=queuesize#scope-executor) can be helpful when controlling how jobs behave on an HPC workload manager.\n\n### 5. Decide where to launch your pipeline\n\nLaunching jobs from a head node is common in small HPC clusters. Launching jobs from dedicated job submission hosts (sometimes called login hosts) is more common in large environments. Depending on the workload manager, the head node or job submission host will usually have the workload manager’s client tools pre-installed. These include client binaries such as `sbatch` (Slurm), `qsub` (PBS or Grid Engine), or `bsub` (LSF). Nextflow expects to be able to find these job submission commands on the Linux `PATH`.\n\nRather than launching the Nextflow driver job for a long-running pipeline from the head node or a job submission host, a better practice is to wrap the Nextflow run command in a script and submit the entire workflow as a job. An example using LSF is provided below:\n\n```\n$ cat submit_pipeline.sh\n#!/bin/bash\n#BSUB -q Nextflow\n#BSUB -m \"hostgroupA\"\n#BSUB -o out.%J\n#BSUB -e err.%J\n#BSUB -J headjob\n#BSUB -R \"rusage[mem=16GB]\"\nnextflow run nextflow=io/hello -c my.config -ansi-log false\n\n$ bsub &lt; submit_pipeline.sh\n```\n\nThe specifics will depend on the cluster environment and how the environment is configured. For this to work, the job submission commands must also be available on the execution hosts to which the head job is dispatched. This is not always the case, so you should check with your HPC cluster administrator.\n\nDepending on the workload manager, check your queue or cluster configuration to ensure that submitted jobs can spawn other jobs and that you do not bump up against hard limits. For example, Slurm by default allows a job step to spawn up to 512 tasks per node by default.^7^\n\n### 6. Limit your heap size\n\nSetting the JVM’s max heap size is another good practice when running on an HPC cluster. The Nextflow runtime runs on top of a Java virtual machine which by design, tries to allocate as much memory as possible. To avoid this, specify the maximum amount of memory that can be used by the Java VM using the `-Xms` and `-Xmx` Java flags.\n\nThese can be specified using the `NXF_OPTS` environment variable.\n\n```bash\nexport NFX_OPTS=\"-Xms=512m -Xmx=8g\"\n```\n\nThe `-Xms` flag specifies the minimum heap size, and -Xmx specifies the maximum heap size. In the example above, the minimum heap size is set to 512 MB, which can grow to a maximum of 8 GB. You will need to experiment with appropriate values for each pipeline to determine how many concurrent head jobs you can run on the same host.\n\nFor more information about memory management with Java, consult this [Oracle documentation regarding tuning JVMs](https://docs.oracle.com/cd/E21764_01/web.1111/e13814/jvm_tuning.htm#PERFM150).\n\n### 7. Use the scratch directive\n\nNextflow requires a shared file system path as a working directory to allow the pipeline tasks to share data with each other. When using this model, a common practice is to use the node's local scratch storage as the working directory. This avoids cluster nodes needing to simultaneously read and write files to a shared network file system, which can become a bottleneck.\n\nNextflow implements this best practice which can be enabled by adding the following setting in your `nextflow.config` file.\n\n```groovy\nprocess.scratch = true\n```\n\nBy default, if you enable `process.scratch`, Nextflow will use the directory pointed to by `$TMPDIR` as a scratch directory on the execution host.\n\nYou can optionally specify a specific path for the scratch directory as shown:\n\n```groovy\nprocess.scratch = '/ssd_drive/scratch_dir'\n```\n\nWhen the scratch directive is enabled, Nextflow:\n\n- Creates a unique directory for process execution in the supplied scratch directory;\n- Creates a symbolic link in the scratch directory for each input file in the shared work directory required for job execution;\n- Runs the job using the local scratch path as the working directory;\n- Copies output files to the job's shared work directory on the shared file system when the job is complete.\n\nScratch storage is particularly beneficial for process steps that perform a lot of file system I/O or create large numbers of intermediate files.\n\nTo learn more about Nextflow and how it works with various storage architectures, including shared file systems, check out our recent article [Selecting the right storage architecture for your Nextflow pipelines](https://nextflow.io/blog/2023/selecting-the-right-storage-architecture-for-your-nextflow-pipelines.html).\n\n### 8. Launch pipelines in the background\n\nIf you are launching your pipeline from a login node or cluster head node, it is useful to run pipelines in the background without losing the execution output reported by Nextflow. You can accomplish this by using the -bg switch in Nextflow and redirecting _stdout_ to a log file as shown:\n\n```bash\nnextflow run <pipeline> -bg &gt; my-file.log\n```\n\nThis frees up the interactive command line to run commands such as [squeue](https://slurm.schedmd.com/squeue.html) (Slurm) or [qstat](https://gridscheduler.sourceforge.net/htmlman/htmlman1/qstat.html) (Grid Engine) to monitor job execution on the cluster. It is also beneficial because it prevents network connection issues from interfering with pipeline execution.\n\nNextflow has rich terminal logging and uses ANSI escape codes to update pipeline execution counters interactively as the pipeline runs. If you are logging output to a file as shown above, it is a good idea to disable ANSI logging using the command line option `-ansi-log false` or the environment variable `NXF_ANSI_LOG=false`. ANSI logging can also be disabled when wrapping the Nextflow head job in a script and launching it as a job managed by the workload manager as explained above.\n\n### 9. Retry failing jobs after increasing resource allocation\n\nGetting resource requirements such as cpu, memory, and time is often challenging since resource requirements can vary depending on the size of the dataset processed by each job step. If you request too much resource, you end up wasting resources on the cluster and reducing the effectiveness of the compute environment for everyone. On the other hand, if you request insufficient resources, process steps can fail.\n\nTo address this problem, Nextflow provides a mechanism that allows you to modify the amount of computing resources requested in the case of a process failure on the fly and attempt to re-execute it using a higher limit. For example:\n\n```groovy\nprocess {\n  withName: foo {\n    memory = { 2.GB * task.attempt }\n    time = { 1.hour * task.attempt }\n\n    errorStrategy = { task.exitStatus in 137..140 ? 'retry' : 'terminate' }\n    maxRetries = 3\n  }\n}\n```\n\nYou can manage how many times a job can be retried and specify different behaviours depending on the exit error code. You will see this automated mechanism used in many production pipelines. It is a common practice to double the resources requested after a failure until the job runs successfully.\n\nFor sites running Nextflow Tower, Tower has a powerful resource optimization facility built in that essentially learns per-process resource requirements from previously executed pipelines and auto-generates resource requirements that can be placed in a pipeline's `nextflow.config` file. By using resource optimization in Tower, pipelines will request only the resources that they actually need. This avoids unnecessary delays due to failed/retried jobs and also uses the shared cluster more efficiently.\n\nTower resource optimizations works with all HPC workload managers as well as popular cloud services. You can learn more about resource optimization in the article [Optimizing resource usage with Nextflow Tower](https://seqera.io/blog/optimizing-resource-usage-with-nextflow-tower/).\n\n### 10. Cloud Bursting\n\nCloud bursting is a configuration method in hybrid cloud environments where cloud computing resources are used automatically whenever on-premises infrastructure reaches peak capacity. The idea is that when sites run out of compute capacity on their local infrastructure, they can dynamically burst additional workloads to the cloud.\n\nWith its built-in support for cloud executors, Nextflow handles bursting to the cloud with ease, but it is important to remember that large HPC sites run other workloads beyond Nextflow pipelines. As such, they often have their own bursting solutions tightly coupled to the workload manager.\n\nCommercial HPC schedulers tend to have facilities for cloud bursting built in. While there are many ways to enable burstings, and implementations vary by workload manager, a few examples are provided here:\n\n- Open source Slurm provides a native mechanism to burst workloads to major cloud providers when local cluster resources are fully subscribed. To learn more, see the Slurm [Cloud Scheduling Guide](https://slurm.schedmd.com/elastic_computing.html).\n- IBM Spectrum LSF provides a cloud resource connector enabling policy-driven cloud bursting to various clouds. See the [IBM Spectrum LSF Resource Connector](https://www.ibm.com/docs/en/spectrum-lsf/10.1.0?topic=lsf-resource-connnector) documentation for details.\n- Altair PBS Professional also provides sophisticated support for cloud bursting to multiple clouds, with cloud cost integration features that avoid overspending in the cloud. [See PBS Professional 2022.1](https://altair.service-now.com/community?sys_id=0e9b07dadbf8d150cfd5f6a4e2961997&amp;view=sp&amp;id=community_blog&amp;table=sn_communities_blog).\n- Adaptive Computing offers [Moab Cloud/NODUS Cloud Bursting](https://support.adaptivecomputing.com/wp-content/uploads/2018/08/Moab_Cloud-NODUS_Cloud_Bursting_datasheet_web.pdf), a commercial offering that works with an extensive set of resource providers including AliCloud, OCI, OpenStack, VMware vSphere, and others.\n\nData handling makes cloud bursting complex. Some HPC centers deploy solutions that provide a consistent namespace where on-premises and cloud-based nodes have a consistent view of a shared file system.\n\nIf you are in a larger facility, it's worth having a discussion with your HPC cluster administrator. Cloud bursting may be handled automatically for you. You may be able to use the executor associated with your on-premises workload manager, and simply point your workloads to a particular queue. The good news is that Nextflow provides you with tremendous flexibility.\n\n### 11. Fusion file system\n\nTraditionally, on-premises clusters have used a local shared file system such as NFS or Lustre. The new Fusion file system provides an alternative way to manage data.\n\nFusion is a lightweight, POSIX-compliant file system deployed inside containers that provides transparent access to cloud-based object stores such as Amazon S3. While users running pipelines on local clusters may not have considered using cloud storage, doing so has some advantages:\n\n- Cloud object storage is economical for long-term storage.\n- Object stores such as Amazon S3 provided virtually unlimited capacity.\n- Many reference datasets in life sciences already reside in cloud object stores.\n\nIn cloud computing environments, Fusion FS has demonstrated that it can improve pipeline throughput by up to **2.2x** and reduce long-term cloud storage costs by up to **76%**. To learn more about Fusion file systems and how it works, you can download the whitepaper [Breakthrough performance and cost-efficiency with the new Fusion file system](https://seqera.io/whitepapers/breakthrough-performance-and-cost-efficiency-with-the-new-fusion-file-system/).\n\nRecently, Fusion support has been added for selected HPC workload managers including Slurm, IBM Spectrum LSF, and Grid Engine. This is an exciting development as it enables on-premises cluster users to seamlessly run workload locally using cloud-based storage with minimal configuration effort.\n\n### 12. Additional configuration options\n\nThere are several additional Nextflow configuration options that are important to be aware of when working with HPC clusters. You can find a complete list in the Netflow documentation in the [Scope executor](https://nextflow.io/docs/latest/config.html#scope-executor) section.\n\n`queueSize` – The queueSize parameter is optionally defined in the `nextflow.config` file or within a process and defines how many Nextflow processes can be queued in the selected workload manager at a given time. By default, this value is set to 100 jobs. In large sites with multiple users, HPC cluster administrators may limit the number of pending or executing jobs per user on the cluster. For example, on an LSF cluster, this is done by setting the parameter `MAX_JOBS` in the `lsb.users` file to enforce per user or per group slot limits. If your administrators have placed limits on the number of jobs you can run, you should tune the `queueSize` parameter in Nextflow to match your site enforced maximums.\n\n`submitRateLimit` – Depending on the scheduler, having many users simultaneously submitting large numbers of jobs to a cluster can overwhelm the scheduler on the head node and cause it to become unresponsive to commands. To mitigate this, if your pipeline submits a large number of jobs, it is a good practice to throttle the rate at which jobs will be dispatched from Nextflow. By default the job submission rate is unlimited. If you wanted to allow no more than 50 jobs to be submitted every two minutes, set this parameter as shown:\n\n```groovy\nexecutor.submitRateLimit = '50/2min'\nexecutor.queueSize = 50\n```\n\n`jobName` – Many workload managers have interactive web interfaces or downstream reporting or analysis tools for monitoring or analyzing workloads. A few examples include [Slurm-web](http://rackslab.github.io/slurm-web/introduction.html), [MOAB HPC Suite](https://adaptivecomputing.com/moab-hpc-suite/) (MOAB and Torque), [Platform Management Console](https://www.ibm.com/docs/en/pasc/1.1.1?topic=asc-platform-management-console) (for LSF), [Spectrum LSF RTM](https://www.ibm.com/docs/en/spectrum-lsf-rtm/10.2.0?topic=about-spectrum-lsf-rtm), and [Altair® Access™](https://altair.com/access).\n\nWhen using these tools, it is helpful to associate a meaningful name with each job. Remember, a job in the context of the workload manager maps to a process or task in Nextflow. Use the `jobName` property associated with the executor to give your job a name. You can construct these names dynamically as illustrated below so the job reported by the workload manager reflects the name of our Nextflow process step and its unique ID.\n\n```groovy\nexecutor.jobName = { \"$task.name - $task.hash\" }\n```\n\nYou will need to make sure that generated name matches the validation constraints of the underlying workload manager. This also makes troubleshooting easier because it allows you to cross reference Nextflow log files with files generated by the workload manager.\n\n## The bottom line\n\nIn addition to supporting major cloud environments, Nextflow works seamlessly with a wide variety of on-premises workload managers. If you are fortunate enough to have access to large-scale compute infrastructure at your facility, taking advantage of these powerful HPC workload management integrations is likely the way to go.\n\n---\n\n^1^While this may sound like a contradiction, remember that HPC workload managers can also run in the cloud.\n\n^2^A cloud vCPU is equivalent to a thread on a multicore CPU, and HPC workloads often run with hyperthreading disabled for the best performance. As a result, you may need 64 vCPUs in the cloud to match the performance of a 32-core processor SKU on-premises. Similarly, interconnects such as Amazon Elastic Fabric Adapter (EFA) deliver impressive performance. However, even with high-end cloud instance types, its 100 Gbps throughput falls short compared to interconnects such as [NDR InfiniBand](https://www.hpcwire.com/2020/11/16/nvidia-mellanox-debuts-ndr-400-gigabit-infiniband-at-sc20/) and [HPE Cray Slingshot](https://www.nextplatform.com/2022/01/31/crays-slingshot-interconnect-is-at-the-heart-of-hpes-hpc-and-ai-ambitions/), delivering 400 Gbps or more.\n\n^3^While MPI parallel jobs are less common in Nextflow pipelines, sites may also run fluid dynamics, computational chemistry, or molecular dynamics workloads using tools such as [NWChem](https://www.nwchem-sw.org/) or [GROMACS](https://www.gromacs.org/) that rely on MPI and fast interconnects to facilitate efficient inter-node communication.\n\n^4^Altair’s open-source OpenPBS is distinct from the original OpenPBS project released in 1998 of the same name.\n\n^5^MOAB HPC is a commercial product offered by Adaptive Computing. Its scheduler is based on the open source Maui scheduler.\n\n^6^For some workload managers, knowing how much time a job is expected to run is considered in scheduling algorithms. For example, suppose it becomes necessary to preempt particular jobs when higher priority jobs come along or because of resource ownership issues. In that case, the scheduler may take into account actual vs. estimated runtime to avoid terminating long-running jobs that are closed to completion.\n\n^7^[MaxTasksPerNode](https://slurm.schedmd.com/slurm.conf.html#OPT_MaxTasksPerNode) setting is configurable in the slurm.conf file.\n\n^8^Jobs that request large amounts of resource often pend in queues and take longer to schedule impacting productivity as there may be fewer candidate hosts available that meet the job’s resource requirement.\n</pipeline>",
    "images": [
      "/img/nextflow-on-big-iron-twelve-tips-for-improving-the-effectiveness-of-pipelines-on-hpc-clusters-1.jpg",
      "/img/nextflow-on-big-iron-twelve-tips-for-improving-the-effectiveness-of-pipelines-on-hpc-clusters-2.jpg"
    ],
    "author": "Gordon Sissons",
    "tags": "nextflow"
  },
  {
    "slug": "2023/celebrating-our-largest-international-training-event-and-hackathon-to-date",
    "title": "Celebrating our largest international training event and hackathon to date",
    "date": "2023-04-25T00:00:00.000Z",
    "content": "In mid-March, we conducted our bi-annual Nextflow and [nf-core](https://nf-co.re/) training and hackathon in what was unquestionably our best-attended community events to date. This year we had an impressive **1,345 participants** attend the training from **76 countries**. Attendees came from far and wide — from Algeria to Andorra to Zambia to Zimbabwe!\n\nAmong our event attendees, we observed the following statistics:\n\n- 40% were 30 years old or younger, pointing to a young cohort of Nextflow users;\n- 55.3% identified as male vs. 40% female, highlighting our growing diversity;\n- 68.2% came from research institutions;\n- 71.4% were attending their first Nextflow training event;\n- 96.7% had never attended a Nextflow hackathon.\n\nRead on to learn more about these exciting events. If you missed it, you can still [watch the Nextflow &amp; nf-core training](https://www.youtube.com/playlist?list=PL3xpfTVZLcNhoWxHR0CS-7xzu5eRT8uHo) at your convenience.\n\n<!-- end-archive-description -->\n\n## Multilingual training\n\nThis year, we were pleased to offer [Nextflow / nf-core training](https://nf-co.re/events/2023/training-march-2023) in multiple languages: in addition to English, we delivered sessions in French, Hindi, Portuguese, and Spanish.\n\nIn our pre-event registration, **~88%** of respondents indicated they would watch the training in English. However, there turned out to be a surprising appetite for training in other languages. We hope that multilingual training will make Nextflow even more accessible to talented scientists and researchers around the world.\n\nThe training consisted of four separate sessions in **5 languages** for a total of **20 sessions**. As of April 19th, we’ve amassed over **6,600 YouTube views** with **2,300+ hours** of training watched so far. **27%** have watched the non-English sessions, making the effort at translation highly worthwhile.\n\nThank you to the following people who delivered the training: [Chris Hakkaart](https://twitter.com/Chris_Hakk) (English), [Marcel Ribeiro-Dantas](https://twitter.com/mribeirodantas) (Portuguese), [Maxime Garcia](https://twitter.com/gau) (French), [Julia Mir Pedrol](https://twitter.com/juliamirpedrol) and [Gisela Gabernet](https://twitter.com/GGabernet) (Spanish), and [Abhinav Sharma](https://twitter.com/abhi18av) (Hindi).\n\nYou can view the community training sessions on YouTube here:\n\n- [March 2023 Community Training – English](https://www.youtube.com/playlist?list=PL3xpfTVZLcNhoWxHR0CS-7xzu5eRT8uHo)\n- [March 2023 Community Training – Portugese](https://www.youtube.com/playlist?list=PL3xpfTVZLcNhi41yDYhyHitUhIcUHIbJg)\n- [March 2023 Community Training – French](https://www.youtube.com/playlist?list=PL3xpfTVZLcNhiv9SjhoA1EDOXj9nzIqdS)\n- [March 2023 Community Training – Spanish](https://www.youtube.com/playlist?list=PL3xpfTVZLcNhSlCWVoa3GURacuLWeFc8O)\n- [March 2023 Community Training – Hindi](https://www.youtube.com/playlist?list=PL3xpfTVZLcNikun1FrSvtXW8ic32TciTJ)\n\nThe videos accompany the written training material, which you can find at [https://training.nextflow.io/](https://training.nextflow.io/)\n\n## Improved community training resources\n\nAlong with the updated training and hackathon resources above, we’ve significantly enhanced our online training materials available at [https://training.nextflow.io/](https://training.nextflow.io/). Thanks to the efforts of our volunteers, technical training, [Gitpod resources](https://training.nextflow.io/basic_training/setup/#gitpod), and materials for hands-on, self-guided learning are now available in English and Portuguese. Some of the materials are also available in Spanish and French.\n\nThe training comprises a significant set of resources covering topics including managing dependencies, containers, channels, processes, operators, and an introduction to the Groovy language. It also includes topics related to nf-core for users and developers as well as Nextflow Tower. Marcel Ribeiro-Dantas describes his experience leading the translation effort for this documentation in his latest nf-core/bytesize [translation talk](https://nf-co.re/events/2023/bytesize_translations).\n\nAdditional educational resources are provided in the recent Seqera Labs blog article, [Learn Nextflow in 2023](https://nextflow.io/blog/2023/learn-nextflow-in-2023.html), posted in February before our latest training event.\n\n## The nf-core hackathon\n\nWe also ran a separate [hackathon](https://nf-co.re/events/2023/hackathon-march-2023) event from March 27th to 29th. This hackathon ran online via Gather, a virtual hosting platform, but for the first time we also asked community members to host local sites. We were blown away by the response, with volunteers coming forward to organize in-person attendance in 16 different locations across the world (and this was before we announced that Seqera would organize pizza for all the sites!). These gatherings had a big impact on the feel of the hackathon, whilst remaining accessible and eco-friendly, avoiding the need for air travel.\n\nThe hackathon was divided into five focus areas: modules, pipelines, documentation, infrastructure, and subworkflows. We had **411** people register, including **278 in-person attendees** at **16 locations**. This is an increase of **38%** compared to the **289** people that attended our October 2022 event. The hackathon was hosted in multiple countries including Brazil, France, Germany, Italy, Poland, Senegal, Serbia, South Africa, Spain, Sweden, the UK, and the United States.\n\nWe would like to thank the many organizations worldwide who provided a venue to host the hackathon and helped make it a resounding success. Besides being an excellent educational event, we resolved many longstanding Nextflow and nf-core issues.\n\n<div style=\"margin-top: 1rem\">\n    <img src=\"/img/celebrating-our-largest-international-training-event-and-hackathon-to-date-1.jpg\" alt=\"Hackathon photo\">\n</div>\n\nYou can access the project reports from each hackathon team over the three-day event compiled in HackMD below:\n\n- [Modules team](https://hackmd.io/A5v4soteQjKywl3UgFa_6g)\n- [Pipelines Team](https://hackmd.io/Bj_MK3ubQWGBD4t0X2KpjA)\n- [Documentation Team](https://hackmd.io/o6AgPTZ7RBGCyZI72O1haA)\n- [Infrastructure Team](https://hackmd.io/uC-mZlEXQy6DaXZdjV6akA)\n- [Subworkflows Team](https://hackmd.io/Udtvj4jASsWLtMgrbTNwBA)\n\nYou can also view ten Hackathon videos outlining the event, introducing an overview of the teams, and daily hackathon activities in the [March 2023 nf-core hackathon YouTube playlist](https://www.youtube.com/playlist?list=PL3xpfTVZLcNhfyF_QJIfSslnxRCU817yc). Check out activity in the nf-core hackathon March 2023 Github [issues board](https://github.com/orgs/nf-core/projects/38/views/16?layout=board) for a summary of what each team worked on.\n\n## A diverse and growing community\n\nWe were particularly pleased to see the growing diversity of the Nextflow and nf-core community membership, enabled partly by support from the Chan Zuckerberg Initiative Diversity and Inclusion grant and our nf-core mentorship programs. You can learn more about our mentorship efforts and exciting efforts of our global team in Chris Hakkaart’s excellent post, [Nextflow and nf-core Mentorship](https://nextflow.io/blog/2023/czi-mentorship-round-2.html) on the Nextflow blog.\n\nThe growing diversity of our community was also reflected in the results of our latest Nextflow Community survey, which you can read more about on the [Seqera Labs blog](https://seqera.io/blog/the-state-of-the-workflow-2023-community-survey-results/).\n\n<div style=\"margin-top: 1rem\">\n    <img src=\"/img/celebrating-our-largest-international-training-event-and-hackathon-to-date-2.jpg\" alt=\"Hackathon photo\">\n</div>\n\n## Looking forward\n\nRunning global events at this scale takes a tremendous team effort. The resources compiled will be valuable in introducing more people to Nextflow and nf-core. Thanks to everyone who participated in this year’s training and hackathon events. We look forward to making these even bigger and better in the future!\n\nThe next community training will be held online September 2023. This will be followed by two Nextflow Summit events with associated nf-core hackathons:\n\n- Barcelona: October 16-20, 2023\n- Boston: November 2023 (dates to be confirmed)\n\nIf you’d like to join, you can register to receive news and updates about the events at [https://summit.nextflow.io/summit-2023-preregistration/](https://summit.nextflow.io/summit-2023-preregistration/)\n\nYou can follow us on Twitter at [@nextflowio](https://twitter.com/nextflowio) or [@nf_core](https://twitter.com/nf_core) or join the discussion on the [Nextflow](https://www.nextflow.io/slack-invite.html) and [nf-core](https://nf-co.re/join) community Slack channels.\n\n<div style=\"margin-top: 1rem\">\n    <img src=\"/img/celebrating-our-largest-international-training-event-and-hackathon-to-date-3.jpg\" alt=\"Hackathon photo\">\n</div>\n\n<div style=\"margin-top: 1rem\">\n    <img src=\"/img/celebrating-our-largest-international-training-event-and-hackathon-to-date-4.jpg\" alt=\"Hackathon photo\">\n</div>",
    "images": [
      "/img/celebrating-our-largest-international-training-event-and-hackathon-to-date-1.jpg",
      "/img/celebrating-our-largest-international-training-event-and-hackathon-to-date-2.jpg",
      "/img/celebrating-our-largest-international-training-event-and-hackathon-to-date-3.jpg",
      "/img/celebrating-our-largest-international-training-event-and-hackathon-to-date-4.jpg"
    ],
    "author": "Phil Ewels",
    "tags": "nextflow"
  },
  {
    "slug": "2023/community-forum",
    "title": "Introducing community.seqera.io",
    "date": "2023-10-18T00:00:00.000Z",
    "content": "We are very excited to introduce the [Seqera community forum](https://community.seqera.io/) - the new home of the Nextflow community!\n\n[community.seqera.io](https://community.seqera.io/)\n\nThe growth of the Nextflow community over recent years has been phenomenal. The Nextflow Slack organization was launched in early 2022 and has already reached a membership of nearly 3,000 members. As we look ahead to growing to 5,000 and even 50,000, we are making a new tool available to the community: a community forum.\n\nWe expect the new forum to coexist with the Nextflow Slack. The forum will be great at medium-format discussion, whereas Slack is largely designed for short-term ephemeral conversations. We want to support this growth of the community and believe the new forum will allow us to scale.\n\nDiscourse is an open-source, web-based platform designed for online community discussions and forum-style interactions. Discourse offers a user-friendly interface, real-time notifications, and a wide range of customization options. It prioritizes healthy and productive conversations by promoting user-friendly features, such as trust levels, gamification, and robust moderation tools. Discourse is well known for its focus on fostering engaging and respectful discussions and already caters to many large developer communities. It’s able to serve immense groups, giving us confidence that it will meet the needs of our growing developer community just as well. We believe that Discourse is a natural fit for the evolution of the Nextflow community.\n\n<img src=\"/img/seqera-community-all.png\" title=\"The new Seqera community forum\">\n\nThe community forum offers many exciting new features. Here are some of the things you can expect:\n\n- **Open content:** Content on the new forum is public – accessible without login, indexed by Google, and can be linked to directly. This means that it will be much easier to find answers to your problems, as well as share solutions on other platforms.\n- **Don’t ask the same thing twice:** It’s not always easy to find answers when there’s a lot of content available. The community forum helps you by suggesting similar topics as you write a new post. An upcoming [Discourse AI Bot](https://www.discourse.org/plugins/ai.html) may even allow you to ask questions using natural language in the future!\n- **Stay afloat:** The community forum will ensure developers have a space where they can post without fear that what they write might be drowned out, and where anything that our community finds useful will rise to the top of the list. Discourse will give life to threads with high-quality content that may have otherwise gone unnoticed and lost in a sea of new posts.\n- **Better organized:** The forum model for categories, tags, threads, and quoting forces conversations to be structured. Many questions involve the broader Nextflow ecosystem, tagging with multiple topics will cut through the noise and allow people to participate in targeted and well-labeled discussions. Importantly, maintainers can move miscategorized posts without asking the original author to delete and write again.\n- **Multi-product:** The forum has categories for Nextflow but also [Seqera Platform](https://seqera.io/platform/), [MultiQC](https://seqera.io/multiqc/), [Wave](https://seqera.io/wave/), and [Fusion](https://seqera.io/fusion/). Questions that involve multiple Seqera products can now span these boundaries, and content can be shared between posts easily.\n- **Community recognition:** The community forum will encourage a healthy ecosystem of developers that provides value to everyone involved and rewards the most active users. The new forum encourages positive community behaviors through features such as badges, a trust system, and community moderation. There’s even a [community leaderboard](https://community.seqera.io/leaderboard/)! We plan to gradually introduce additional features over time as adoption grows.\n\nOnline discussion platforms have been the beating heart of the Nextflow community from its inception. The first was a Google groups email list, which was followed by the Gitter instant messaging platform, GitHub Discussions, and most recently, Slack. We’re thrilled to embark on this new chapter of the Nextflow community – let us know what you think and ask any questions you might have in the [“Site Feedback” forum category](https://community.seqera.io/c/community/site-feedback/2)! Join us today at [https://community.seqera.io](https://community.seqera.io/) for a new and improved developer experience.\n\n[Visit the Seqera community forum](https://community.seqera.io/)",
    "images": [
      "/img/seqera-community-all.png"
    ],
    "author": "Phil Ewels",
    "tags": "nextflow,community"
  },
  {
    "slug": "2023/czi-mentorship-round-2",
    "title": "Nextflow and nf-core Mentorship, Round 2",
    "date": "2023-04-17T00:00:00.000Z",
    "content": "## Introduction\n\n<div class=\"pull-right\" style=\" max-width: 30%; margin-left: 2rem; padding: 2rem;\">\n    <img src=\"/img/mentorships-round2-rocket.png\" alt=\"Mentorship rocket.\">\n    \n\n*Nextflow and nf-core mentorship rocket.*\n\n</div>\n\nThe global Nextflow and nf-core community is thriving with strong engagement in several countries. As we continue to expand and grow, we remain committed to prioritizing inclusivity and actively reaching groups with low representation.\n\nThanks to the support of our Chan Zuckerberg Initiative Diversity and Inclusion grant, we established an international Nextflow and nf-core mentoring program. With the second round of the mentorship program now complete, we celebrate the success of the most recent cohort of mentors and mentees.\n\nFrom hundreds of applications, thirteen pairs of mentors and mentees were chosen for the second round of the program. For the past four months, they met regularly to collaborate on Nextflow or nf-core projects. The project scope was left up to the mentees, enabling them to work on any project aligned with their scientific interests and schedules.\n\nMentor-mentee pairs worked on a range of projects that included learning Nextflow and nf-core fundamentals, setting up Nextflow on their institutional clusters, translating Nextflow training material into other languages, and developing and implementing Nextflow and nf-core pipelines. Impressively, despite many mentees starting the program with very limited knowledge of Nextflow and nf-core, they completed the program with confidence and improved their abilities to develop and implement scalable and reproducible scientific workflows.\n\n![Map of mentor and mentee pairs](/img/mentorships-round2-map.png)<br>\n_The second round of the mentorship program was global._\n\n## Jing Lu (Mentee) &amp; Moritz Beber (Mentor)\n\nJing joined the program with the goal of learning how to develop advanced Nextflow pipelines for disease surveillance at the Guangdong Provincial Center for Diseases Control and Prevention in China. His mentor was Moritz Beber from Denmark.\n\nTogether, Jing and Moritz developed a pipeline for the analysis of SARS-CoV-2 genomes from sewage samples. They also used GitHub and docker containers to make the pipeline more sharable and reproducible. In the future, Jing hopes to use Nextflow Tower to share the pipeline with other institutions.\n\n## Luria Leslie Founou (Mentee) &amp; Sebastian Malkusch (Mentor)\n\nLuria's goal was to accelerate her understanding of Nextflow and apply it to her exploration of the resistome, virulome, mobilome, and phylogeny of bacteria at the Research Centre of Expertise and Biological Diagnostic of Cameroon. Luria was mentored by Sebastian Malkusch, Kolja Becker, and Alex Peltzer from the Boehringer Ingelheim Pharma GmbH &amp; Co. KG in Germany.\n\nFor their project, Luria and her mentors developed a [pipeline](https://github.com/SMLMS/nfml) for mapping multi-dimensional feature space onto a discrete or continuous response variable by using multivariate models from the field of classical machine learning. Their pipeline will be able to handle classification, regression, and time-to-event models and can be used for model training, validation, and feature selection.\n\n## Sebastian Musundi (Mentee) &amp; Athanasios Baltzis (Mentor)\n\nSebastian, from Mount Kenya University in Kenya, joined the mentorship program with the goal of using Nextflow pipelines to identify vaccine targets in Apicomplexan parasites. He was mentored by Athanasios Balzis from the Centre for Genomic Regulation in Spain.\n\nWith Athanasios’s help, Sebastian learned the fundamentals for developing Nextflow pipelines. During the learning process, they developed a [pipeline](https://github.com/sebymusundi/simple_RNA-seq) for customized RNA sequencing and a [pipeline](https://github.com/sebymusundi/AMR_pipeline) for predicting antimicrobial resistance genes. With his new skills, Sebastian plans to keep using Nextflow on a daily basis and start contributing to nf-core.\n\n## Juan Ugalde (Mentee) &amp; Robert Petit (Mentor)\n\nJuan joined the mentorship program with the goal of improving his understanding of Nextflow to support microbial and viral analysis at the Universidad Andres Bello in Chile. Juan was mentored by Robert Petit from the Wyoming Public Health Laboratory in the USA. Robert is an experienced Nextflow mentor who also mentored in Round 1 of the program.\n\nJuan and Robert shared an interest in viral genomics. After learning more about the Nextflow and nf-core ecosystem, Robert mentored Juan as he developed a Nextflow viral amplicon analysis [pipeline](https://github.com/gene2dis/hantaflow). Juan will continue his Nextflow and nf-core journey by sharing his new knowledge with his group and incorporating it into his classes in the coming semester.\n\n## Bhargava Reddy Morampalli (Mentee) &amp; Venkat Malladi (Mentor)\n\nBhargava studies at Massey University in New Zealand and joined the program with the goal of improving his understanding of Nextflow and resolving issues he was facing while developing a pipeline to analyze Nanopore direct RNA sequencing data. Bhargava was mentored by Venkat Malladi from Microsoft in the USA.\n\nBhargava and Venkat worked on Bhargava’s [pipeline](https://github.com/bhargava-morampalli/rnamods-nf/) to identify RNA modifications from bacteria. Their successes included advancing the pipeline and making Singularity images for the tools Bhargava was using to make it more reproducible. For Bhargava, the mentorship program was a great kickstart for learning Nextflow and his pipeline development. He hopes to continue to develop his pipeline and optimize it for cloud platforms in the future.\n\n## Odion Ikhimiukor (Mentee) &amp; Ben Sherman (Mentor)\n\nBefore the program, Odion, who is at the University at Albany in the USA, was new to Nextflow and nf-core. He joined the program with the goal of improving his understanding and to learn how to develop pipelines for bacterial genome analysis. His mentor Ben Sherman works for Seqera Labs in the USA.\n\nDuring the program Odion and Ben developed a [pipeline](https://github.com/odionikh/nf-practice) to analyze bacterial genomes for antimicrobial resistance surveillance. They also developed configuration settings to enable the deployment of their pipeline with high and low resources. Odion has plans to share his new knowledge with others in his community.\n\n## Batool Almarzouq (Mentee) &amp; Murray Wham (Mentor)\n\nBatool works at the King Abdullah International Medical Research Center in Saudi Arabia. Her goal for the mentorship program was to contribute to, and develop, nf-core pipelines.\nAdditionally, she aimed to develop new educational resources for nf-core that can support researchers from lowly represented groups. Her mentor was Murray Wham from the ​​University of Edinburgh in the UK.\n\nDuring the mentorship program, Murray helped Batool develop her molecular dynamics pipeline and participate in the 1st Biohackathon in MENA (KAUST). Batool and Murray also found ways to make documentation more accessible and are actively promoting Nextlfow and nf-core in Saudi Arabia.\n\n## Mariama Telly Diallo (Mentee) &amp; Emilio Garcia (Mentor)\n\nMariama Telly joined the mentorship program with the goal of developing and implementing Nextflow pipelines for malaria research at the Medical Research Unit at The London School of Hygiene and Tropical Medicine in Gambia. She was mentored by Emilio Garcia from Platomics in Austria. Emilio is another experienced mentor who joined the program for a second time.\n\nTogether, Mariama Telly and Emilio worked on learning the basics of Nextflow, Git, and Docker. Putting these skills into practice they started to develop a Nextflow pipeline with a docker file and custom configuration. Mariama Telly greatly improved her understanding of best practices and Nextflow and intends to use her newfound knowledge for future projects.\n\n## Anabella Trigila (Mentee) &amp; Matthias De Smet (Mentor)\n\nAnabella’s goal was to set up Nextflow on her institutional cluster at Héritas S.A. in Argentina and translate some bash pipelines into Nextflow pipelines. Anabella was mentored by Matthias De Smet from Ghent University in Belgium.\n\nAnabella and Matthias worked on developing several new nf-core modules. Extending this, they started the development of a [pipeline](https://github.com/atrigila/nf-core-saliva) to process VCFs obtained from saliva samples and a [pipeline](https://github.com/atrigila/nf-core-ancestry) to infer ancestry from VCF samples. Anabella has now transitioned from a user to a developer and made multiple contributions to the most recent nf-core hackathon. She also contributed to the Spanish translation of the Nextflow [training material](https://training.nextflow.io/es/).\n\n## Juliano de Oliveira Silveira (Mentee) &amp; Maxime Garcia (Mentor)\n\nJuliano works at the Laboratório Central de Saúde Pública RS in Brazil. He joined the program with the goal of setting up Nextflow at his institution, which led him to learn to write his own pipelines. Juliano was mentored by Maxime Garcia from Seqera Labs in Sweden.\n\nJuliano and Maxime worked on learning about Nextflow and nf-core. Juliano applied his new skills to an open-source bioinformatics program that used Nextflow with a customized R script. Juliano hopes to give back to the wider community and peers in Brazil.\n\n## Patricia Agudelo-Romero (Mentee) &amp; Abhinav Sharma (Mentor)\n\nPatricia's goal was to create, customize, and deploy nf-core pipelines at the Telethon Kids Institute in Australia. Her mentor was Abhinav Sharma from Stellenbosch University in South Africa.\n\nAbhinav helped Patricia learn how to write reproducible pipelines with Nextflow and how to work with shared code repositories on GitHub. With Abhinav's support, Patricia worked on translating a Snakemake [pipeline](https://github.com/agudeloromero/everest_nf) designed for genome virus identification and classification into Nextflow. Patricia is already applying her new skills and supporting others at her institute as they adopt Nextflow.\n\n## Mariana Guilardi (Mentee) &amp; Alyssa Briggs (Mentor)\n\nMariana’s goal was to learn the fundamentals of Nextflow, construct and run pipelines, and help with nf-core pipeline development. Her mentor was Alyssa Briggs from the University of Texas at Dallas in the USA\n\nAt the start of the program, Alyssa helped Mariana learn the fundamentals of Nextflow. With Alyssa’s help, Mariana’s skills progressed rapidly and by the end of the program, they were running pipelines and developing new nf-core modules and the [nf-core/viralintegration](https://github.com/nf-core/viralintegration) pipeline. Mariana also made community contributions to the Portuguese translation of the Nextflow [training material](https://training.nextflow.io/pt/).\n\n## Liliane Cavalcante (Mentee) &amp; Marcel Ribeiro-Dantas (Mentor)\n\nLiliane’s goal was to develop and apply Nextflow pipelines for genomic and epidemiological analyses at the Laboratório Central de Saúde Pública Noel Nutels in Brazil. Her mentor was Marcel Ribeiro-Dantas from Seqera Labs in Brazil.\n\nLiliane and Marcel used Nextflow and nf-core to analyze SARS-CoV-2 genomes and demographic data for public health surveillance. They used the [nf-core/viralrecon](https://nf-co.re/viralrecon) pipeline and made a new Nextflow script for additional analysis and generating graphs.\n\n## Conclusion\n\nAs with the first round of the program, the feedback about the second round of the mentorship program was overwhelmingly positive. All mentees found the experience to be highly beneficial and were grateful for the opportunity to participate.\n\n&gt; *“Having a mentor guide through the entire program was super cool. We worked all the way from the basics of Nextflow and learned a lot about developing and debugging pipelines. Today, I feel more confident than before in using Nextflow on a daily basis.”* - Sebastian Musundi (Mentee)\n\nSimilarly, the mentors also found the experience to be highly rewarding.\n\n&gt; *“As a mentor, I really enjoyed participating in the program. Not only did I have the chance to support and work with colleagues from lowly represented regions, but also I learned a lot and improved myself through the mentoring and teaching process.”* - Athanasios Baltzis (Mentor)\n\nImportantly, all program participants expressed their willingness to encourage others to be part of it in the future.\n\n&gt; *“The mentorship allows mentees not only to learn nf-core/Nextflow but also a lot of aspects about open-source reproducible research. With your learning, at the end of the mentorship, you could even contribute back to the nf-core community, which is fantastic! I would tell everyone who is interested in the program to go for it.”* - Anabella Trigila (Mentee)\n\nAs the Nextflow and nf-core communities continue to grow, the mentorship program will have long-lasting benefits beyond those that can be immediately measured. Mentees from the program have already become positive role models, contributing new perspectives to the broader community.\n\n&gt; *“I highly recommend this program. Independent if you are new to Nextflow or already have some experience, the possibility of working with amazing people to learn about the Nextflow ecosystem is invaluable. It helped me to improve my work, learn new things, and become confident enough to teach Nextflow to students.”* - Juan Ugalde (Mentee)\n\nWe were delighted with the achievements of the mentors and mentees. Applications for the third round are now open! For more information, please visit https://nf-co.re/mentorships.",
    "images": [
      "/img/mentorships-round2-rocket.png"
    ],
    "author": "Chris Hakkaart",
    "tags": "nextflow,nf-core,czi,mentorship,training"
  },
  {
    "slug": "2023/czi-mentorship-round-3",
    "title": "Nextflow and nf-core Mentorship, Round 3",
    "date": "2023-11-13T00:00:00.000Z",
    "content": "<div class=\"pull-right\" style=\" max-width: 30%; margin-left: 2rem; padding: 2rem;\">\n    <img src=\"/img/mentorship_3_sticker.png\" alt=\"Mentorship rocket.\">\n    \n\n*Nextflow and nf-core mentorship rocket.*\n\n</div>\n\nWith the third round of the [Nextflow and nf-core mentorship program](https://nf-co.re/mentorships) now behind us, it's time to pop the confetti and celebrate the outstanding achievements of our latest group of mentors and mentees!\n\nAs with the [first](https://www.nextflow.io/blog/2022/czi-mentorship-round-1.html) and [second](https://www.nextflow.io/blog/2023/czi-mentorship-round-2.html) rounds of the program, we received hundreds of applications from all over the world. Mentors and mentees were matched based on compatible interests and time zones and set off to work on a project of their choosing. Pairs met regularly to work on their projects and reported back to the group to discuss their progress every month.\n\nThe mentor-mentee duos chose to tackle many interesting projects during the program. From learning how to develop pipelines with Nextflow and nf-core, setting up Nextflow on their institutional clusters, and translating Nextflow training materials into other languages, this cohort of mentors and mentees did it all. Regardless of all initial challenges, every pair emerged from the program brimming with confidence and a knack for building scalable and reproducible scientific workflows with Nextlfow. Way to go, team!\n\n![Map of mentor and mentee pairs](/img/mentorship_3_map.png)<br>\n_Participants of the third round of the mentorship program._\n\n## Abhay Rastogi and Matthias De Smet\n\nAbhay Rastogi is a Clinical Research Fellow at the All India Institute Of Medical Sciences (AllMS Delhi). During the program, he wanted to contribute to the [nf-core/sarek](https://github.com/nf-core/sarek/) pipeline. He was mentored by Matthias De Smet, a Bioinformatician at the Center for Medical Genetics in the Ghent University Hospital. Together they worked on developing an nf-core module for Exomiser, a variant prioritization tool for short-read WGS data that they hope to incorporate into [nf-core/sarek](https://github.com/nf-core/sarek/). Keep an eye out for this brand new feature as they continue to work towards implementing this new feature into the [nf-core/sarek](https://github.com/nf-core/sarek/) pipeline!\n\n## Alan Möbbs and Simon Pearce\n\nAlan Möbbs, a Bioinformatics Analyst at MultiplAI, was mentored by Simon Pearce, Principal Bioinformatician at the Cancer Research UK Cancer Biomarker Centre. During the program, Alan wanted to create a custom pipeline that merges functionalities from the [nf-core/rnaseq](https://github.com/nf-core/rnaseq/) and [nf-core/rnavar](https://github.com/nf-core/rnavar/) pipelines. They started their project by forking the [nf-core/rnaseq](https://github.com/nf-core/rnaseq/) pipeline and adding a subworkflow with variant calling functionalities. As the project moved on, they were able to remove tools from the pipeline that were no longer required. Finally, they created some custom definitions for processing samples and work queues to optimize the workflow on AWS. Alan plans to keep working on this project in the future.\n\n## Cen Liau and Chris Hakkaart\n\nCen Liau is a scientist at the Bragato Research Institute in New Zealand, analyzing the epigenetics of grapevines in response to environmental stress. Her mentor was Chris Hakkaart, a Developer Advocate at Seqera. They started the program by deploying the [nf-core/methylseq](https://github.com/nf-core/methylseq/) pipeline on New Zealand’s national infrastructure to analyze data Cen had produced. Afterward, they started to develop a proof of concept methylation pipeline to analyze additional data Cen has produced. Along the way, they learned about nf-core best practices and how to use GitHub to build pipelines collaboratively.\n\n## Chenyu Jin and Ben Sherman\n\nChenyu Jin is a Ph.D. student at the Center for Palaeogenetics of the Swedish Museum of Natural History. She worked with Ben Sherman, a Software Engineer at Seqera. Together they worked towards establishing a workflow for recursive step-down classification using experimental Nextflow features. During the program, they made huge progress in developing a cutting-edge pipeline that can be used for analyzing ancient environmental DNA and reconstructing flora and fauna. Watch this space for future developments!\n\n## Georgie Samaha and Cristina Tuñí i Domínguez\n\nGeorgie Samaha, a bioinformatician from the University of Sydney, was mentored by Cristina Tuñi i Domínguez, a Bioinformatics Scientist at Flomics Biotech SL. During the program, they developed Nextflow configuration files. As a part of this, they built institutional configuration files for multiple national research HPC and cloud infrastructures in Australia. Towards the end of the mentorship, they [built a tool for building configuration files](https://github.com/georgiesamaha/configBuilder-nf) that they hope to share widely in the future.\n\n## Ícaro Maia Santos de Castro and Robert Petit\n\nÍcaro Maia Santos is a Ph.D. Candidate at the University of São Paulo. He was mentored by Robert, a Research Scientist from Wyoming Public Health Lab. After learning the basics of Nextflow and nf-core, they worked on a [metatranscriptomics pipeline](https://github.com/icaromsc/nf-core-phiflow) that simultaneously characterizes microbial composition and host gene expression RNA sequencing samples. As a part of this process, they used nf-core modules that were already available and developed and contributed new modules to the nf-core repository. Ícaro found having someone to help him learn and overcome issues as he was developing his pipeline was invaluable for his career.\n\n![phiflow metro map](/img/phiflow_metro_map.png)<br>\n_Metro map of the phiflow workflow._\n\n## Lila Maciel Rodríguez Pérez and Priyanka Surana\n\nLila Maciel Rodríguez Pérez, from the National Agrarian University in Peru, was mentored by Priyanka Surana, a researcher from the Wellcome Sanger Institute in the UK. Lila and Priyanka focused on building and deploying Nextflow scripts for metagenomic assemblies. In particular, they were interested in the identification of Antibiotic-Resistant Genes (ARG), Metal-Resistant Genes (MRG), and Mobile Genetic Elements (MGE) in different environments, and in figuring out how these genes are correlated. Both Lila and Priyanka spoke highly of each other and how much they enjoyed being a part of the program.\n\n## Luisa Sacristan and Gisela Gabernet\n\nLuisa is an MSc. student studying computational biology in the Computational Biology and Microbial Ecology group at Universidad de los Andes in Colombia. She was mentored by Gisela Gabernet, a researcher at Yale Medical School. At the start of the program, Luisa and Gisela focused on learning more about GitHub. They quickly moved on to developing an nf-core configuration file for Luisa’s local university cluster. Finally, they started developing a pipeline for the analysis of custom ONT metagenomic amplicons from coffee beans.\n\n## Natalia Coutouné and Marcel Ribeiro-Dantas\n\nNatalia Coutoné is a Ph.D. Candidate at the University of Campinas in Brazil. Her mentor was Marcel Ribeiro-Dantas from Seqera. Natalia and Marcel worked on developing a pipeline to identify relevant QTL among two or more pool-seq samples. Learning the little things, such as how and where to get help was a valuable part of the learning process for Natalia. She also found it especially useful to consolidate a “Frankenstein” pipeline she had been using into a cohesive Nextflow pipeline that she could share with others.\n\n## Raquel Manzano and Maxime Garcia\n\nRaquel Manzano is a bioinformatician and Ph.D. candidate at the University of Cambridge, Cancer Research UK Cambridge Institute. She was mentored by Maxime Garcia, a bioinformatics engineer at Seqera. During the program, they spent their time developing the [nf-core/rnadnavar](https://github.com/nf-core/rnadnavar/) pipeline. Initially designed for cancer research, this pipeline identifies a consensus call set from RNA and DNA somatic variant calling tools. Both Raquel and Maxime found the program to be highly rewarding. Raquel’s [presentation](https://www.youtube.com/watch?v=PzGOvqSI5n0) about the rnadnavar pipeline and her experience as a mentee from the 2023 Nextflow Summit in Barcelona is now online.\n\n## Conclusion\n\nWe are thrilled to report that the feedback from both mentors and mentees has been overwhelmingly positive. Every participant, whether mentor or mentee, found the experience extremely valuable and expressed gratitude for the chance to participate.\n\n&gt; *“I loved the experience and the opportunity to develop my autonomy in nextflow/nf-core. This community is totally amazing!”* - Icaro Castro\n\n&gt; *“I think this was a great opportunity to learn about a tool that can make our day-to-day easier and reproducible. Who knows, maybe it can give you a better chance when applying for jobs.”* - Alan Möbbs\n\nThanks to the fantastic support of the Chan Zuckerberg Initiative Diversity and Inclusion grant, Seqera, and our fantastic community, who made it possible to run all three rounds of the Nextflow and nf-core mentorship program.",
    "images": [
      "/img/mentorship_3_sticker.png"
    ],
    "author": "Marcel Ribeiro-Dantas",
    "tags": "nextflow,nf-core,czi,mentorship"
  },
  {
    "slug": "2023/geraldine-van-der-auwera-joins-seqera",
    "title": "Geraldine Van der Auwera joins Seqera",
    "date": "2023-10-11T00:00:00.000Z",
    "content": "<img src=\"/img/geraldine-van-der-auwera.jpg\" style=\"float:right;width:250px;margin: 0 0 15px 15px\">\n\nI’m excited to announce that I’m joining Seqera as Lead Developer Advocate. My mission is to support the growth of the Nextflow user community, especially in the USA, which will involve running community events, conducting training sessions, managing communications and working globally with our partners across the field to ensure Nextflow users have what they need to be successful. I’ll be working remotely from Boston, in collaboration with Paolo, Phil and the rest of the Nextflow team.\n\nSome of you may already know me from my previous job at the Broad Institute, where I spent a solid decade doing outreach and providing support for the genomics research community, first for GATK, then for WDL and Cromwell, and eventually Terra. A smaller subset might have come across the O’Reilly book I co-authored, [Genomics on the Cloud](https://www.oreilly.com/library/view/genomics-in-the/9781491975183/).\n\nThis new mission is very much a continuation of my dedication to helping the research community use cutting-edge software tools effectively.\n\n## From bacterial cultures to large-scale genomics\n\nTo give you a brief sense of where I’m coming from, I originally trained as a wetlab microbiologist in my homeland of Belgium, so it’s fair to say I’ve come a long way, quite literally. I never took a computing class, but taught myself Python during my PhD to analyze bacterial plasmid sequencing data (72 kb of Sanger sequence!) and sort of fell in love with bioinformatics in the process. Later, I got the opportunity to deepen my bioinformatics skills during my postdoc at Harvard Medical School, although my overall research project was still very focused on wetlab work.\n\nToward the end of my postdoc, I realized I had become more interested in the software side of things, though I didn’t have any formal qualifications. Fortunately I was able to take a big leap sideways and found a new home at the Broad Institute, where I was hired as a Bioinformatics Scientist to build out the GATK community, at a time when it was still a bit niche. (It’s a long story that I don’t have time for today, but I’m always happy to tell it over drinks at a conference reception…)\n\nThe GATK job involved providing technical and scientific support to researchers, developing documentation, and teaching workshops about genomics and variant calling specifically. Which is hilarious because at the time I was hired, I had no clue what variant calling even meant! I think I was easily a month or two into the job before that part actually started making a little bit of sense. I still remember the stress and confusion of trying to figure all that out, and it’s something I always carry with me when I think about how to help newcomers to the ecosystem. I can safely say, whatever aspect of this highly multidisciplinary field is causing you trouble, I’ve struggled with it myself at some point.\n\nAnyway, I can’t fully summarize a decade in a couple of paragraphs, but suffice to say, I learned an enormous amount on the job. And in the process, I developed a passion for helping researchers take maximum advantage of the powerful bioinformatics at their disposal. Which inevitably involves workflows.\n\n## Going with the flow\n\nOver time my responsibilities at the Broad grew into supporting not just GATK, but also the workflow systems people use to run tools like GATK at scale, both on premises and increasingly, on public cloud platforms. My own pipelining experience has been focused on WDL and Cromwell, but I’ve dabbled with most of the mainstream tools in the space.\n\nIf I had a dollar for every time I’ve been asked the question “What’s the best workflow language?” I’d still need a full-time job, but I could maybe take a nice holiday somewhere warm. Oh, and my answer is: whatever gets the work done, plays nice with the systems you’re tied to, and connects you to a community.\n\nThat’s one of the reasons I’ve been watching the growth of Nextflow’s popularity with great interest for the last few years. The amount of community engagement that we’ve seen around Nextflow, and especially around the development of nf-core, has been really impressive.\n\nSo I’m especially thrilled to be joining the Seqera team the week of the [Nextflow Summit](https://summit.nextflow.io/) in Barcelona, because it means I’ll get to meet a lot of people from the community in person during my very first few days on the job. I’m also very much looking forward to participating in the hackathon, which should be a great way for me to get started doing real work with Nextflow.\n\nI’m hoping to see many of you there!",
    "images": [
      "/img/geraldine-van-der-auwera.jpg"
    ],
    "author": "Geraldine Van der Auwera",
    "tags": "nextflow,community"
  },
  {
    "slug": "2023/introducing-nextflow-ambassador-program",
    "title": "Introducing the Nextflow Ambassador Program",
    "date": "2023-10-18T00:00:00.000Z",
    "content": "<img src=\"/img/ambassadors-hackathon.jpeg\" style=\"float:right;width:250px;margin: 0 0 15px 15px\">\n\nWe are excited to announce the launch of the Nextflow Ambassador Program, a worldwide initiative designed to foster collaboration, knowledge sharing, and community growth. It is intended to recognize and support the efforts of our community leaders and marks another step forward in our mission to advance scientific research and empower researchers.\n\nNextflow ambassadors will play a vital role in:\n\n- Sharing Knowledge: Ambassadors provide valuable insights and best practices to help users make the most of Nextflow by writing training material and blog posts, giving seminars and workshops, organizing hackathons and meet-ups, and helping with community support.\n- Fostering Collaboration: As knowledgeable members of our community, ambassadors facilitate connections among users and developers, enabling collaboration on community projects, such as nf-core pipelines, sub-workflows, and modules, among other things, in the Nextflow ecosystem.\n- Community Growth: Ambassadors help expand and enrich the Nextflow community, making it more vibrant and supportive. They are local contacts for new community members and engage with potential users in their region and fields of expertise.\n\nAs community members who already actively contribute to outreach, ambassadors will be supported to extend the work they're already doing. For example, many of our ambassadors run local Nextflow training events – to help with this, the program will include “train the trainer” sessions and give access to our content library with slide decks, templates, and more. Ambassadors can also request stickers and financial support for events they organize (e.g., for pizza). Seqera is opening an exclusive travel fund that ambassadors can apply to help cover travel costs for events where they will present relevant work. Social media content written by ambassadors will be amplified by the nextflow and nf-core accounts, increasing their reach. Ambassadors will get \"behind the scenes\" access, with insights into running an open-source community, early access to new features, and a great networking experience. The ambassador network will enable members to be kept up-to-date with events and opportunities happening all over the world. To recognize their efforts, ambassadors will receive exclusive swag and apparel, a certificate for their work, and a profile on the ambassador page of our website.\n\n## Meet Our Ambassadors\n\nYou can visit our [Nextflow ambassadors page](https://www.nextflow.io/our_ambassadors.html) to learn more about our first group of ambassadors. You will find their profiles there, highlighting their interests, expertise, and insights they bring to the Nextflow ecosystem.\n\nYou can see snippets about some of our ambassadors below:\n\n#### Priyanka Surana\n\nPriyanka Surana is a Principal Bioinformatician at the Wellcome Sanger Institute, where she oversees the Nextflow development for the Tree of Life program. Over the last almost two years, they have released nine pipelines with nf-core standards and have three more in development. You can learn more about them [here](https://pipelines.tol.sanger.ac.uk/pipelines).\n\nShe’s one of our ambassadors in the UK 🇬🇧 and has already done fantastic outreach work, organizing seminars and bringing many new users to our community! 🤩 In the March Hackathon, she organized a local site with over 70 individuals participating in person, plus over five other events in 2023. The Nextflow community on the Wellcome Genome Campus started in March 2023 with the nf-core hackathon, and now it has grown to over 150 members across 11 different organizations across Cambridge. Currently, they are planning a day-long Nextflow Symposium in December 🤯. They do seminars, workshops, coffee meetups, and trainings. In our previous round of the Nextflow and nf-core mentorship, Priyanka mentored Lila, a graduate student in Peru, to build her first Nextflow pipeline using nf-core tools to analyze bacterial metagenomics data. This is the power of a Nextflow ambassador! Not only growing a local community but helping people all over the world to get the best out of Nextflow and nf-core 🥰.\n\n#### Abhinav Sharma\n\nAbhinav is a PhD candidate at Stellenbosch University, South Africa. As a Nextflow Ambassador, Abhinav has been tremendously active in the Global South, supporting young scientists in Africa 🇿🇦🇿🇲, Brazil 🇧🇷, India 🇮🇳 and Australia 🇦🇺 leading to the growth of local communities. He has contributed to the [Nextflow training in Hindi](https://www.youtube.com/playlist?list=PL3xpfTVZLcNikun1FrSvtXW8ic32TciTJ) and played a key role in integrating African bioinformaticians in the Nextflow and nf-core community and initiatives, showcased by the high participation of individuals in African countries who benefited from mentorship during nf-core Hackathons, Training events and prominent workshops like [VEME, 2023](https://twitter.com/abhi18av/status/1695863348162675042). In Australia, Abhinav continues to collaborate with Patricia, a research scientist from Telethon Kids Institute, Perth (whom he mentored during the nf-core mentorship round 2), to organize monthly seminars on [BioWiki](https://github.com/TelethonKids/Nextflow-BioWiki) and bootcamp for local capacity building. In addition, he engages in regular capacity-building sessions in Brazilian institutes such as [Instituto Evandro Chagas](https://www.gov.br/iec/pt-br/assuntos/noticias/curso-contribui-para-criacao-da-rede-norte-nordeste-de-vigilancia-genomica-para-tuberculose-no-iec) (Belém, Brazil) and INI, FIOCRUZ (Rio de Janeiro, Brazil). Last but not least, Abhinav has contributed to the Nextflow community and project in several ways, even to the extent of contributing to the Nextflow code base and plugin ecosystem! 😎\n\n#### Robert Petit\n\nRobert Petit is the Senior Bioinformatics Scientist at the [Wyoming Public Health Laboratory](https://health.wyo.gov/publichealth/lab/) 🦬 and a long-time contributor to the Nextflow community! 🥳 Being a Nextflow Ambassador, Robert has made extensive efforts to grow the Nextflow and nf-core communities, both locally and internationally. Through his work on [Bactopia](https://bactopia.github.io/), a popular and extensive Nextflow pipeline for the analysis of bacterial genomes, Robert has been able to [contribute to nf-core regularly](https://bactopia.github.io/v3.0.0/impact-and-outreach/enhancements/#enhancements-and-fixes). As a Bioconda Core team member, he is always lending a hand when called upon by the Nextflow community, whether it is to add a new recipe or approve a pull request! ⚒️ He has also delivered multiple trainings to the local community in Wyoming, US 🇺🇸, and workshops at conferences, including ASM Microbe. Robert's dedication as a Nextflow Ambassador is best highlighted, and he'll agree, by his active role as a mentor. Robert has acted as a mentor multiple times during virtual nf-core hackathons, and he is the only person to be a mentor in all three rounds of the Nextflow and nf-core mentorship program 😍!\n\nThe Nextflow Ambassador Program is a testament to the power of community-driven innovation, and we invite you to join us in celebrating this exceptional group. In the coming weeks and months, you will hear more from our ambassadors as they continue to share their experiences, insights, and expertise with the community as freshly minted Nextflow ambassadors.",
    "images": [
      "/img/ambassadors-hackathon.jpeg"
    ],
    "author": "Marcel Ribeiro-Dantas",
    "tags": "nextflow,community"
  },
  {
    "slug": "2023/learn-nextflow-in-2023",
    "title": "Learn Nextflow in 2023",
    "date": "2023-02-24T00:00:00.000Z",
    "content": "In 2023, the world of Nextflow is more exciting than ever! With new resources constantly being released, there is no better time to dive into this powerful tool. From a new [Software Carpentries’](https://carpentries-incubator.github.io/workflows-nextflow/index.html) course to [recordings of mutiple nf-core training events](https://nf-co.re/events/training/) to [new tutorials on Wave and Fusion](https://github.com/seqeralabs/wave-showcase), the options for learning Nextflow are endless.\n\nWe've compiled a list of the best resources in 2023 to make your journey to Nextflow mastery as seamless as possible. And remember, Nextflow is a community-driven project. If you have suggestions or want to contribute to this list, head to the [GitHub page](https://github.com/nextflow-io/) and make a pull request.\n\n## Before you start\n\nBefore learning Nextflow, you should be comfortable with the Linux command line and be familiar with some basic scripting languages, such as Perl or Python. The beauty of Nextflow is that task logic can be written in your language of choice. You will just need to learn Nextflow’s domain-specific language (DSL) to control overall flow.\n\nNextflow is widely used in bioinformatics, so many tutorials focus on life sciences. However, Nextflow can be used for almost any data-intensive workflow, including image analysis, ML model training, astronomy, and geoscience applications.\n\nSo, let's get started! These resources will guide you from beginner to expert and make you unstoppable in the field of scientific workflows.\n\n## Contents\n\n- [Why Learn Nextflow](#why-learn-nextflow)\n- [Meet the Tutorials!](#meet-the-tutorials)\n  1. [Basic Nextflow Community Training](#introduction-to-nextflow-by-community)\n  2. [Hands-on Nextflow Community Training](#nextflow-hands-on-by-community)\n  3. [Advanced Nextflow Community Training](#advanced-nextflow-by-community)\n  4. [Software Carpentry workshop](#software-carpentry-workshop)\n  5. [An introduction to Nextflow course by Uppsala University](#intro-nexflow-by-uppsala)\n  6. [Introduction to Nextflow workshop by VIB](#intro-nextflow-by-vib)\n  7. [Nextflow Training by Curtin Institute of Radio Astronomy (CIRA)](#nextflow-training-cira)\n  8. [Managing Pipelines in the Cloud - GenomeWeb Webinar](#managing-pipelines-in-the-cloud-genomeweb-webinar)\n  9. [Nextflow implementation patterns](#nextflow-implementation-patterns)\n  10. [nf-core tutorials](#nf-core-tutorials)\n  11. [Awesome Nextflow](#awesome-nextflow)\n  12. [Wave showcase: Wave and Fusion tutorials](#wave-showcase-wave-and-fusion-tutorials)\n  13. [Building Containers for Scientific Workflows](#building-containers-for-scientific-workflows)\n  14. [Best Practices for Deploying Pipelines with Nextflow Tower](#best-practices-for-deploying-pipelines-with-nextflow-tower)\n- [Cloud integration tutorials](#cloud-integration-tutorials)\n  1. [Nextflow and AWS Batch Inside the Integration](#nextflow-and-aws-batch-inside-the-integration)\n  2. [Nextflow and Azure Batch Inside the Integration](#nextflow-and-azure-batch-inside-the-integration)\n  3. [Get started with Nextflow on Google Cloud Batch](#get-started-with-nextflow-on-google-cloud-batch)\n  4. [Nextflow and K8s Rebooted: Running Nextflow on Amazon EKS](#nextflow-and-k8s-rebooted-running-nextflow-on-amazon-eks)\n- [Additional resources](#additional-resources)\n  1. [Nextflow docs](#nextflow-docs)\n  2. [Seqera Labs docs](#seqera-labs-docs)\n  3. [nf-core](#nf-core)\n  4. [Nextflow Tower](#nextflow-tower)\n  5. [Nextflow on AWS](#nextflow-on-aws)\n  6. [Nextflow Data pipelines on Azure Batch](#nextflow-data-pipelines-on-azure-batch)\n  7. [Running Nextflow with Google Life Sciences](#running-nextflow-with-google-life-sciences)\n  8. [Bonus: Nextflow Tutorial - Variant Calling Edition](#bonus-nextflow-tutorial-variant-calling-edition)\n- [Community and support](#community-and-support)\n\n<h2 id=\"why-learn-nextflow\">Why Learn Nextflow</h2>\n\nThere are hundreds of workflow managers to choose from. In fact, Meir Wahnon and several of his colleagues have gone to the trouble of compiling an awesome-workflow-engines list. The workflows community initiative is another excellent source of information about workflow engines.\n\n- Using Nextflow in your analysis workflows helps you implement reproducible pipelines. Nextflow pipelines follow [FAIR guidelines](https://www.go-fair.org/fair-principles/) (findability, accessibility, interoperability, and reuse). Nextflow also supports version control and containers to manage all software dependencies.\n- Nextflow is portable; the same pipeline written on a laptop can quickly scale to run on an HPC cluster, Amazon AWS, Microsoft Azure, Google Cloud Platform, or Kubernetes. With features like [configuration profiles](https://nextflow.io/docs/latest/config.html?#config-profiles), code can be written so that it is 100% portable across different on-prem and cloud infrastructures enabling collaboration and avoiding lock-in.\n- It is massively **scalable**, allowing the parallelization of tasks using the dataflow paradigm without hard-coding pipelines to specific platforms, workload managers, or batch services.\n- Nextflow is **flexible**, supporting scientific workflow requirements like caching processes to avoid redundant computation and workflow reporting to help understand and diagnose workflow execution patterns.\n- It is **growing fast**, and **support is available** from [Seqera Labs](https://seqera.io). The project has been active since 2013 with a vibrant developer community, and the Nextflow ecosystem continues to expand rapidly.\n- Finally, Nextflow is open source and licensed under Apache 2.0. You are free to use it, modify it, and distribute it.\n\n<h2 id=\"meet-the-tutorials\">Meet the Tutorials!</h2>\n\nSome of the best publicly available tutorials are listed below:\n\n<h3 id=\"introduction-to-nextflow-by-community\">1. Basic Nextflow Community Training </h3>\n\nBasic training for all things Nextflow. Perfect for anyone looking to get to grips with using Nextflow to run analyses and build workflows. This is the primary Nextflow training material used in most Nextflow and nf-core training events. It covers a large number of topics, with both theoretical and hands-on chapters.\n\n[Basic Nextflow Community Training](https://training.nextflow.io/basic_training/)\n\nWe run a free online training event for this course approximately every six months. Videos are streamed to YouTube and questions are handled in the nf-core Slack community. You can watch the recording of the most recent training ([September, 2023](https://nf-co.re/events/2023/training-basic-2023)) in the [YouTube playlist](https://youtu.be/ERbTqLtAkps?si=6xDoDXsb6kGQ_Qa8) below:\n\n<div style=\"text-align: center;\">\n    <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/watch?v=ERbTqLtAkps&amp;list=PL3xpfTVZLcNiLFLiDqk_H5b3TBwvgO_-W\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen=\"\" data-ruffle-polyfilled=\"\"></iframe>\n</div>\n\n<h3 id=\"nextflow-hands-on-by-community\">2. Hands-on Nextflow Community Training </h3>\n\nA \"learn by doing\" tutorial with less focus on theory, instead leading through exercises of slowly increasing complexity. This course is quite short and hands-on, great if you want to practice your Nextflow skills.\n\n[Hands-on Nextflow Community Training](https://training.nextflow.io/hands_on/)\n\nYou can watch the recording of the most recent training ([September, 2023](https://nf-co.re/events/2023/training-hands-on-2023/)) below:\n\n<div style=\"text-align: center;\">\n    <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/x5klpxczAXA?si=moNZUFGd4veMdtC8\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen=\"\" data-ruffle-polyfilled=\"\"></iframe>\n</div>\n\n<h3 id=\"advanced-nextflow-by-community\">3. Advanced Nextflow Community Training </h3>\n\nAn advanced material exploring the advanced features of the Nextflow language and runtime, and how to use them to write efficient and scalable data-intensive workflows. This is the Nextflow training material used in advanced training events.\n\n[Advanced Nextflow Community Training](https://training.nextflow.io/advanced/)\n\nYou can watch the recording of the most recent training ([September, 2023](https://nf-co.re/events/2023/training-sept-2023/)) below:\n\n<div style=\"text-align: center;\">\n    <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/nPAH9owvKvI?si=-1If8F5DcLqa-cd2\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen=\"\" data-ruffle-polyfilled=\"\"></iframe>\n</div>\n\n<h3 id=\"software-carpentry-workshop\">4. Software Carpentry workshop</h3>\n\nThe [Nextflow Software Carpentry](https://carpentries-incubator.github.io/workflows-nextflow/index.html) workshop (still being developed) explains the use of Nextflow and [nf-core](https://nf-co.re/) as development tools for building and sharing reproducible data science workflows. The intended audience is those with little programming experience. The course provides a foundation to write and run Nextflow and nf-core workflows comfortably. Adapted from the Seqera training material above, the workshop has been updated by Software Carpentries instructors within the nf-core community to fit The Carpentries training style. [The Carpentries](https://carpentries.org/) emphasize feedback to improve teaching materials, so we would like to hear back from you about what you thought was well-explained and what needs improvement. Pull requests to the course material are very welcome.\nThe workshop can be opened on Gitpod where you can try the exercises in an online computing environment at your own pace while referencing the course material in another window alongside the tutorials.\n\nThe workshop can be opened on [Gitpod](https://gitpod.io/#https://github.com/carpentries-incubator/workflows-nextflow) where you can try the exercises in an online computing environment at your own pace while referencing the course material in another window alongside the tutorials.\n\nYou can find the course in [The Carpentries incubator](https://carpentries-incubator.github.io/workflows-nextflow/index.html).\n\n<h3 id=\"intro-nexflow-by-uppsala\">5. An introduction to Nextflow course from Uppsala University</h3>\n\nThis 5-module course by Uppsala University covers the basics of Nextflow, from running Nextflow pipelines, writing your own pipelines and even using containers and conda.\n\nThe course can be viewed [here](https://uppsala.instructure.com/courses/51980/pages/nextflow-1-introduction?module_item_id=328997).\n\n<h3 id=\"intro-nextflow-by-vib\">6. Introduction to Nextflow workshop by VIB</h3>\n\nWorkshop materials by VIB (mainly) in DSL2 aiming to get familiar with the Nextflow syntax by explaining basic concepts and building a simple RNAseq pipeline. Highlights also reproducibility aspects with adding containers (docker &amp; singularity).\n\nThe course can be viewed [here](https://vibbits-nextflow-workshop.readthedocs.io/en/latest/).\n\n<h3 id=\"nextflow-training-cira\">7. Nextflow Training by Curtin Institute of Radio Astronomy (CIRA)</h3>\n\nThis training was prepared for physicists and has examples applied to astronomy which may be interesting for Nextflow users coming from this background!\n\nThe course can be viewed [here](https://carpentries-incubator.github.io/Pipeline_Training_with_Nextflow/).\n\n<h3 id=\"managing-pipelines-in-the-cloud-genomeweb-webinar\">8. Managing Pipelines in the Cloud - GenomeWeb Webinar</h3>\n\nThis on-demand webinar features Phil Ewels from SciLifeLab, nf-core (now also Seqera Labs), Brendan Boufler from Amazon Web Services, and Evan Floden from Seqera Labs. The wide-ranging discussion covers the significance of scientific workflows, examples of Nextflow in production settings, and how Nextflow can be integrated with other processes.\n\n[Watch the webinar](https://seqera.io/events/managing-bioinformatics-pipelines-in-the-cloud-to-do-more-science/)\n\n<h3 id=\"nextflow-implementation-patterns\">9. Nextflow implementation patterns</h3>\n\nThis advanced documentation discusses recurring patterns in Nextflow and solutions to many common implementation requirements. Code examples are available with notes to follow along and a GitHub repository.\n\n[Nextflow Patterns](http://nextflow-io.github.io/patterns/index.html) &amp; [GitHub repository](https://github.com/nextflow-io/patterns).\n\n<h3 id=\"nf-core-tutorials\">10. nf-core tutorials</h3>\n\nA set of tutorials covering the basics of using and creating nf-core pipelines developed by the team at [nf-core](https://nf-co.re/). These tutorials provide an overview of the nf-core framework, including:\n\n- How to run nf-core pipelines\n- What are the most commonly used nf-core tools\n- How to make new pipelines using the nf-core template\n- What are nf-core shared modules\n- How to add nf-core shared modules to a pipeline\n- How to make new nf-core modules using the nf-core module template\n- How nf-core pipelines are reviewed and ultimately released\n\n[nf-core usage tutorials](https://nf-co.re/docs/usage/tutorials) and [nf-core developer tutorials](https://nf-co.re/docs/contributing/tutorials).\n\n<h3 id=\"awesome-nextflow\">11. Awesome Nextflow</h3>\n\nA collection of awesome Nextflow pipelines compiled by various contributors to the open-source Nextflow project.\n\n[Awesome Nextflow](https://github.com/nextflow-io/awesome-nextflow) and GitHub\n\n<h3 id=\"wave-showcase-wave-and-fusion-tutorials\">12. Wave showcase: Wave and Fusion tutorials</h3>\n\nWave and the Fusion file system are new Nextflow capabilities introduced in November 2022. Wave is a container provisioning and augmentation service fully integrated with the Nextflow ecosystem. Instead of viewing containers as separate artifacts that need to be integrated into a pipeline, Wave allows developers to manage containers as part of the pipeline itself.\n\nTightly coupled with Wave is the new Fusion 2.0 file system. Fusion implements a virtual distributed file system and presents a thin client, allowing data hosted in AWS S3 buckets (and other object stores in the future) to be accessed via the standard POSIX filesystem interface expected by most applications.\n\nWave can help simplify development, improve reliability, and make pipelines easier to maintain. It can even improve pipeline performance. The optional Fusion 2.0 file system offers further advantages, delivering performance on par with FSx for Lustre while enabling organizations to reduce their cloud computing bill and improve pipeline efficiency throughput. See the [blog article](https://seqera.io/blog/breakthrough-performance-and-cost-efficiency-with-the-new-fusion-file-system/) released in February 2023 explaining the Fusion file system and providing benchmarks comparing Fusion to other data handling approaches in the cloud.\n\n[Wave showcase](https://github.com/seqeralabs/wave-showcase) on GitHub\n\n<h3 id=\"building-containers-for-scientific-workflows\">13. Building Containers for Scientific Workflows</h3>\n\nWhile not strictly a guide about Nextflow, this article provides an overview of scientific containers and provides a tutorial involved in creating your own container and integrating it into a Nextflow pipeline. It also provides some useful tips on troubleshooting containers and publishing them to registries.\n\n[Building Containers for Scientific Workflows](https://seqera.io/blog/building-containers-for-scientific-workflows/)\n\n<h3 id=\"best-practices-for-deploying-pipelines-with-nextflow-tower\">14. Best Practices for Deploying Pipelines with Nextflow Tower</h3>\n\nWhen building Nextflow pipelines, a best practice is to supply a nextflow_schema.json file describing pipeline input parameters. The benefit of adding this file to your code repository, is that if the pipeline is launched using Nextflow, the schema enables an easy-to-use web interface that users through the process of parameter selection. While it is possible to craft this file by hand, the nf-core community provides a handy schema build tool. This step-by-step guide explains how to adapt your pipeline for use with Nextflow Tower by using the schema build tool to automatically generate the nextflow_schema.json file.\n\n[Best Practices for Deploying Pipelines with Nextflow Tower](https://seqera.io/blog/best-practices-for-deploying-pipelines-with-nextflow-tower/)\n\n<h2 id=\"cloud-integration-tutorials\">Cloud integration tutorials</h2>\n\nIn addition to the learning resources above, several step-by-step integration guides explain how to run Nextflow pipelines on your cloud platform of choice. Some of these tutorials extend to the use of [Nextflow Tower](https://cloud.tower.nf/). Organizations can use the Tower Cloud Free edition to launch pipelines quickly in the cloud. Organizations can optionally use Tower Cloud Professional or run self-hosted or on-premises Tower Enterprise environments as requirements grow. This year, we added Google Cloud Batch to the cloud services supported by Nextflow.\n\n<h3 id=\"nextflow-and-aws-batch-inside-the-integration\">1. Nextflow and AWS Batch — Inside the Integration</h3>\n\nThis three-part series of articles provides a step-by-step guide explaining how to use Nextflow with AWS Batch. The [first of three articles](https://seqera.io/blog/nextflow-and-aws-batch-inside-the-integration-part-1-of-3/) covers AWS Batch concepts, the Nextflow execution model, and explains how the integration works under the covers. The [second article](https://seqera.io/blog/nextflow-and-aws-batch-inside-the-integration-part-2-of-3/) in the series provides a step-by-step guide explaining how to set up the AWS batch environment and how to run and troubleshoot open-source Nextflow pipelines. The [third article](https://seqera.io/blog/nextflow-and-aws-batch-using-tower-part-3-of-3/) builds on what you've learned, explaining how to integrate workflows with Nextflow Tower and share the AWS Batch environment with other users by \"publishing\" your workflows to the cloud.\n\nNextflow and AWS Batch — Inside the Integration ([part 1 of 3](https://seqera.io/blog/nextflow-and-aws-batch-inside-the-integration-part-1-of-3/), [part 2 of 3](https://seqera.io/blog/nextflow-and-aws-batch-inside-the-integration-part-2-of-3/), [part 3 of 3](https://seqera.io/blog/nextflow-and-aws-batch-using-tower-part-3-of-3/))\n\n<h3 id=\"nextflow-and-azure-batch-inside-the-integration\">2. Nextflow and Azure Batch — Inside the Integration</h3>\n\nSimilar to the tutorial above, this set of articles does a deep dive into the Nextflow Azure Batch integration. [Part 1](https://seqera.io/blog/nextflow-and-azure-batch-part-1-of-2/) covers Azure Batch and essential concepts, provides an overview of the integration, and explains how to set up Azure Batch and Storage accounts. It also covers deploying a machine instance in the Azure cloud and configuring it to run Nextflow pipelines against the Azure Batch service.\n\n[Part 2](https://seqera.io/blog/nextflow-and-azure-batch-working-with-tower-part-2-of-2/) builds on what you learned in part 1 and shows how to use Azure Batch from within Nextflow Tower Cloud. It provides a walkthrough of how to make the environment set up in part 1 accessible to users through Tower's intuitive web interface.\n\nNextflow and Azure Batch — Inside the Integration ([part 1 of 2](https://seqera.io/blog/nextflow-and-azure-batch-part-1-of-2/), [part 2 of 2](https://seqera.io/blog/nextflow-and-azure-batch-working-with-tower-part-2-of-2/))\n\n<h3 id=\"get-started-with-nextflow-on-google-cloud-batch\">3. Get started with Nextflow on Google Cloud Batch</h3>\n\nThis excellent article by Marcel Ribeiro-Dantas provides a step-by-step tutorial on using Nextflow with Google’s new Google Cloud Batch service. Google Cloud Batch is expected to replace the Google Life Sciences integration over time. The article explains how to deploy the Google Cloud Batch and Storage environments in GCP using the gcloud CLI. It then goes on to explain how to configure Nextflow to launch pipelines into the newly created Google Cloud Batch environment.\n\n[Get started with Nextflow on Google Cloud Batch](https://nextflow.io/blog/2023/nextflow-with-gbatch.html)\n\n<h3 id=\"nextflow-and-k8s-rebooted-running-nextflow-on-amazon-eks\">4. Nextflow and K8s Rebooted: Running Nextflow on Amazon EKS</h3>\n\nWhile not commonly used for HPC workloads, Kubernetes has clear momentum. In this educational article, Ben Sherman provides an overview of how the Nextflow / Kubernetes integration has been simplified by avoiding the requirement for Persistent Volumes (PVs) and Persistent Volume Claims (PVCs). This detailed guide provides step-by-step instructions for using Amazon EKS as a compute environment complete with how to configure IAM Roles for Kubernetes Services Accounts (IRSA), now an Amazon EKS best practice.\n\n[Nextflow and K8s Rebooted: Running Nextflow on Amazon EKS](https://seqera.io/blog/deploying-nextflow-on-amazon-eks/)\n\n<h2 id=\"additional-resources\">Additional resources</h2>\n\nThe following resources will help you dig deeper into Nextflow and other related projects like the nf-core community which maintain curated pipelines and a very active Slack channel. There are plenty of Nextflow tutorials and videos online, and the following list is no way exhaustive. Please let us know if we are missing anything.\n\n<h3 id=\"nextflow-docs\">1. Nextflow docs</h3>\n\nThe reference for the Nextflow language and runtime. These docs should be your first point of reference while developing Nextflow pipelines. The newest features are documented in edge documentation pages released every month, with the latest stable releases every three months.\n\nLatest [stable](https://www.nextflow.io/docs/latest/index.html) &amp; [edge](https://www.nextflow.io/docs/edge/index.html) documentation.\n\n<h3 id=\"seqera-labs-docs\">2. Seqera Labs docs</h3>\n\nAn index of documentation, deployment guides, training materials, and resources for all things Nextflow and Tower.\n\n[Seqera Labs docs](https://seqera.io/docs/)\n\n<h3 id=\"nf-core\">3. nf-core</h3>\n\nnf-core is a growing community of Nextflow users and developers. You can find curated sets of biomedical analysis pipelines written in Nextflow and built by domain experts. Each pipeline is stringently reviewed and has been implemented according to best practice guidelines. Be sure to sign up for the Slack channel.\n\n[nf-core website](https://nf-co.re/) and [nf-core Slack](https://nf-co.re/join)\n\n<h3 id=\"nextflow-tower\">4. Nextflow Tower</h3>\n\nNextflow Tower is a platform to easily monitor, launch, and scale Nextflow pipelines on cloud providers and on-premise infrastructure. The documentation provides details on setting up compute environments, monitoring pipelines, and launching using either the web graphic interface, CLI, or API.\n\n[Nextflow Tower](https://tower.nf/) and [user documentation](http://help.tower.nf/).\n\n<h3 id=\"nextflow-on-aws\">5. Nextflow on AWS</h3>\n\nPart of the Genomics Workflows on AWS, Amazon provides a quickstart for deploying a genomics analysis environment on Amazon Web Services (AWS) cloud, using Nextflow to create and orchestrate analysis workflows and AWS Batch to run the workflow processes. While this article is packed with good information, the procedure outlined in the more recent [Nextflow and AWS Batch – Inside the integration](https://seqera.io/blog/nextflow-and-aws-batch-inside-the-integration-part-1-of-3/) series, may be an easier place to start. Some of the steps that previously needed to be performed manually have been updated in the latest integration.\n\n[Nextflow on AWS Batch](https://docs.opendata.aws/genomics-workflows/orchestration/nextflow/nextflow-overview.html)\n\n<h3 id=\"nextflow-data-pipelines-on-azure-batch\">6. Nextflow Data Pipelines on Azure Batch</h3>\n\nNextflow on Azure requires at minimum two Azure services, Azure Batch and Azure Storage. Follow the guide below developed by the team at Microsoft to set up both services on Azure, and to get your storage and batch account names and keys.\n\n[Azure Blog](https://techcommunity.microsoft.com/t5/azure-compute-blog/running-nextflow-data-pipelines-on-azure-batch/ba-p/2150383) and [GitHub repository](https://github.com/microsoft/Genomics-Quickstart/blob/main/03-Nextflow-Azure/README.md).\n\n<h3 id=\"running-nextflow-with-google-life-sciences\">7. Running Nextflow with Google Life Sciences</h3>\n\nA step-by-step guide to launching Nextflow Pipelines in Google Cloud. Note that this integration process is specific to Google Life Sciences – an offering that pre-dates Google Cloud Batch. If you want to use the newer integration approach, you can also check out the Nextflow blog article [Get started with Nextflow on Google Cloud Batch](https://nextflow.io/blog/2023/nextflow-with-gbatch.html).\n\n[Nextflow on Google Cloud](https://cloud.google.com/life-sciences/docs/tutorials/nextflow]\n\n<h3 id=\"bonus-nextflow-tutorial-variant-calling-edition\">8. Bonus: Nextflow Tutorial - Variant Calling Edition</h3>\n\nThis [Nextflow Tutorial - Variant Calling Edition](https://sateeshperi.github.io/nextflow_varcal/nextflow/) has been adapted from the [Nextflow Software Carpentry training material](https://carpentries-incubator.github.io/workflows-nextflow/index.html) and [Data Carpentry: Wrangling Genomics Lesson](https://datacarpentry.org/wrangling-genomics/). Learners will have the chance to learn Nextflow and nf-core basics, to convert a variant-calling bash script into a Nextflow workflow, and modularize the pipeline using DSL2 modules and sub-workflows.\n\nThe workshop can be opened on [Gitpod](https://gitpod.io/#https://github.com/sateeshperi/nextflow_tutorial.git), where you can try the exercises in an online computing environment at your own pace, with the course material in another window alongside.\n\nYou can find the course in [Nextflow Tutorial - Variant Calling Edition](https://sateeshperi.github.io/nextflow_varcal/nextflow/).\n\n<h2 id=\"community-and-support\">Community and support</h2>\n\n- [Seqera Community Forum](https://community.seqera.io)\n- Nextflow Twitter [@nextflowio](https://twitter.com/nextflowio?lang=en)\n- [Nextflow Slack](https://www.nextflow.io/slack-invite.html)\n- [nf-core Slack](https://nfcore.slack.com/)\n- [Seqera Labs](https://www.seqera.io/) and [Nextflow Tower](https://tower.nf/)\n- [Nextflow patterns](https://github.com/nextflow-io/patterns)\n- [Nextflow Snippets](https://github.com/mribeirodantas/NextflowSnippets)",
    "images": [],
    "author": "Evan Floden",
    "tags": "nextflow, tower"
  },
  {
    "slug": "2023/nextflow-goes-to-university",
    "title": "Nextflow goes to university!",
    "date": "2023-07-24T00:00:00.000Z",
    "content": "The Nextflow project originated from within an academic research group, so perhaps it’s no surprise that education is an essential part of the Nextflow and nf-core communities. Over the years, we have established several regular training resources: we have a weekly online seminar series called nf-core/bytesize and run hugely popular bi-annual [Nextflow and nf-core community training online](https://www.youtube.com/@nf-core/playlists?view=50&amp;sort=dd&amp;shelf_id=2). In 2022, Seqera established a new community and growth team, funded in part by a grant from the Chan Zuckerberg Initiative “Essential Open Source Software for Science” grant. We are all former bioinformatics researchers from academia and part of our mission is to build resources and programs to support academic institutions. We want to help to provide leading edge, high-quality, [Nextflow](https://www.nextflow.io/) and [nf-core](https://nf-co.re/) training for Masters and Ph.D. students in Bioinformatics and other related fields.\n\nWe recently held one of our first such projects, a collaboration with the [Bioinformatics Multidisciplinary Environment, BioME](https://bioinfo.imd.ufrn.br/site/en-US) at the [Federal University of Rio Grande do Norte (UFRN)](https://www.ufrn.br/) in Brazil. The UFRN is one of the largest universities in Brazil with over 40,000 enrolled students, hosting one of the best-ranked bioinformatics programs in Brazil, attracting students from all over the country. The BioME department runs courses for Masters and Ph.D. students, including a flexible course dedicated to cutting-edge bioinformatics techniques. As part of this, we were invited to run an 8-day Nextflow and nf-core graduate course. Participants attended 5 days of training seminars and presented a Nextflow project at the end of the course. Upon successful completion of the course, participants received graduate program course credits as well as a Seqera Labs certified certificate recognizing their knowledge and hands-on experience 😎.\n\n<!-- end-archive-description -->\n\nThe course participants included one undergraduate student, Master's students, Ph.D. students, and postdocs with very diverse backgrounds. While some had prior Nextflow and nf-core experience and had already attended Nextflow training, others had never used it. Unsurprisingly, they all chose very different project topics to work on and present to the rest of the group. At the end of the course, eleven students chose to undergo the final project evaluation for the Seqera certification. They all passed with flying colors!\n\n<img src=\"/img/nextflow-university-class-ufrn.jpg\"> Picture with some of the students that attended the course\n\n## Final projects\n\nFinal hands-on projects are very useful not only to practice new skills but also to have a tangible deliverable at the end of the course. It could be the first step of a long journey with Nextflow, especially if you work on a project that lives on after the course concludes. Participants were given complete freedom to design a project that was relevant to them and their interests. Many students were very satisfied with their projects and intend to continue working on them after the course conclusion.\n\n### Euryale 🐍\n\n[João Vitor Cavalcante](https://www.linkedin.com/in/joao-vitor-cavalcante), along with collaborators, had developed and [published](https://www.frontiersin.org/articles/10.3389/fgene.2022.814437/full) a Snakemake pipeline for Sensitive Taxonomic Classification and Flexible Functional Annotation of Metagenomic Shotgun Sequences called MEDUSA. During the course, after seeing the huge potential of Nextflow, he decided to fully translate this pipeline to Nextflow, but with a new name: Euryale. You can check the result [here](https://github.com/dalmolingroup/euryale/) 😍 Why Euryale? In Greek mythology, Euryale was one of the three gorgons, a sister to Medusa 🤓\n\n### Bringing Nanopore to Google Batch ☁️\n\nThe Customer Workflows Group at Oxford Nanopore Technologies (ONT) has adopted Nextflow to develop and distribute general-purpose pipelines for its customers. One of these pipelines, [wf-alignment](https://github.com/epi2me-labs/wf-alignment), takes a FASTQ directory and a reference directory and outputs a minimap2 alignment, along with samtools stats and an HTML report. Both samtools stats and the HTML report generated by this pipeline are well suited for Nextflow Tower’s Reports feature. However, [Danilo Imparato](https://www.linkedin.com/in/daniloimparato) noticed that the pipeline lacked support for using Google Cloud as compute environment and decided to work on this limitation on his [final project](https://github.com/daniloimparato/wf-alignment), which included fixing a few bugs specific to running it on Google Cloud and making the reports available on Nextflow Tower 🤯\n\n### Nextflow applied to Economics! 🤩\n\n[Galileu Nobre](https://www.linkedin.com/in/galileu-nobre-901551187/) is studying Economical Sciences and decided to convert his scripts into a Nextflow pipeline for his [final project](https://github.com/galileunobre/nextflow_projeto_1). The goal of the pipeline is to estimate the demand for health services in Brazil based on data from the 2019 PNS (National Health Survey), (a) treating this database to contain only the variables we will work with, (b) running a descriptive analysis to determine the data distribution in order to investigate which models would be best applicable. In the end, two regression models, Poisson, and the Negative Binomial, are used to estimate the demand. His work is an excellent example of applying Nextflow to fields outside of traditional bioinformatics 😉.\n\n### Whole Exome Sequencing 🧬\n\nFor her [final project](https://github.com/RafaellaFerraz/exome), [Rafaella Ferraz](https://www.linkedin.com/in/rafaella-sousa-ferraz) used nf-core/tools to write a whole-exome sequencing analysis pipeline from scratch. She applied her new skills using nf-core modules and sub-workflows to achieve this and was able to launch and monitor her pipeline using Nextflow Tower. Kudos to Rafaella! 👏🏻\n\n### RNASeq with contamination 🧫\n\nIn her [final project](https://github.com/iaradsouza1/tab-projeto-final), [Iara Souza](https://www.linkedin.com/in/iaradsouza) developed a bioinformatics pipeline that analyzed RNA-Seq data when it's required to have an extra pre-filtering step. She needed this for analyzing data from RNA-Seq experiments performed in cell culture, where there is a high probability of contamination of the target transcriptome with the host transcriptome. Iara was able to learn how to use nf-core/tools and benefit from all the \"batteries included\" that come with it 🔋😬\n\n### SARS-CoV-2 Genome assembly and lineage classification 🦠\n\n[Diego Teixeira](https://www.linkedin.com/in/diego-go-tex) has been working with SARS-CoV-2 genome assembly and lineage classification. As his final project, he wrote a [Nextflow pipeline](https://github.com/diegogotex/sarscov2_irma_nf) aggregating all tools and analyses he's been doing, allowing him to be much more efficient in his work and have a reproducible pipeline that can easily be shared with collaborators.\n\nIn the nf-core project, there are almost a [thousand modules](https://nf-co.re/modules) ready to plug in your pipeline, together with [dozens of full-featured pipelines](https://nf-co.re/pipelines). However, in many situations, you'll need a custom pipeline. With that in mind, it's very useful to master the skills of Nextflow scripting so that you can take advantage of everything that is available, both building new pipelines and modifying public ones.\n\n## Exciting experience!\n\nIt was an amazing experience to see what each participant had worked on for their final projects! 🤯 They were all able to master the skills required to write Nextflow pipelines in real-life scenarios, which can continue to be used well after the end of the course. For people just starting their adventure with Nextflow, it can feel overwhelming to use nf-core tools with all the associated best practices, but students surprised me by using nf-core tools from the very beginning and having their project almost perfectly fitting the best practices 🤩\n\nWe’d love to help out with more university bioinformatics courses like this. If you think your institution could benefit from such an experience, please don't hesitate to reach out to us at community@seqera.io. We would love to hear from you!",
    "images": [
      "/img/nextflow-university-class-ufrn.jpg"
    ],
    "author": "Marcel Ribeiro-Dantas",
    "tags": "nextflow,nf-core"
  },
  {
    "slug": "2023/nextflow-summit-2023-recap",
    "title": "Nextflow Summit 2023 Recap",
    "date": "2023-10-25T00:00:00.000Z",
    "content": "## Five days of Nextflow Awesomeness in Barcelona\n\nOn Friday, Oct 20, we wrapped up our [hackathon](https://nf-co.re/events/hackathon) and [Nextflow Summit](https://summit.nextflow.io/) in Barcelona, Spain. By any measure, this year’s Summit was our best community event ever, drawing roughly 900 attendees across multiple channels, including in-person attendees, participants in our [#summit-2023](https://nextflow.slack.com/archives/C0602TWRT5G) Slack channel, and [Summit Livestream](https://www.youtube.com/playlist?list=PLPZ8WHdZGxmUotnP-tWRVNtuNWpN7xbpL) viewers on YouTube.\n\nThe Summit drew attendees, speakers, and sponsors from around the world. Over the course of the three-day event, we heard from dozens of impressive speakers working at the cutting edge of life sciences from academia, research, healthcare providers, biotechs, and cloud providers, including:\n\n- Australian BioCommons\n- Genomics England\n- Pixelgen Technologies\n- University of Tennessee Health Science Center\n- Amazon Web Services\n- Quantitative Biology Center - University of Tübingen\n- Biomodal\n- Matterhorn Studio\n- Centre for Genomic Regulation (CRG)\n- Heidelberg University Hospital\n- MemVerge\n- University of Cambridge\n- Oxford Nanopore Technologies\n- Medical University of Innsbruck\n- Sano Genetics\n- Institute of Genetics and Development of Rennes, University of Rennes\n- Ardigen\n- ZS\n- Wellcome Sanger Institute\n- SciLifeLab\n- AstraZeneca UK Ltd\n- University of Texas at Dallas\n- Seqera\n\n## The Hackathon – advancing the Nextflow ecosystem\n\nThe week began with a three-day in-person and virtual nf-core hackathon event. With roughly 100 in-person developers, this was twice the size of our largest Hackathon to date. As with previous Hackathons, participants were divided into project groups, with activities coordinated via a single [GitHub project board](https://github.com/orgs/nf-core/projects/47/views/1) focusing on different aspects of [nf-core](https://nf-co.re/) and Nextflow, including:\n\n- Pipelines\n- Modules &amp; subworkflows\n- Infrastructure\n- Nextflow &amp; plugins development\n\nThis year, the focus of the hackathon was [nf-test](https://code.askimed.com/nf-test/), an open-source testing framework for Nextflow pipelines. The team made considerable progress applying nf-test consistently across various nf-core pipelines and modules — and of course, no Hackathon would be complete without a community cooking class, quiz, bingo, a sock hunt, and a scavenger hunt!\n\nFor an overview of the tremendous progress made advancing the state of Nextflow and nf-core in three short days, view Chris Hakkaart’s talk on [highlights from the nf-core hackathon](https://summit.nextflow.io/barcelona/agenda/summit/oct-20-hackathon/).\n\n## The Summit kicks off\n\nThe Summit began on Wednesday Oct 18 with excellent talks from [Australian BioCommons](https://summit.nextflow.io/barcelona/agenda/summit/oct-18-the-national-nextflow-tower-service-for-australian-researchers/) and [Genomics England](https://summit.nextflow.io/barcelona/agenda/summit/oct-18-analysing-ont-long-read-data-for-cancer-with-nextflow/). This was followed by a presentation where [Pixelgen Technologies](https://summit.nextflow.io/barcelona/agenda/summit/oct-18-pixelgen-technologies-heart-nextflow/) described their unique Molecular Pixelation (MPX) technologies and unveiled their new [nf-core/pixelator](https://nf-co.re/pixelator/1.0.0) community pipeline for molecular pixelation assays.\n\nNext, Seqera’s Phil Ewels took the stage providing a series of community updates, including the announcement of a new [Nextflow Ambassador](https://nextflow.io/blog/2023/introducing-nextflow-ambassador-program.html) program, [a new community forum](https://nextflow.io/blog/2023/community-forum.html) at [community.seqera.io](https://community.seqera.io), and the exciting appointment of [Geraldine Van der Auwera](https://nextflow.io/blog/2023/geraldine-van-der-auwera-joins-seqera.html) as lead developer advocate for the Nextflow. Geraldine is well known for her work on GATK, WDL, and Terra.bio and is the co-author of the book [Genomics on the Cloud](https://www.oreilly.com/library/view/genomics-in-the/9781491975183/). As Geraldine assumes leadership of the developer advocacy team, Phil will spend more time focusing on open-source development, as product manager of open source at Seqera.\n\n<div style=\"margin-top: 2rem; margin-bottom: 2rem;\">\n    <img src=\"/img/blog-summit-2023-recap--img1b.jpg\" alt=\"Hackathon 2023 photo\">\n</div>\n\nSeqera’s Evan Floden shared his vision of the modern biotech stack for open science, highlighting recent developments at Seqera, including a revamped [Seqera platform](https://seqera.io/platform/), new [Data Explorer](https://seqera.io/blog/introducing-data-explorer/) functionality, and providing an exciting glimpse of the new Data Studios feature now in private preview. You can view [Evan’s full talk here](https://summit.nextflow.io/barcelona/agenda/summit/oct-18-modern-biotech/).\n\nA highlight was the keynote delivered by Erik Garrison of the University of Tennessee Health Science Center provided. In his talk, [Biological revelations at the frontiers of a draft human pangenome reference](https://summit.nextflow.io/barcelona/agenda/summit/oct-18-erik-garrison/), Erik shared how his team's cutting-edge work applying new computational methods in the context of the Human Pangenome Project has yielded the most complete picture of human sequence evolution available to date.\n\nDay one wrapped up with a surprise [announcement](https://www.globenewswire.com/news-release/2023/10/20/2763899/0/en/Seqera-Sets-Sail-With-Alinghi-Red-Bull-Racing-as-Official-High-Performance-Computing-Supplier.html) that Seqera has been confirmed as the official High-Performance Computing Supplier for Alinghi Red Bull Racing at the [37th America’s Cup](https://www.americascup.com/) in Barcelona. This was followed by an evening reception hosted by [Alinghi Red Bull Racing](https://alinghiredbullracing.americascup.com/).\n\n## Day two starts off on the right foot\n\nDay two kicked off with a brisk sunrise run along the iconic Barcelona Waterfront attended by a team of hardy Summit participants. After that, things kicked into high gear for the morning session with talks on everything from using Nextflow to power [Machine Learning pipelines for materials science](https://summit.nextflow.io/barcelona/agenda/summit/oct-19-machine-learning-for-material-science/) to [standardized frameworks for protein structure prediction](https://summit.nextflow.io/barcelona/agenda/summit/oct-19-proteinfold/) to discussions on [how to estimate the CO2 footprint of pipeline runs](https://summit.nextflow.io/barcelona/agenda/summit/oct-19-nf-co2footprint/).\n\n<div style=\"margin-top: 2rem; margin-bottom: 2rem;\">\n    <img src=\"/img/blog-summit-2023-recap--img2b.jpg\" alt=\"Summit 2023 photo\">\n</div>\n\nNextflow creator and Seqera CTO and co-founder Paolo Di Tommaso provided an update on some of the technologies he and his team have been working on including a deep dive on the [Fusion file system](https://seqera.io/fusion/). Paolo also delved into [Wave containers](https://seqera.io/wave/), discussing the dynamic assembly of containers using the [Spack package manager](https://nextflow.io/docs/latest/process.html#spack), echoing a similar theme from AWS’s [Brendan Bouffler](https://summit.nextflow.io/barcelona/agenda/summit/oct-19-brendan-bouffler/) earlier in the day. During the conference, Seqera announced Wave Containers as our latest [open-source](https://github.com/seqeralabs/wave) contribution to the bioinformatics community — a huge contribution to the open science movement.\n\nPaolo also provided an impressive command-line focused demo of Wave, echoing Harshil Patel’s equally impressive demo earlier in the day focused on [seqerakit and automation on the Seqera Platform](https://summit.nextflow.io/barcelona/agenda/summit/oct-19-harshil-patel/). Both Harshil and Paolo showed themselves to be **\"kings of the live demo\"** for their command line mastery under pressure! You can view [Paolo’s talk and demos here](https://summit.nextflow.io/barcelona/agenda/summit/oct-19-paolo-di-tommaso/) and [Harshil’s talk here](https://summit.nextflow.io/barcelona/agenda/summit/oct-19-harshil-patel/).\n\nTalks during day two included [bringing spatial omics to nf-core](https://summit.nextflow.io/barcelona/agenda/summit/oct-19-bringing-spatial-omics-to-nf-core/), a discussion of [nf-validation](https://summit.nextflow.io/barcelona/agenda/summit/oct-19-nf-validation/), and a talk on the [development of an integrated DNA and RNA variant calling pipeline](https://summit.nextflow.io/barcelona/agenda/summit/oct-19-development-of-an-integrated-dna-and-rna-variant-calling-pipeline/).\n\nUnfortunately, there were too many brilliant speakers and topics to mention them all here, so we’ve provided a handy summary of talks at the end of this post so you can look up topics of interest.\n\nThe Summit also featured an exhibition area, and attendees visited booths hosted by [event sponsors](https://summit.nextflow.io/barcelona/sponsors/) between talks and viewed the many excellent [scientific posters](https://summit.nextflow.io/barcelona/posters/) contributed for the event. Following a packed day of sessions that went into the evening, attendees relaxed and socialized with colleagues over dinner.\n\n<div style=\"margin-top: 2rem; margin-bottom: 2rem;\">\n    <img src=\"/img/blog-summit-2023-recap--img3b.jpg\" alt=\"Morning run photo\">\n</div>\n\n## Wrapping up\n\nAs things wound to a close on day three, there were additional talks on topics ranging from ZS’s [contributing to nf-core through client collaboration](https://summit.nextflow.io/barcelona/agenda/summit/oct-20-zs/) to [decoding the Tree of Life at Wellcome Sanger Institute](https://summit.nextflow.io/barcelona/agenda/summit/oct-20-tree-of-life/) to [performing large and reproducible GWAS analysis on biobank-scale data](https://summit.nextflow.io/barcelona/agenda/summit/oct-20-gwas/) at Medical University of Innsbruck.\n\nPhil Ewels discussed [future plans for MultiQC](https://summit.nextflow.io/barcelona/agenda/summit/oct-20-multiqc/), and Edmund Miller [shared his experience working on nf-test](https://summit.nextflow.io/barcelona/agenda/summit/oct-20-nf-test-at-nf-core/) and how it is empowering scalable and streamlined testing for nf-core projects.\n\nTo close the event, Evan took the stage a final time, thanking the many Summit organizers and contributors, and announcing the next Nextflow Summit Barcelona, scheduled for **October 21-25, 2024**. He also reminded attendees of the upcoming North American Hackathon and [Nextflow Summit in Boston](https://summit.nextflow.io/boston/) beginning on November 28, 2023.\n\nOn behalf of the Seqera team, thank you to our fellow [sponsors](https://summit.nextflow.io/boston/sponsors/) who helped make the Nextflow Summit a resounding success. This year’s sponsors included:\n\n- AWS\n- ZS\n- Element Biosciences\n- Microsoft\n- MemVerge\n- Pixelgen Technologies\n- Oxford Nanopore\n- Quilt\n- TileDB\n\n## In case you missed it\n\nIf you were unable to attend in person, or missed a talk, you can watch all three days of the Summit on our [YouTube channel](https://www.youtube.com/playlist?list=PLPZ8WHdZGxmUotnP-tWRVNtuNWpN7xbpL).\n\nFor information about additional upcoming events including bytesize talks, hackathons, webinars, and training events, you can visit [https://nf-co.re/events](https://nf-co.re/events) or [https://seqera.io/events/seqera/](https://seqera.io/events/seqera/).\n\nFor your convenience, a handy list of talks from Nextflow Summit 2023 are summarized below.\n\n### Day one (Wednesday Oct 18):\n\n- [The National Nextflow Tower Service for Australian researchers](https://summit.nextflow.io/barcelona/agenda/summit/oct-18-the-national-nextflow-tower-service-for-australian-researchers/) – Steven Manos\n- [Analysing ONT long read data for cancer with Nextflow](https://summit.nextflow.io/barcelona/agenda/summit/oct-18-analysing-ont-long-read-data-for-cancer-with-nextflow/) – Arthur Gymer\n- [Community updates](https://summit.nextflow.io/barcelona/agenda/summit/oct-18-community-updates/) – Phil Ewels\n- [Pixelgen Technologies ❤︎ Nextflow](https://summit.nextflow.io/barcelona/agenda/summit/oct-18-pixelgen-technologies-heart-nextflow/) – John Dahlberg\n- [The modern biotech stack](https://summit.nextflow.io/barcelona/agenda/summit/oct-18-modern-biotech/) – Evan Floden\n- [Biological revelations at the frontiers of a draft human pangenome reference](https://summit.nextflow.io/barcelona/agenda/summit/oct-18-erik-garrison/) – Erik Garrison\n\n### Day two (Thursday Oct 19):\n\n- [It’s been quite a year for research technology in the cloud: we’ve been busy](https://summit.nextflow.io/barcelona/agenda/summit/oct-19-brendan-bouffler/) – Brendan Bouffler\n- [nf-validation: a Nextflow plugin to validate pipeline parameters and input files](https://summit.nextflow.io/barcelona/agenda/summit/oct-19-nf-validation/) - Júlia Mir Pedrol\n- [Computational methods for allele-specific methylation with biomodal Duet](https://summit.nextflow.io/barcelona/agenda/summit/oct-19-biomodal-duet/) – Michael Wilson\n- [How to use data pipelines in Machine Learning for Material Science](https://summit.nextflow.io/barcelona/agenda/summit/oct-19-machine-learning-for-material-science/) – Jakob Zeitler\n- [nf-core/proteinfold: a standardized workflow framework for protein structure prediction tools](https://summit.nextflow.io/barcelona/agenda/summit/oct-19-proteinfold/) - Jose Espinosa-Carrasco\n- [Automation on the Seqera Platform](https://summit.nextflow.io/barcelona/agenda/summit/oct-19-harshil-patel/) - Harshil Patel\n- [nf-co2footprint: a Nextflow plugin to estimate the CO2 footprint of pipeline runs](https://summit.nextflow.io/barcelona/agenda/summit/oct-19-nf-co2footprint/) - Sabrina Krakau\n- [Bringing spatial omics to nf-core](https://summit.nextflow.io/barcelona/agenda/summit/oct-19-bringing-spatial-omics-to-nf-core/) - Victor Perez\n- [Bioinformatics at the speed of cloud: revolutionizing genomics with Nextflow and MMCloud](https://summit.nextflow.io/barcelona/agenda/summit/oct-19-bioinformatics-at-the-speed-of-cloud/) - Sateesh Peri\n- [Enabling converged computing with the Nextflow ecosystem](https://summit.nextflow.io/barcelona/agenda/summit/oct-19-paolo-di-tommaso/) - Paolo Di Tommaso\n- [Cluster scalable pangenome graph construction with nf-core/pangenome](https://summit.nextflow.io/barcelona/agenda/summit/oct-19-cluster-scalable-pangenome/) - Simon Heumos\n- [Development of an integrated DNA and RNA variant calling pipeline](https://summit.nextflow.io/barcelona/agenda/summit/oct-19-development-of-an-integrated-dna-and-rna-variant-calling-pipeline/) - Raquel Manzano\n- [Annotation cache: using nf-core/modules and Seqera Platform to build an AWS open data resource](https://summit.nextflow.io/barcelona/agenda/summit/oct-19-annotation-cache/) - Maxime Garcia\n- [Real-time sequencing analysis with Nextflow](https://summit.nextflow.io/barcelona/agenda/summit/oct-19-real-time-sequencing-analysis-with-nextflow/) - Chris Wright\n- [nf-core/sarek: a comprehensive &amp; efficient somatic &amp; germline variant calling workflow](https://summit.nextflow.io/barcelona/agenda/summit/oct-19-nf-core-sarek/) - Friederike Hanssen\n- [nf-test: a simple but powerful testing framework for Nextflow pipelines](https://summit.nextflow.io/barcelona/agenda/summit/oct-19-nf-test-simple-but-powerful/) - Lukas Forer\n- [Empowering distributed precision medicine: scalable genomic analysis in clinical trial recruitment](https://summit.nextflow.io/barcelona/agenda/summit/oct-19-empowering-distributed-precision-medicine/) - Heath Obrien\n- [nf-core pipeline for genomic imputation: from phasing to imputation to validation](https://summit.nextflow.io/barcelona/agenda/summit/oct-19-nf-core-pipeline-for-genomic-imputation/) - Louis Le Nézet\n- [Porting workflow managers to Nextflow at a national diagnostic genomics medical service – strategy and learnings](https://summit.nextflow.io/barcelona/agenda/summit/oct-19-genomics-england/) - Several Speakers\n\n### Day three (Thursday Oct 19):\n\n- [Driving discovery: contributing to the nf-core project through client collaboration](https://summit.nextflow.io/barcelona/agenda/summit/oct-20-zs/) - Felipe Almeida &amp; Juliet Frederiksen\n- [Automated production engine to decode the Tree of Life](https://summit.nextflow.io/barcelona/agenda/summit/oct-20-tree-of-life/) - Guoying Qi\n- [Building a community: experiences from one year as a developer advocate](https://summit.nextflow.io/barcelona/agenda/summit/oct-20-community-building/) - Marcel Ribeiro-Dantas\n- [nf-core/raredisease: a workflow to analyse data from patients with rare diseases](https://summit.nextflow.io/barcelona/agenda/summit/oct-20-nf-core-raredisease/) - Ramprasad Neethiraj\n- [Enabling AZ bioinformatics with Nextflow/Nextflow Tower](https://summit.nextflow.io/barcelona/agenda/summit/oct-20-az/) - Manasa Surakala\n- [Bringing MultiQC into a new era](https://summit.nextflow.io/barcelona/agenda/summit/oct-20-multiqc/) - Phil Ewels\n- [nf-test at nf-core: empowering scalable and streamlined testing](https://summit.nextflow.io/barcelona/agenda/summit/oct-20-nf-test-at-nf-core/) - Edmund Miller\n- [Performing large and reproducible GWAS analysis on biobank-scale data](https://summit.nextflow.io/barcelona/agenda/summit/oct-20-gwas/) - Sebastian Schönherr\n- [Highlights from the nf-core hackathon](https://summit.nextflow.io/barcelona/agenda/summit/oct-20-hackathon/) - Chris Hakkaart\n\n_In this event, we're showcasing some of the results of the project 'Optimization of computational resources for HPC workloads in the cloud using ML/AI' by Seqera Labs S.L. This project has been funded by the European Regional Development Fund (ERDF) of the European Union, coordinated and managed by RED.es, with the aim of carrying out the development of technological entrepreneurship and technological demand, within the framework of the Strategic Action on Digital Economy and Society of the State Program for R&amp;D&amp;I oriented towards societal challenges._\n\n![grant logos](/img/blog-2022-11-03--img1.png)",
    "images": [
      "/img/blog-summit-2023-recap--img1b.jpg",
      "/img/blog-summit-2023-recap--img2b.jpg",
      "/img/blog-summit-2023-recap--img3b.jpg"
    ],
    "author": "Noel Ortiz",
    "tags": "nextflow,summit,event,hackathon"
  },
  {
    "slug": "2023/nextflow-with-gbatch",
    "title": "Get started with Nextflow on Google Cloud Batch",
    "date": "2023-02-01T00:00:00.000Z",
    "content": "[We have talked about Google Cloud Batch before](https://www.nextflow.io/blog/2022/deploy-nextflow-pipelines-with-google-cloud-batch.html). Not only that, we were proud to announce Nextflow support to Google Cloud Batch right after it was publicly released, back in July 2022. How amazing is that? But we didn't stop there! The [Nextflow official documentation](https://www.nextflow.io/docs/latest/google.html) also provides a lot of useful information on how to use Google Cloud Batch as the compute environment for your Nextflow pipelines. Having said that, feedback from the community is valuable, and we agreed that in addition to the documentation, teaching by example, and in a more informal language, can help many of our users. So, here is a tutorial on how to use the Batch service of the Google Cloud Platform with Nextflow 🥳\n\n### Running an RNAseq pipeline with Google Cloud Batch\n\nWelcome to our RNAseq tutorial using Nextflow and Google Cloud Batch! RNAseq is a powerful technique for studying gene expression and is widely used in a variety of fields, including genomics, transcriptomics, and epigenomics. In this tutorial, we will show you how to use Nextflow, a popular workflow management tool, to run a proof-of-concept RNAseq pipeline to perform the analysis on Google Cloud Batch, a scalable cloud-based computing platform. For a real Nextflow RNAseq pipeline, check [nf-core/rnaseq](https://github.com/nf-core/rnaseq). For the proof-of-concept RNAseq pipeline that we will use here, check [nextflow-io/rnaseq-nf](https://github.com/nextflow-io/rnaseq-nf).\n\nNextflow allows you to easily develop, execute, and scale complex pipelines on any infrastructure, including the cloud. Google Cloud Batch enables you to run batch workloads on Google Cloud Platform (GCP), with the ability to scale up or down as needed. Together, Nextflow and Google Cloud Batch provide a powerful and flexible solution for RNAseq analysis.\n\nWe will walk you through the entire process, from setting up your Google Cloud account and installing Nextflow to running an RNAseq pipeline and interpreting the results. By the end of this tutorial, you will have a solid understanding of how to use Nextflow and Google Cloud Batch for RNAseq analysis. So let's get started!\n\n### Setting up Google Cloud CLI (gcloud)\n\nIn this tutorial, you will learn how to use the gcloud command-line interface to interact with the Google Cloud Platform and set up your Google Cloud account for use with Nextflow. If you do not already have gcloud installed, you can follow the instructions [here](https://cloud.google.com/sdk/docs/install) to install it. Once you have gcloud installed, run the command `gcloud init` to initialize the CLI. You will be prompted to choose an existing project to work on or create a new one. For the purpose of this tutorial, we will create a new project. Name your project \"my-rnaseq-pipeline\". There may be a lot of information displayed on the screen after running this command, but you can ignore it for now.\n\n### Setting up Batch and Storage in Google Cloud Platform\n\n#### Enable Google Batch\n\nAccording to the [official Google documentation](https://cloud.google.com/batch/docs/get-started) _Batch is a fully managed service that lets you schedule, queue, and execute [batch processing](https://en.wikipedia.org/wiki/Batch_processing) workloads on Compute Engine virtual machine (VM) instances. Batch provisions resources and manages capacity on your behalf, allowing your batch workloads to run at scale_.\n\nThe first step is to download the `beta` command group. You can do this by executing:\n\n```bash\n$ gcloud components install beta\n```\n\nThen, enable billing for this project. You will first need to get your account id with\n\n```bash\n$ gcloud beta billing accounts list\n```\n\nAfter that, you will see something like the following appear in your window:\n\n```console\nACCOUNT_ID            NAME                OPEN  MASTER_ACCOUNT_ID\nXXXXX-YYYYYY-ZZZZZZ  My Billing Account  True\n```\n\nIf you get the error “Service Usage API has not been used in project 842841895214 before or it is disabled”, simply run the command again and it should work. Then copy the account id, and the project id and paste them into the command below. This will enable billing for your project id.\n\n```bash\n$ gcloud beta billing projects link PROJECT-ID --billing-account XXXXXX-YYYYYY-ZZZZZZ\n```\n\nNext, you must enable the Batch API, along with the Compute Engine and Cloud Logging APIs. You can do so with the following command:\n\n```bash\n$ gcloud services enable batch.googleapis.com compute.googleapis.com logging.googleapis.com\n```\n\nYou should see a message similar to the one below:\n\n```console\nOperation \"operations/acf.p2-AAAA-BBBBB-CCCC--DDDD\" finished successfully.\n```\n\n#### Create a Service Account\n\nIn order to access the APIs we enabled, you need to [create a Service Account](https://cloud.google.com/iam/docs/creating-managing-service-accounts#iam-service-accounts-create-gcloud) and set the necessary IAM roles for the project. You can create the Service Account by executing:\n\n```bash\n$ gcloud iam service-accounts create rnaseq-pipeline-sa\n```\n\nAfter this, set appropriate roles for the project using the commands below:\n\n```bash\n$ gcloud projects add-iam-policy-binding my-rnaseq-pipeline \\\n--member=\"serviceAccount:rnaseq-pipeline-sa@my-rnaseq-pipeline.iam.gserviceaccount.com\" \\\n--role=\"roles/iam.serviceAccountUser\"\n\n$ gcloud projects add-iam-policy-binding my-rnaseq-pipeline \\\n--member=\"serviceAccount:rnaseq-pipeline-sa@my-rnaseq-pipeline.iam.gserviceaccount.com\" \\\n--role=\"roles/batch.jobsEditor\"\n\n$ gcloud projects add-iam-policy-binding my-rnaseq-pipeline \\\n--member=\"serviceAccount:rnaseq-pipeline-sa@my-rnaseq-pipeline.iam.gserviceaccount.com\" \\\n--role=\"roles/logging.viewer\"\n\n$ gcloud projects add-iam-policy-binding my-rnaseq-pipeline \\\n--member=\"serviceAccount:rnaseq-pipeline-sa@my-rnaseq-pipeline.iam.gserviceaccount.com\" \\\n--role=\"roles/storage.admin\"\n```\n\n#### Create your Bucket\n\nNow it's time to create your Storage bucket, where both your input, intermediate and output files will be hosted and accessed by the Google Batch virtual machines. Your bucket name must be globally unique (across regions). For the example below, the bucket is named rnaseq-pipeline-nextflow-bucket. However, as this name has now been used you have to create a bucket with a different name\n\n```bash\n$ gcloud storage buckets create gs://rnaseq-pipeline-bckt\n```\n\nNow it's time for Nextflow to join the party! 🥳\n\n### Setting up Nextflow to make use of Batch and Storage\n\n#### Write the configuration file\n\nHere you will set up a simple RNAseq pipeline with Nextflow to be run entirely on Google Cloud Platform (GCP) directly from your local machine.\n\nStart by creating a folder for your project on your local machine, such as “rnaseq-example”. It's important to mention that you can also go fully cloud and use a Virtual Machine for everything we will do here locally.\n\nInside the folder that you created for the project, create a file named `nextflow.config` with the following content (remember to replace PROJECT-ID with the project id you created above):\n\n```groovy\nworkDir = 'gs://rnaseq-pipeline-bckt/scratch'\n\nprocess {\n  executor = 'google-batch'\n  container = 'nextflow/rnaseq-nf'\n  errorStrategy = { task.exitStatus==14 ? 'retry' : 'terminate' }\n  maxRetries = 5\n}\n\ngoogle {\n  project = 'PROJECT-ID'\n  location = 'us-central1'\n  batch.spot = true\n}\n```\n\nThe `workDir` option tells Nextflow to use the bucket you created as the work directory. Nextflow will use this directory to stage our input data and store intermediate and final data. Nextflow does not allow you to use the root directory of a bucket as the work directory -- it must be a subdirectory instead. Using a subdirectory is also just a good practice.\n\nThe `process` scope tells Nextflow to run all the processes (steps) of your pipeline on Google Batch and to use the `nextflow/rnaseq-nf` Docker image hosted on DockerHub (default) for all processes. Also, the error strategy will automatically retry any failed tasks with exit code 14, which is the exit code for spot instances that were reclaimed.\n\nThe `google` scope is specific to Google Cloud. You need to provide the project id (don't provide the project name, it won't work!), and a Google Cloud location (leave it as above if you're not sure of what to put). In the example above, spot instances are also requested (more info about spot instances [here](https://www.nextflow.io/docs/latest/google.html#spot-instances)), which are cheaper instances that, as a drawback, can be reclaimed at any time if resources are needed by the cloud provider. Based on what we have seen so far, the `nextflow.config` file should contain \"rnaseq-nxf\" as the project id.\n\nUse the command below to authenticate with Google Cloud Platform. Nextflow will use this account by default when you run a pipeline.\n\n```bash\n$ gcloud auth application-default login\n```\n\n#### Launch the pipeline!\n\nWith that done, you’re now ready to run the proof-of-concept RNAseq Nextflow pipeline. Instead of asking you to download it, or copy-paste something into a script file, you can simply provide the GitHub URL of the RNAseq pipeline mentioned at the beginning of [this tutorial](https://github.com/nextflow-io/rnaseq-nf), and Nextflow will do all the heavy lifting for you. This pipeline comes with test data bundled with it, and for more information about it and how it was developed, you can check the public training material developed by Seqera Labs at <https: training.nextflow.io=\"\">.\n\nOne important thing to mention is that in this repository there is already a `nextflow.config` file with different configuration, but don't worry about that. You can run the pipeline with the configuration file that we have wrote above using the `-c` Nextflow parameter. Run the command line below:\n\n```bash\n$ nextflow run nextflow-io/rnaseq-nf -c nextflow.config\n```\n\nWhile the pipeline stores everything in the bucket, our example pipeline will also download the final outputs to a local directory called `results`, because of how the `publishDir` directive was specified in the `main.nf` script (example [here](https://github.com/nextflow-io/rnaseq-nf/blob/ed179ef74df8d5c14c188e200a37fff61fd55dfb/modules/multiqc/main.nf#L5)). If you want to avoid the egress cost associated with downloading data from a bucket, you can change the `publishDir` to another bucket directory, e.g. `gs://rnaseq-pipeline-bckt/results`.\n\nIn your terminal, you should see something like this:\n\n![Nextflow ongoing run on Google Cloud Batch](/img/ongoing-nxf-gbatch.png)\n\nYou can check the status of your jobs on Google Batch by opening another terminal and running the following command:\n\n```bash\n$ gcloud batch jobs list\n```\n\nBy the end of it, if everything worked well, you should see something like:\n\n![Nextflow run on Google Cloud Batch finished](/img/nxf-gbatch-finished.png)\n\nAnd that's all, folks! 😆\n\nYou will find more information about Nextflow on Google Batch in [this blog post](https://www.nextflow.io/blog/2022/deploy-nextflow-pipelines-with-google-cloud-batch.html) and the [official Nextflow documentation](https://www.nextflow.io/docs/latest/google.html).\n\nSpecial thanks to Hatem Nawar, Chris Hakkaart, and Ben Sherman for providing valuable feedback to this document.\n</https:>",
    "images": [],
    "author": "Marcel Ribeiro-Dantas",
    "tags": "nextflow,google,cloud"
  },
  {
    "slug": "2023/reflecting-on-ten-years-of-nextflow-awesomeness",
    "title": "Reflecting on ten years of Nextflow awesomeness",
    "date": "2023-06-06T00:00:00.000Z",
    "content": "There's been a lot of water under the bridge since the first release of Nextflow in July 2013. From its humble beginnings at the [Centre for Genomic Regulation](https://www.crg.eu/) (CRG) in Barcelona, Nextflow has evolved from an upstart workflow orchestrator to one of the most consequential projects in open science software (OSS). Today, Nextflow is downloaded **120,000+** times monthly, boasts vibrant user and developer communities, and is used by leading pharmaceutical, healthcare, and biotech research firms.\n\nOn the occasion of Nextflow's anniversary, I thought it would be fun to share some perspectives and point out how far we've come as a community. I also wanted to recognize the efforts of Paolo Di Tommaso and the many people who have contributed enormous time and effort to make Nextflow what it is today.\n\n## A decade of innovation\n\nBill Gates is credited with observing that \"people often overestimate what they can do in one year, but underestimate what they can do in ten.\" The lesson, of course, is that real, meaningful change takes time. Progress is measured in a series of steps. Considered in isolation, each new feature added to Nextflow seems small, but they combine to deliver powerful capabilities.\n\nLife sciences has seen a staggering amount of innovation. According to estimates from the National Human Genome Research Institute (NHGRI), the cost of sequencing a human genome in 2013 was roughly USD 10,000. Today, sequencing costs are in the range of USD 200—a **50-fold reduction**.^1^\n\nA fundamental principle of economics is that _\"if you make something cheaper, you get more of it.\"_ One didn't need a crystal ball to see that, driven by plummeting sequencing and computing costs, the need for downstream analysis was poised to explode. With advances in sequencing technology outpacing Moore's Law, It was clear that scaling analysis capacity would be a significant issue.^2^\n\n## Getting the fundamentals right\n\nWhen Paolo and his colleagues started the Nextflow project, it was clear that emerging technologies such as cloud computing, containers, and collaborative software development would be important. Even so, it is still amazing how rapidly these key technologies have advanced in ten short years.\n\nIn an [article for eLife magazine in 2021](https://elifesciences.org/labs/d193babe/the-story-of-nextflow-building-a-modern-pipeline-orchestrator), Paolo described how Solomon Hyke's talk \"[Why we built Docker](https://www.youtube.com/watch?v=3N3n9FzebAA)\" at DotScale in the summer of 2013 impacted his thinking about the design of Nextflow. It was evident that containers would be a game changer for scientific workflows. Encapsulating application logic in self-contained, portable containers solved a multitude of complexity and dependency management challenges — problems experienced daily at the CRG and by many bioinformaticians to this day. Nextflow was developed concurrent with the container revolution, and Nextflow’s authors had the foresight to make containers first-class citizens.\n\nWith containers, HPC environments have been transformed — from complex environments where application binaries were typically served to compute nodes via NFS to simpler architectures where task-specific containers are pulled from registries on demand. Today, most bioinformatic pipelines use containers. Nextflow supports [multiple container formats](https://www.nextflow.io/docs/latest/container.html?highlight=containers) and runtimes, including [Docker](https://www.docker.com/), [Singularity](https://sylabs.io/), [Podman](https://podman.io/), [Charliecloud](https://hpc.github.io/charliecloud/), [Sarus](https://sarus.readthedocs.io/en/stable/), and [Shifter](https://github.com/NERSC/shifter).\n\n## The shift to the cloud\n\nSome of the earliest efforts around Nextflow centered on building high-quality executors for HPC workload managers. A key idea behind schedulers such as LSF, PBS, Slurm, and Grid Engine was to share a fixed pool of on-premises resources among multiple users, maximizing throughput, efficiency, and resource utilization.\n\nSee the article [Nextflow on BIG IRON: Twelve tips for improving the effectiveness of pipelines on HPC clusters](https://nextflow.io/blog/2023/best-practices-deploying-pipelines-with-hpc-workload-managers.html)\n\nWhile cloud infrastructure was initially \"clunky\" and hard to deploy and use, the idea of instant access and pay-per-use models was too compelling to ignore. In the early days, many organizations attempted to replicate on-premises HPC clusters in the cloud, deploying the same software stacks and management tools used locally to cloud-based VMs.\n\nWith the launch of [AWS Batch](https://aws.amazon.com/batch/) in December 2016, Nextflow’s developers realized there was a better way. In cloud environments, resources are (in theory) infinite and just an API call away. The traditional scheduling paradigm of sharing a finite resource pool didn't make sense in the cloud, where users could dynamically provision a private, scalable resource pool for only the duration of their workload. All the complex scheduling and control policies that tended to make HPC workload managers hard to use and manage were no longer required.^3^\n\nAWS Batch also relied on containerization, so it only made sense that AWS Batch was the first cloud-native integration to the Nextflow platform early in 2017, along with native support for S3 storage buckets. Nextflow has since been enhanced to support other batch services, including [Azure Batch](https://azure.microsoft.com/en-us/products/batch) and [Google Cloud Batch](https://cloud.google.com/batch), along with a rich set of managed cloud storage solutions. Nextflow’s authors have also embraced [Kubernetes](https://kubernetes.io/docs/concepts/overview/), developed by Google, yet another way to marshal and manage containerized application environments across public and private clouds.\n\n## SCMs come of age\n\nA major trend shaping software development has been the use of collaborative source code managers (SCMs) based on Git. When Paolo was thinking about the design of Nextflow, GitHub had already been around for several years, and DevOps techniques were revolutionizing software. These advances turned out to be highly relevant to managing pipelines. Ten years ago, most bioinformaticians stored copies of pipeline scripts locally. Nextflow’s authors recognized what now seems obvious — it would be easier to make Nextflow SCM aware and launch pipelines directly from a code repository. Today, this simple idea has become standard practice. Most users run pipelines directly from GitHub, GitLab, Gitea, or other favorite SCMs.\n\n## Modularization on steroids\n\nA few basic concepts and patterns in computer science appear repeatedly in different contexts. These include iteration, indirection, abstraction, and component reuse/modularization. Enabled by containers, we have seen a significant shift towards modularization in bioinformatics pipelines enabled by catalogs of reusable containers. In addition to general-purpose registries such as [Docker Hub](https://hub.docker.com/) and [Quay.io](https://quay.io/), domain-specific efforts such as [biocontainers](https://biocontainers.pro/) have emerged, aimed at curating purpose-built containers to meet the specialized needs of bioinformaticians.\n\nWe have also seen the emergence of platform and language-independent package managers such as [Conda](https://docs.conda.io/en/latest/). Today, almost **10,000** Conda recipes for various bioinformatics tools are freely available from [Bioconda](https://anaconda.org/bioconda/repo). Gone are the days of manually installing software. In addition to pulling pre-built bioinformatics containers from registries, developers can leverage [packages of bioconda](http://bioconda.github.io/conda-package_index.html) recipes directly from the bioconda channel.\n\nThe Nextflow community has helped lead this trend toward modularization in several areas. For example, in 2022, Seqera Labs introduced [Wave](https://seqera.io/wave/). This new service can dynamically build and serve containers on the fly based on bioconda recipes, enabling the two technologies to work together seamlessly and avoiding building and maintaining containers by hand.\n\nWith [nf-core](https://nf-co.re/), the Nextflow community has extended the concept of modularization and reuse one step further. Much as bioconda and containers have made bioinformatics software modular and portable, [nf-core modules](https://nf-co.re/modules) extend these concepts to pipelines. Today, there are **900+** nf-core modules — essentially building blocks with pre-defined inputs and outputs based on Nextflow's elegant dataflow model. Rather than creating pipelines from scratch, developers can now wire together these pre-assembled modules to deliver new functionality rapidly or use any of **80** of the pre-built [nf-core analysis pipelines](https://nf-co.re/pipelines). The result is a dramatic reduction in development and maintenance costs.\n\n## Some key Nextflow milestones\n\nSince the [first Nextflow release](https://github.com/nextflow-io/nextflow/releases/tag/v0.3.0) in July 2013, there have been **237 releases** and **5,800 commits**. Also, the project has been forked over **530** times. There have been too many important enhancements and milestones to capture here. We capture some important developments in the timeline below:\n\n<img src=\"/img/nextflow_ten_years_graphic.jpg\" alt=\"Nextflow ten year graphic\">\n\nAs we look to the future, the pace of innovation continues to increase. It’s been exciting to see Nextflow expand beyond the various _omics_ disciplines to new areas such as medical imaging, data science, and machine learning. We continue to evolve Nextflow, adding new features and capabilities to support these emerging use cases and support new compute and storage environments. I can hardly wait to see what the next ten years will bring.\n\nFor those new to Nextflow and wishing to learn more about the project, we have compiled an excellent collection of resources to help you [Learn Nextflow in 2023](https://nextflow.io/blog/2023/learn-nextflow-in-2023.html).\n\n---\n\n^1^ [https://www.genome.gov/about-genomics/fact-sheets/Sequencing-Human-Genome-cost](https://www.genome.gov/about-genomics/fact-sheets/Sequencing-Human-Genome-cost)\n^2^ Coined by Gordon Moore of Intel in 1965, Moore’s Law predicted that transistor density, roughly equating to compute performance, would roughly double every two years. This was later revised in some estimates to 18 months. Over ten years, Moore’s law predicts roughly a 2^5 = 32X increase in performance – less than the ~50-fold decrease in sequencing costs. See [chart here](https://www.genome.gov/sites/default/files/inline-images/2021_Sequencing_cost_per_Human_Genome.jpg).\n^3^ This included features like separate queues, pre-emption policies, application profiles, and weighted fairshare algorithms.",
    "images": [
      "/img/nextflow_ten_years_graphic.jpg"
    ],
    "author": "Noel Ortiz",
    "tags": "nextflow"
  },
  {
    "slug": "2023/selecting-the-right-storage-architecture-for-your-nextflow-pipelines",
    "title": "Selecting the right storage architecture for your Nextflow pipelines",
    "date": "2023-05-04T00:00:00.000Z",
    "content": "_In this article we present the various storage solutions supported by Nextflow including on-prem and cloud file systems, parallel file systems, and cloud object stores. We also discuss Fusion file system 2.0, a new high-performance file system that can help simplify configuration, improve throughput, and reduce costs in the cloud._\n\nAt one time, selecting a file system for distributed workloads was straightforward. Through the 1990s, the Network File System (NFS), developed by Sun Microsystems in 1984, was pretty much the only game in town. It was part of every UNIX distribution, and it presented a standard [POSIX interface](https://pubs.opengroup.org/onlinepubs/9699919799/nframe.html), meaning that applications could read and write data without modification. Dedicated NFS servers and NAS filers became the norm in most clustered computing environments.\n\nFor organizations that outgrew the capabilities of NFS, other POSIX file systems emerged. These included parallel file systems such as [Lustre](https://www.lustre.org/), [PVFS](https://www.anl.gov/mcs/pvfs-parallel-virtual-file-system), [OpenZFS](https://openzfs.org/wiki/Main_Page), [BeeGFS](https://www.beegfs.io/c/), and [IBM Spectrum Scale](https://www.ibm.com/products/storage-scale-system) (formerly GPFS). Parallel file systems can support thousands of compute clients and deliver more than a TB/sec combined throughput, however, they are expensive, and can be complex to deploy and manage. While some parallel file systems work with standard Ethernet, most rely on specialized low-latency fabrics such as Intel® Omni-Path Architecture (OPA) or InfiniBand. Because of this, these file systems are typically found in only the largest HPC data centers.\n\n## Cloud changes everything\n\nWith the launch of [Amazon S3](https://aws.amazon.com/s3/) in 2006, new choices began to emerge. Rather than being a traditional file system, S3 is an object store accessible through a web API. S3 abandoned traditional ideas around hierarchical file systems. Instead, it presented a simple programmatic interface and CLI for storing and retrieving binary objects.\n\nObject stores are a good fit for cloud services because they are simple and scalable to multiple petabytes of storage. Rather than relying on central metadata that presents a bottleneck, metadata is stored with each object. All operations are atomic, so there is no need for complex POSIX-style file-locking mechanisms that add complexity to the design. Developers interact with object stores using simple calls like [PutObject](https://docs.aws.amazon.com/AmazonS3/latest/API/API_PutObject.html) (store an object in a bucket in return for a key) and [GetObject](https://docs.aws.amazon.com/AmazonS3/latest/API/API_GetObject.html) (retrieve a binary object, given a key).\n\nThis simple approach was ideal for internet-scale applications. It was also much less expensive than traditional file systems. As a result, S3 usage grew rapidly. Similar object stores quickly emerged, including Microsoft [Azure Blob Storage](https://azure.microsoft.com/en-ca/products/storage/blobs/), [Open Stack Swift](https://wiki.openstack.org/wiki/Swift), and [Google Cloud Storage](https://cloud.google.com/storage/), released in 2010.\n\n## Cloud object stores vs. shared file systems\n\nObject stores are attractive because they are reliable, scalable, and cost-effective. They are frequently used to store large amounts of data that are accessed infrequently. Examples include archives, images, raw video footage, or in the case of bioinformatics applications, libraries of biological samples or reference genomes. Object stores provide near-continuous availability by spreading data replicas across cloud availability zones (AZs). AWS claims theoretical data availability of up to 99.999999999% (11 9's) – a level of availability so high that it does not even register on most [downtime calculators](https://availability.sre.xyz/)!\n\nBecause they support both near-line and cold storage, object stores are sometimes referred to as \"cheap and deep.\" Based on current [S3 pricing](https://aws.amazon.com/s3/pricing), the going rate for data storage is USD 0.023 per GB for the first 50 TB of data. Users can \"pay as they go\" — spinning up S3 storage buckets and storing arbitrary amounts of data for as long as they choose. Some high-level differences between object stores and traditional file systems are summarized below.\n\n<div class=\"table-responsive\">\n  <table class=\"table table-striped table-bordered\" style=\"font-size:80%;\">\n    <thead>\n      <tr>\n        <td></td>\n        <td>\n          **Cloud object stores**\n        </td>\n        <td>\n          **Traditional file systems**\n        </td>\n      </tr>\n    </thead>\n    <tbody>\n      <tr>\n        <td>\n          Interface / access protocol\n        </td>\n        <td>\n          HTTP-based API\n        </td>\n        <td>\n          POSIX interface\n        </td>\n      </tr>\n      <tr>\n        <td>\n          Cost\n        </td>\n        <td>\n          $\n        </td>\n        <td>\n          $$$\n        </td>\n      </tr>\n      <tr>\n        <td>\n          Scalability / capacity\n        </td>\n        <td>\n          Practically unlimited\n        </td>\n        <td>\n          Limited\n        </td>\n      </tr>\n      <tr>\n        <td>\n          Reliability / availability\n        </td>\n        <td>\n          Extremely high\n        </td>\n        <td>\n          Varies\n        </td>\n      </tr>\n      <tr>\n        <td>\n          Performance\n        </td>\n        <td>\n          Typically lower\n        </td>\n        <td>\n          Varies\n        </td>\n      </tr>\n      <tr>\n        <td>\n          Support for existing application\n        </td>\n        <td>\n          NO\n        </td>\n        <td>\n          YES\n        </td>\n      </tr>\n    </tbody>\n  </table>\n</div>\n\nThe downside of object storage is that the vast majority of applications are written to work with POSIX file systems. As a result, applications seldom interact directly with object stores. A common practice is to copy data from an object store, perform calculations locally on a cluster node, and write results back to the object store for long-term storage.\n\n## Data handling in Nextflow\n\nUnlike older pipeline orchestrators, Nextflow was built with cloud object stores in mind. Depending on the cloud where pipelines run, Nextflow manages cloud credentials and allows users to provide a path to shared data. This can be a shared file system such as `/my-shared-filesystem/data` or a cloud object store e.g. `s3://my-bucket/data/`.\n\n**Nextflow is exceptionally versatile when it comes to data handling, and can support almost any file system or object store.** Internally, Nextflow uses [executors](https://nextflow.io/docs/latest/executor.html) implemented as plug-ins to insulate pipeline code from underlying compute and storage environments. This enables pipelines to run without modification across multiple clouds regardless of the underlying storage technology.\n\nSuppose an S3 bucket is specified as a location for shared data during pipeline execution. In that case, aided by the [nf-amazon](https://github.com/nextflow-io/nextflow/tree/master/plugins/nf-amazon) plug-in, Nextflow transparently copies data from the S3 bucket to a file system on a cloud instance. Containerized applications mount the local file system and read and write data directly. Once processing is complete, Nextflow copies data to the shared bucket to be available for the next task. All of this is completely transparent to the pipeline and applications. The same plug-in-based approach is used for other cloud object stores such as Azure BLOBs and Google Cloud Storage.\n\n## The Nextflow scratch directive\n\nThe idea of staging data from shared repositories to a local disk, as described above, is not new. A common practice with HPC clusters when using NFS file systems is to use local \"scratch\" storage.\n\nA common problem with shared NFS file systems is that they can be relatively slow — especially when there are multiple clients. File systems introduce latency, have limited IO capacity, and are prone to problems such as “hot spots” and bandwidth limitations when multiple clients read and write files in the same directory.\n\nTo avoid bottlenecks, data is often copied from an NFS filer to local scratch storage for processing. Depending on data volumes, users often use fast solid-state drives or [RAM disks](https://www.mvps.net/docs/how-to-mount-the-physical-memory-from-a-linux-system-as-a-partition/) for scratch storage to accelerate processing.\n\nNextflow automates this data handling pattern with built-in support for a [scratch](https://nextflow.io/docs/latest/process.html?highlight=scratch#scratch) directive that can be enabled or disabled per process. If scratch is enabled, data is automatically copied to a designated local scratch device prior to processing.\n\nWhen high-performance file systems such as Lustre or Spectrum Scale are available, the question of whether to use scratch storage becomes more complicated. Depending on the file system and interconnect, parallel file systems performance can sometimes exceed that of local disk. In these cases, customers may set scratch to false and perform I/O directly on the parallel file system.\n\nResults will vary depending on the performance of the shared file system, the speed of local scratch storage, and the amount of shared data to be shuttled back and forth. Users will want to experiment to determine whether enabling scratch benefits pipelines performance.\n\n## Multiple storage options for Nextflow users\n\nStorage solutions used with Nextflow can be grouped into five categories as described below:\n\n- Traditional file systems\n- Cloud object stores\n- Cloud file systems\n- High-performance cloud file systems\n- Fusion file system v2.0\n\nThe optimal choice will depend on your environment and the nature of your applications and compute environments.\n\n**Traditional file systems** — These are file systems typically deployed on-premises that present a POSIX interface. NFS is the most popular choice, but some users may use high-performance parallel file systems. Storage vendors often package their offerings as appliances, making them easier to deploy and manage. Solutions common in on-prem HPC environments include [Network Appliance](https://www.netapp.com/), [Data Direct Networks](https://www.ddn.com/) (DDN), [HPE Cray ClusterStor](https://www.hpe.com/psnow/doc/a00062172enw), and [IBM Storage Scale](https://www.ibm.com/products/storage-scale-system). While customers can deploy self-managed NFS or parallel file systems in the cloud, most don’t bother with this in practice. There are generally better solutions available in the cloud.\n\n**Cloud object stores** — In the cloud, object stores tend to be the most popular solution among Nextflow users. Although object stores don’t present a POSIX interface, they are inexpensive, easy to configure, and scale practically without limit. Depending on performance, access, and retention requirements, customers can purchase different object storage tiers at different price points. Popular cloud object stores include Amazon S3, Azure BLOBs, and Google Cloud Storage. As pipelines execute, the Nextflow executors described above manage data transfers to and from cloud object storage automatically. One drawback is that because of the need to copy data to and from the object store for every process, performance may be lower than a fast shared file system.\n\n**Cloud file systems** — Often, it is desirable to have a shared file NFS system. However, these environments can be tedious to deploy and manage in the cloud. Recognizing this, most cloud providers offer cloud file systems that combine some of the best properties of traditional file systems and object stores. These file systems present a POSIX interface and are accessible via SMB and NFS file-sharing protocols. Like object stores, they are easy to deploy and scalable on demand. Examples include [Amazon EFS](https://aws.amazon.com/efs/), [Azure Files](https://azure.microsoft.com/en-us/products/storage/files/), and [Google Cloud Filestore](https://cloud.google.com/filestore). These file systems are described as \"serverless\" and \"elastic\" because there are no servers to manage, and capacity scales automatically.\n\nComparing price and performance can be tricky because cloud file systems are highly configurable. For example, [Amazon EFS](https://aws.amazon.com/efs/pricing/) is available in [four storage classes](https://docs.aws.amazon.com/efs/latest/ug/storage-classes.html) – Amazon EFS Standard, Amazon EFS Standard-IA, and two One Zone storage classes – Amazon EFS One Zone and Amazon EFS One Zone-IA. Similarly, Azure Files is configurable with [four different redundancy options](https://azure.microsoft.com/en-us/pricing/details/storage/files/), and different billing models apply depending on the offer selected. To provide a comparison, Amazon EFS Standard costs $0.08 /GB-Mo in the US East region, which is ~4x more expensive than Amazon S3.\n\nFrom the perspective of Nextflow users, using Amazon EFS and similar cloud file systems is the same as using a local NFS system. Nextflow users must ensure that their cloud instances mount the NFS share, so there is slightly more management overhead than using an S3 bucket. Nextflow users and administrators can experiment with the scratch directive governing whether Nextflow stages data in a local scratch area or reads and writes directly to the shared file system.\n\nCloud file systems suffer from some of the same limitations as on-prem NFS file systems. They often don’t scale efficiently, and performance is limited by network bandwidth. Also, depending on the pipeline, users may need to stage data to the shared file system in advance, often by copying data from an object store used for long term storage.\n\nFor [Nextflow Tower](https://cloud.tower.nf/) users, there is a convenient integration with Amazon EFS. Tower Cloud users can have an Amazon EFS instance created for them automatically via Tower Forge, or they can leverage an existing EFS instance in their compute environment. In either case, Tower ensures that the EFS share is available to compute hosts in the AWS Batch environment, reducing configuration requirements.\n\n**Cloud high-performance file systems** — For customers that need high levels of performance in the cloud, Amazon offers Amazon FSx. Amazon FSx comes in different flavors, including NetApp ONTAP, OpenZFS, Windows File Server, and Lustre. In HPC circles, [FSx for Lustre](https://aws.amazon.com/fsx/lustre/) is most popular delivering sub-millisecond latency, up to 1 TB/sec maximum throughput per file system, and millions of IOPs. Some Nextflow users with data bottlenecks use FSx for Lustre, but it is more difficult to configure and manage than Amazon S3.\n\nLike Amazon EFS, FSx for Lustre is a fully-managed, serverless, elastic file system. Amazon FSx for Lustre is configurable, depending on customer requirements. For example, customers with latency-sensitive applications can deploy FSx cluster nodes with SSD drives. Customers concerned with cost and throughput can select standard hard drives (HDD). HDD-based FSx for Lustre clusters can be optionally configured with an SSD-based cache to accelerate performance. Customers also choose between different persistent file system options and a scratch file system option. Another factor to remember is that with parallel file systems, bandwidth scales with capacity. If you deploy a Lustre file system that is too small, you may be disappointed in the performance.\n\nFSx for Lustre persistent file systems ranges from 125 to 1,000 MB/s/TiB at [prices](https://aws.amazon.com/fsx/lustre/pricing/) ranging from **$0.145** to **$0.600** per GB month. Amazon also offers a lower-cost scratch FSx for Lustre file systems (not to be confused with the scratch directive in Nextflow). At this tier, FSx for Lustre does not replicate data across availability zones, so it is suited to short-term data storage. Scratch FSx for Lustre storage delivers **200 MB/s/TiB**, costing **$0.140** per GB month. This is **~75%** more expensive than Amazon EFS (Standard) and **~6x** the cost of standard S3 storage. Persistent FSx for Lustre file systems configured to deliver **1,000 MB/s/TiB** can be up to **~26x** the price of standard S3 object storage!\n\n**Hybrid Cloud file systems** — In addition to the solutions described above, there are other solutions that combine the best of object stores and high-performance parallel file systems. An example is [WekaFS™](https://www.weka.io/) from WEKA. WekaFS is used by several Nextflow users and is deployable on-premises or across your choice cloud platforms. WekaFS is attractive because it provides multi-protocol access to the same data (POSIX, S3, NFS, SMB) while presenting a common namespace between on-prem and cloud resident compute environments. Weka delivers the performance benefits of a high-performance parallel file system and optionally uses cloud object storage as a backing store for file system data to help reduce costs.\n\nFrom a Nextflow perspective, WekaFS behaves like any other shared file system. As such, Nextflow and Tower have no specific integration with WEKA. Nextflow users will need to deploy and manage WekaFS themselves making the environment more complex to setup and manage. However, the flexibility and performance provided by a hybrid cloud file system makes this worthwhile for many organizations.\n\n**Fusion file system 2.0** — Fusion file system is a solution developed by [Seqera Labs](https://seqera.io/fusion) that aims to bridge the gap between cloud-native storage and data analysis workflows. The solution implements a thin client that allows pipeline jobs to access object storage using a standard POSIX interface, thus simplifying and speeding up most operations.\n\nThe advantage of the Fusion file system is that there is no need to copy data between S3 and local storage. The Fusion file system driver accesses and manipulates files in Amazon S3 directly. You can learn more about the Fusion file system and how it works in the whitepaper [Breakthrough performance and cost-efficiency with the new Fusion file system](https://seqera.io/whitepapers/breakthrough-performance-and-cost-efficiency-with-the-new-fusion-file-system/).\n\nFor sites struggling with performance and scalability issues on shared file systems or object storage, the Fusion file system offers several advantages. [Benchmarks conducted](https://seqera.io/whitepapers/breakthrough-performance-and-cost-efficiency-with-the-new-fusion-file-system/) by Seqera Labs have shown that, in some cases, **Fusion can deliver performance on par with Lustre but at a much lower cost.** Fusion is also significantly easier to configure and manage and can result in lower costs for both compute and storage resources.\n\n## Comparing the alternatives\n\nA summary of storage options is presented in the table below:\n\n<div class=\"table-responsive\">\n  <table class=\"table table-striped table-bordered\" style=\"font-size: 80%;\">\n    <thead>\n      <tr>\n        <td></td>\n        <td>\n          **Traditional file systems**\n        </td>\n        <td colspan=\"3\">\n          **Cloud object storage**\n        </td>\n        <td colspan=\"3\">\n          **Cloud file systems**\n        </td>\n        <td>\n          **Fusion FS**\n        </td>\n      </tr>\n      <tr>\n        <td></td>\n        <td>\n          NFS, Lustre, Spectrum Scale\n        </td>\n        <td>\n          Amazon S3\n        </td>\n        <td>\n          Azure BLOB storage\n        </td>\n        <td>\n          Google Cloud Storage\n        </td>\n        <td>\n          Amazon EFS\n        </td>\n        <td>\n          Amazon FSX for Lustre\n        </td>\n        <td>\n          Azure File\n        </td>\n        <td>\n          Fusion file system 2.0\n        </td>\n      </tr>\n    </thead>\n    <tbody>\n      <tr>\n        <td>\n          **Deployment model**\n        </td>\n        <td>\n          Manual\n        </td>\n        <td>\n          Serverless\n        </td>\n        <td>\n          Serverless\n        </td>\n        <td>\n          Serverless\n        </td>\n        <td>\n          Serverless\n        </td>\n        <td>\n          Serverless\n        </td>\n        <td>\n          Serverless\n        </td>\n        <td>\n          Serverless\n        </td>\n      </tr>\n      <tr>\n        <td>\n          **Access model**\n        </td>\n        <td>\n          POSIX\n        </td>\n        <td>\n          Object\n        </td>\n        <td>\n          Object\n        </td>\n        <td>\n          Object\n        </td>\n        <td>\n          POSIX\n        </td>\n        <td>\n          POSIX\n        </td>\n        <td>\n          POSIX\n        </td>\n        <td>\n          POSIX\n        </td>\n      </tr>\n      <tr>\n        <td>\n          **Clouds supported**\n        </td>\n        <td>\n          On-prem, any cloud\n        </td>\n        <td>\n          AWS only\n        </td>\n        <td>\n          Azure only\n        </td>\n        <td>\n          GCP only\n        </td>\n        <td>\n          AWS only\n        </td>\n        <td>\n          AWS only\n        </td>\n        <td>\n          Azure only\n        </td>\n        <td>\n          AWS, GCP and Azure ^1^\n        </td>\n      </tr>\n      <tr>\n        <td>\n          **Requires block storage**\n        </td>\n        <td>\n          Yes\n        </td>\n        <td>\n          Optional\n        </td>\n        <td>\n          Optional\n        </td>\n        <td>\n          Optional\n        </td>\n        <td>\n          Optional\n        </td>\n        <td>\n          No\n        </td>\n        <td>\n          Optional\n        </td>\n        <td>\n          No\n        </td>\n      </tr>\n      <tr>\n        <td>\n          **Relative cost**\n        </td>\n        <td>\n          $$\n        </td>\n        <td>\n          $\n        </td>\n        <td>\n          $\n        </td>\n        <td>\n          $\n        </td>\n        <td>\n          $$\n        </td>\n        <td>\n          $$$\n        </td>\n        <td>\n          $$\n        </td>\n        <td>\n          $\n        </td>\n      </tr>\n      <tr>\n        <td>\n          **Nextflow plugins**\n        </td>\n        <td>\n          -\n        </td>\n        <td>\n          nf-amazon\n        </td>\n        <td>\n          nf-azure\n        </td>\n        <td>\n          nf-google\n        </td>\n        <td>\n          -\n        </td>\n        <td>\n          -\n        </td>\n        <td>\n          -\n        </td>\n        <td>\n          nf-amazon\n        </td>\n      </tr>\n      <tr>\n        <td>\n          **Tower support**\n        </td>\n        <td>\n          Yes\n        </td>\n        <td>\n          Yes, existing buckets\n        </td>\n        <td>\n          Yes, existing BLOB container\n        </td>\n        <td>\n          Yes, existing cloud storage bucket\n        </td>\n        <td>\n          Yes, creates EFS instances\n        </td>\n        <td>\n          Yes, creates FSx for Lustre instances\n        </td>\n        <td>\n          File system created manually\n        </td>\n        <td>\n          Yes, fully automated\n        </td>\n      </tr>\n      <tr>\n        <td>\n          **Dependencies**\n        </td>\n        <td>\n          Externally configured\n        </td>\n        <td></td>\n        <td></td>\n        <td></td>\n        <td></td>\n        <td></td>\n        <td></td>\n        <td>\n          Wave Amazon S3\n        </td>\n      </tr>\n      <tr>\n        <td>\n          **Cost model**\n        </td>\n        <td>\n          Fixed price on-prem, instance+block storage costs\n        </td>\n        <td>\n          GB per month\n        </td>\n        <td>\n          GB per month\n        </td>\n        <td>\n          GB per month\n        </td>\n        <td>\n          Multiple factors\n        </td>\n        <td>\n          Multiple factors\n        </td>\n        <td>\n          Multiple factors\n        </td>\n        <td>\n          GB per month (uses S3)\n        </td>\n      </tr>\n      <tr>\n        <td>\n          **Level of configuration effort (when used with Tower)**\n        </td>\n        <td>\n          High\n        </td>\n        <td>\n          Low\n        </td>\n        <td>\n          Low\n        </td>\n        <td>\n          Low\n        </td>\n        <td>\n          Medium (low with Tower)\n        </td>\n        <td>\n          High (easier  with Tower)\n        </td>\n        <td>\n          Medium\n        </td>\n        <td>\n          Low\n        </td>\n      </tr>\n      <tr>\n        <td>\n          **Works best with:**\n        </td>\n        <td>\n          Any on-prem cluster manager (LSF, Slurm, etc.)\n        </td>\n        <td>\n          AWS Batch\n        </td>\n        <td>\n          Azure Batch\n        </td>\n        <td>\n          Google Cloud Batch\n        </td>\n        <td>\n          AWS Batch\n        </td>\n        <td>\n          AWS Batch\n        </td>\n        <td>\n          Azure Batch\n        </td>\n        <td>\n          AWS Batch, Amazon EKS, Azure Batch, Google Cloud Batch ^1^\n        </td>\n      </tr>\n    </tbody>\n  </table>\n</div>\n\n## So what’s the bottom line?\n\nThe choice or storage solution depends on several factors. Object stores like Amazon S3 are popular because they are convenient and inexpensive. However, depending on data access patterns, and the amount of data to be staged in advance, file systems such as EFS, Azure Files or FSx for Lustre can also be a good alternative.\n\nFor many Nextflow users, Fusion file system will be a better option since it offers performance comparable to a high-performance file system at the cost of cloud object storage. Fusion is also dramatically easier to deploy and manage. [Adding Fusion support](https://nextflow.io/docs/latest/fusion.html) is just a matter of adding a few lines to the `nextflow.config` file.\n\nWhere workloads run is also an important consideration. For example, on-premises clusters will typically use whatever shared file system is available locally. When operating in the cloud, you can choose whether to use cloud file systems, object stores, high-performance file systems, Fusion FS, or hybrid cloud solutions such as Weka.\n\nStill unsure what storage solution will best meet your needs? Consider joining our community at [nextflow.slack.com](https://nextflow.slack.com/). You can engage with others, post technical questions, and learn more about the pros and cons of the storage solutions described above.",
    "images": [],
    "author": "Paolo Di Tommaso",
    "tags": "nextflow"
  },
  {
    "slug": "2023/the-state-of-kubernetes-in-nextflow",
    "title": "The State of Kubernetes in Nextflow",
    "date": "2023-03-10T00:00:00.000Z",
    "content": "Hi, my name is Ben, and I’m a software engineer at Seqera Labs. I joined Seqera in November 2021 after finishing my Ph.D. at Clemson University. I work on a number of things at Seqera, but my primary role is that of a Nextflow core contributor.\n\nI have run Nextflow just about everywhere, from my laptop to my university cluster to the cloud and Kubernetes. I have written Nextlfow pipelines for bioinformatics and machine learning, and I even wrote a pipeline to run other Nextflow pipelines for my [dissertation research](https://github.com/bentsherman/tesseract). While I tried to avoid contributing code to Nextflow as a student (I had enough work already), now I get to work on it full-time!\n\nWhich brings me to the topic of this post: Nextflow and Kubernetes.\n\nOne of my first contributions was a “[best practices guide](https://github.com/seqeralabs/nf-k8s-best-practices)” for running Nextflow on Kubernetes. The guide has helped many people, but for me it provided a map for how to improve K8s support in Nextflow. You see, Nextflow was originally built for HPC, while Kubernetes and cloud batch executors were added later. While Nextflow’s extensible design makes adding features like new executors relatively easy, support for Kubernetes is still a bit spotty.\n\nSo, I set out to make Nextflow + K8s great! Over the past year, in collaboration with talented members of the Nextflow community, we have added all sorts of enhancements to the K8s executor. In this blog post, I’d like to show off all of these improvements in one place. So here we go!\n\n## New features\n\n### Submit tasks as Kubernetes Jobs\n\n_New in version 22.05.0-edge._\n\nNextflow submits tasks as Pods by default, which is sort of a bad practice. In Kubernetes, every Pod should be created through a controller (e.g., Deployment, Job, StatefulSet) so that Pod failures can be handled automatically. For Nextflow, the appropriate controller is a K8s Job. Using Jobs instead of Pods directly has greatly improved the stability of large Nextflow runs on Kubernetes, and will likely become the default behavior in a future version.\n\nYou can enable this feature with the following configuration option:\n\n```groovy\nk8s.computeResourceType = 'Job'\n```\n\nCredit goes to @xhejtman from CERIT-SC for leading the charge on this one!\n\n### Object storage as the work directory\n\n_New in version 22.10.0._\n\nOne of the most difficult aspects of using Nextflow with Kubernetes is that Nextflow needs a `PersistentVolumeClaim` (PVC) to store the shared work directory, which also means that Nextflow itself must run inside the Kubernetes cluster in order to access this storage. While the `kuberun` command attempts to automate this process, it has never been reliable enough for production usage.\n\nAt the Nextflow Summit in October 2022, we introduced [Fusion](https://seqera.io/fusion/), a file system driver that can mount S3 buckets as POSIX-like directories. The combination of Fusion and [Wave](https://seqera.io/wave/) (a just-in-time container provisioning service) enables you to have your work directory in S3-compatible storage. See the [Wave blog post](https://nextflow.io/blog/2022/rethinking-containers-for-cloud-native-pipelines.html) for an explanation of how it works — it’s pretty cool.\n\nThis functionality is useful in general, but it is especially useful for Kubernetes, because (1) you don’t need to provision your own PVC and (2) you can run Nextflow on Kubernetes without using `kuberun` or creating your own submitter Pod.\n\nThis feature currently supports AWS S3 on Elastic Kubernetes Service (EKS) clusters and Google Cloud Storage on Google Kubernetes Engine (GKE) clusters.\n\nCheck out [this article](https://seqera.io/blog/deploying-nextflow-on-amazon-eks/) over at the Seqera blog for an in-depth guide to running Nextflow (with Fusion) on Amazon EKS.\n\n### No CPU limits by default\n\n_New in version 22.11.0-edge._\n\nWe have changed the default behavior of CPU requests for the K8s executor. Before, a single number in a Nextflow resource request (e.g., `cpus = 8`) was interpreted as both a “request” (lower bound) and a “limit” (upper bound) in the Pod definition. However, setting an explicit CPU limit in K8s is increasingly seen as an anti-pattern (see [this blog post](https://home.robusta.dev/blog/stop-using-cpu-limits) for an explanation). The bottom line is that it is better to specify a request without a limit, because that will ensure that each task has the CPU time it requested, while also allowing the task to use more CPU time if it is available. Unlike other resources like memory and disk, CPU time is compressible — it can be given and taken away without killing the application.\n\nWe have also updated the Docker integration in Nextflow to use [CPU shares](https://www.batey.info/cgroup-cpu-shares-for-docker.html), which is the mechanism used by [Kubernetes](https://www.batey.info/cgroup-cpu-shares-for-kubernetes.html) and [AWS Batch](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definition_parameters.html#container_definitions) under the hood to define expandable CPU requests. These changes make the behavior of CPU requests in Nextflow much more consistent across executors.\n\n### CSI ephemeral volumes\n\n_New in version 22.11.0-edge._\n\nIn Kubernetes, volumes are used to provide storage and data (e.g., configuration and secrets) to Pods. Persistent volumes exist independently of Pods and can be mounted and unmounted over time, while ephemeral volumes are attached to a single Pod and are created and destroyed alongside it. While Nextflow can use any persistent volume through a `PersistentVolumeClaim`, ephemeral volume types are supported on a case-by-case basis. For example, `ConfigMaps` and `Secrets` are two ephemeral volume types that are already supported by Nextflow.\n\nNextflow now also supports [CSI ephemeral volumes](https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#csi-ephemeral-volumes). CSI stands for Container Storage Interface, and it is a standard used by Kubernetes to support third-party storage systems as volumes. The most common example of a CSI ephemeral volume is [Secrets Store](https://secrets-store-csi-driver.sigs.k8s.io/getting-started/usage.html), which is used to inject secrets from a remote vault such as [Hashicorp Vault](https://www.vaultproject.io/) or [Azure Key Vault](https://azure.microsoft.com/en-us/products/key-vault/).\n\n_Note: CSI persistent volumes can already be used in Nextflow through a `PersistentVolumeClaim`._\n\n### Local disk storage for tasks\n\n_New in version 22.11.0-edge._\n\nNextflow uses a shared work directory to coordinate tasks. Each task receives its own subdirectory with the required input files, and each task is expected to write its output files to this directory. As a workflow scales to thousands of concurrent tasks, this shared storage becomes a major performance bottleneck. We are investigating a few different ways to overcome this challenge.\n\nOne of the tools we have to reduce I/O pressure on the shared work directory is to make tasks use local storage. For example, if a task takes input file A, produces an intermediate file B, then produces an output file C, the file B can be written to local storage instead of shared storage because it isn’t a required output file. Or, if the task writes an output file line by line instead of all at once at the end, it can stream the output to local storage first and then copy the file to shared storage.\n\nWhile it is far from a comprehensive solution, local storage can reduce I/O congestion in some cases. Provisioning local storage for every task looks different on every platform, and in some cases it is not supported. Fortunately, Kubernetes provides a seamless interface for local storage, and now Nextflow supports it as well.\n\nTo provision local storage for tasks, you must (1) add an `emptyDir` volume to your Pod options, (2) request disk storage via the `disk` directive, and (3) direct tasks to use the local storage with the `scratch` directive. Here’s an example:\n\n```groovy\nprocess {\n    disk = 10.GB\n    pod = [ [emptyDir: [:], mountPath: '/scratch'] ]\n    scratch = '/scratch'\n}\n```\n\nAs a bonus, you can also provision an `emptyDir` backed by memory:\n\n```groovy\nprocess {\n    memory = 10.GB\n    pod = [ [emptyDir: [medium: 'Memory'], mountPath: '/scratch'] ]\n    scratch = '/scratch'\n}\n```\n\nNextflow maps the `disk` directive to the [`ephemeral-storage`](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#setting-requests-and-limits-for-local-ephemeral-storage) resource request, which is provided by the [`emptyDir`](https://kubernetes.io/docs/concepts/storage/volumes/#emptydir) volume (another ephemeral volume type).\n\n### Miscellaneous\n\nCheck the [release notes](https://github.com/nextflow-io/nextflow/releases) or the list of [K8s pull requests](https://github.com/nextflow-io/nextflow/pulls?q=is%3Apr+label%3Aplatform%2Fk8s) on Github to see what else has been added. Here are some notable improvements from the past year:\n\n- Support Pod `affinity` ([640cbed4](https://github.com/nextflow-io/nextflow/commit/640cbed4813a34887d4dc10f87fa2e4aa524d055))\n- Support Pod `automountServiceAccountToken` ([1b5908e4](https://github.com/nextflow-io/nextflow/commit/1b5908e4cbbb79f93be2889eec3acfa6242068a1))\n- Support Pod `priorityClassName` ([51650f8c](https://github.com/nextflow-io/nextflow/commit/51650f8c411ba40f0966031035e7a47c036f542e))\n- Support Pod `tolerations` ([7f7cdadc](https://github.com/nextflow-io/nextflow/commit/7f7cdadc6a36d0fb99ef125f6c6f89bfca8ca52e))\n- Support `time` directive via `activeDeadlineSeconds` ([2b6f70a8](https://github.com/nextflow-io/nextflow/commit/2b6f70a8fa55b993fa48755f7a47ac9e1b584e48))\n- Improved control over error conditions ([064f9bc4](https://github.com/nextflow-io/nextflow/commit/064f9bc4), [58be2128](https://github.com/nextflow-io/nextflow/commit/58be2128), [d86ddc36](https://github.com/nextflow-io/nextflow/commit/d86ddc36))\n- Improved support for labels and queue annotation ([9951fcd9](https://github.com/nextflow-io/nextflow/commit/9951fcd9), [4df8c8d2](https://github.com/nextflow-io/nextflow/commit/4df8c8d2))\n- Add support for AWS IAM role for Service Accounts ([62df42c3](https://github.com/nextflow-io/nextflow/commit/62df42c3), [c3364d0f](https://github.com/nextflow-io/nextflow/commit/c3364d0f), [b3d33e3b](https://github.com/nextflow-io/nextflow/commit/b3d33e3b))\n\n## Beyond Kubernetes\n\nWe’ve added tons of value to Nextflow over the past year – not just in terms of Kubernetes support, but also in terms of performance, stability, and integrations with other technologies – and we aren’t stopping any time soon! We have greater ambitions still for Nextflow, and I for one am looking forward to what we will accomplish together. As always, keep an eye on this blog, as well as the [Nextflow GitHub](https://github.com/nextflow-io/nextflow) page, for the latest updates to Nextflow.",
    "images": [],
    "author": "Ben Sherman",
    "tags": "nextflow, kubernetes"
  },
  {
    "slug": "2024/addressing-bioinformatics-core-challenges",
    "title": "Addressing Bioinformatics Core Challenges with Nextflow and nf-core",
    "date": "2024-09-11T00:00:00.000Z",
    "content": "I was honored to be invited to the ISMB 2024 congress to speak at the session organised by the COSI (Community of Special Interest) of Bioinformatics Cores. This session brought together bioinformatics professionals from around the world who manage bioinformatics facilities in different institutions to share experiences, discuss challenges, and explore solutions for managing and analyzing large-scale biological data. In this session, I had the opportunity to introduce Nextflow, and discuss how its adoption can help bioinformatics cores to address some of the most common challenges they face. From managing complex pipelines to optimizing resource utilization, Nextflow offers a range of benefits that can streamline workflows and improve productivity. In this blog, I'll summarize my talk and share insights on how Nextflow can help overcome some of those challenges, including meeting the needs of a wide range of users or customers, automate reporting, customising pipelines and training.\n\n### Challenge 1: running multiple services\n\n_Challenge description: “I have a wide range of stakeholders, and my pipelines need to address different needs in multiple scientific domains”_\n\nOne of the biggest challenges faced by bioinformatics cores is catering to a diverse range of users with varying applications. On one hand, one might need to run analyses for researchers focused on cancer or human genetics. On the other hand, one may also need to support scientists working with mass spectrometry or metagenomics. Fortunately, the nf-core community has made it relatively easy to tackle these diverse needs with their curated pipelines. These pipelines are ready to use, covering a broad spectrum of applications, from genomics and metagenomics to immunology and mass spectrometry. In one of my slides I showed a non-exhaustive list, which spans genomics, metagenomics, immunology, mass spec, and more: one can find best-practice pipelines for almost any bioinformatics application imaginable, including emerging areas like imaging and spatial-omics. By leveraging this framework, one can not only tap into the expertise of the pipeline developers but also engage with them to discuss specific needs and requirements. This collaborative approach can significantly ease the deployment of a workflow, allowing the user to focus on high-priority tasks while ensuring that the analyses are always up to date and aligned with current best practices.\n\n### Challenge 2: customising applications\n\n_Challenge description: “We often need to customise our applications and pipeline, to meet specific in-house needs of our users”_\n\nWhile ready-to-use applications are a huge advantage, there are times when customisation is necessary. Perhaps the standard pipeline that works for most users doesn't quite meet the specific needs of a facilities user or customer. Fortunately, the nf-core community has got these cases covered. With over 1,300 modules at everyone’s disposal, one can easily compose their own pipeline using the nf-core components and tooling. Should that not be enough though, one can even create a pipeline from scratch using nf-core tools. For instance, one can run a simple command like “nf-core create” followed by the name of the pipeline, and voilà! The software package will create a complete skeleton for the pipeline, filled with pre-compiled code and placeholders to ease customisation. This process is incredibly quick, as I demonstrated in a video clip during the talk, where a pipeline skeleton was created in just a few moments.\n\nOf course, customisation isn't limited to pipelines. It also applies to containers, which are a crucial enabler of portability. When it comes to containers, Nextflow users have two options: an easy way and a more advanced approach. The easy way involves using Seqera Containers, a platform that allows anyone to compose a container using tools from bioconda, pypi, and conda-forge. No need for logging in, just select the tools, and the URL of your container will be made available in no time. One can build containers for either Docker or Singularity, and for different platforms (amd64 or arm64).\n\nIf one is looking for more control, they can use Wave as a command line. This is a powerful tool that can act as an intermediary between the user and a container registry. Wave builds containers on the fly, allowing anyone to pass a wave build command as an evaluation inside a docker run command. It's incredibly fast, and builds containers from conda packages in a matter of seconds. Wave, which is also the engine behind Seqera Containers, can be extremely handy to allow other operations like container augmentation. This feature enables a user to add new layers to existing containers without having to rebuild them, thanks to Docker's layer-based architecture. One can simply create a folder where configuration files or executable scripts are located, pass the folder to Wave which will add the folder with a new layer, and get the URL of the augmented container on the fly.\n\n### Challenge 3: Reporting\n\n_Challenge description: “I need to deliver a clear report of the analysis results, in a format that is accessible and can be used for publication purposes by my users”_\n\nReporting is a crucial aspect of any bioinformatics pipeline, and as for customisation Nextflow offers different ways to approach it. suitable for different levels of expertise. The most straightforward solution involves running MultiQC, a tool that collects the output and logs of a wide range of software in a pipeline and generates a nicely formatted HTML report. This is a great option if one wants a quick and easy way to get a summary of their pipeline's results. MultiQC is a widely used tool that supports a huge list (and growing) of bioinformatics tools and file formats, making it a great choice for many use cases.\n\nHowever, if the developer needs more control over the reporting process or wants to create a custom report that meets some specific needs, it is entirely possible to engineer the reports from scratch. This involves collecting the outputs from various processes in the pipeline and passing them as an input to a process that runs an R Markdown or Quarto script. R Markdown and Quarto are popular tools for creating dynamic documents that can be parameterised, allowing anyone to customize the content and the layout of a report dynamically.\nBy using this approach, one can create a report that is tailored to your specific needs, including the types of plots and visualizations they want to include, the formatting and layouting, branding, and anything specific one might want to highlight.\n\nTo follow this approach, the user can either create their own customised module, or re-use one of the available notebooks modules in the nf-core repository (quarto [here](https://github.com/nf-core/modules/tree/master/modules/nf-core/quartonotebook), or jupyter [here](https://github.com/nf-core/modules/tree/master/modules/nf-core/jupyternotebook)).\n\n### Challenge 4: Monitoring\n\n_Challenge description: “I need to be able to estimate and optimise runtimes as well as costs of my pipelines, fitting our cost model”_\n\nMonitoring is a critical aspect of pipeline management, and Nextflow provides a robust set of tools to help you track and optimise a pipeline's performance. At its core, monitoring involves tracking the execution of the pipeline to ensure that it's running efficiently and effectively. But it's not just about knowing how long a pipeline takes to run or how much it costs - it's also about making sure each process in the pipeline is using the requested resources efficiently.\nWith Nextflow, the user can track the resources used by each process in your pipeline, including CPU, memory, and disk usage and compare them visually with the resources requested in the pipeline configuration and reserved by each job. This information allows the user to identify bottlenecks and areas for optimisation, so one can fine-tune their pipeline for a better resource consumption. For example, if the user notices that one process is using a disproportionate amount of memory, they can adjust the configuration to better match the actual usage.\n\nBut monitoring isn't just about optimising a pipeline's performance - it's also about reducing the environmental impact where possible. A recently developed Nextflow plugin allows to track the carbon footprint of a pipeline, including the energy consumption and greenhouse gas emissions associated with running that pipeline. This information allows one to make informed decisions about their environmental impact, and gaining better awareness or even adopting greener strategies to computing.\n\nOne of the key benefits of Nextflow’s monitoring system is its flexibility. The user can either use the built-in html reports for trace and pipeline execution, or could monitor a run live by connecting to Seqera Platform and visualising its progress on a graphical interface in real time. More expert or creative users could use the trace file produced by a Nextflow execution, to create their own metrics and visualisations.\n\n### Challenge 5: User accessibility\n\n_Challenge description: “I could balance workloads better, by giving users a certain level of autonomy in running some of my pipelines”_\n\nUser accessibility is a crucial aspect of pipeline development, as it enables users with varying levels of bioinformatics experience to run complex pipelines with ease. One of the advantages of Nextflow, is that a developer can create pipelines that are not only robust and efficient but also user-friendly. Allowing your users to run them with a certain level of autonomy might be a good strategy in a bioinformatics core to decentralise straightforward analyses and invest human resources on more complex projects. Empowering a facility’s users to run specific pipelines independently could be a solution to reduce certain workloads.\n\nThe nf-core template includes a parameters schema, which is captured by the nf-core website to create a graphical interface for parameters configuration of the pipelines hosted under the nf-core organisation on GitHub. This interface allows users to fill in the necessary fields for parameters needed to run a pipeline, and allows even users with minimal experience with bioinformatics or command-line interfaces to quickly set up a run. The user can then simply copy and paste the command generated by the webpage into a terminal, and the pipeline will launch as configured. This approach is ideal for users who are familiar with basic computer tasks, and have a very minimal familiarity with a terminal.\n\nHowever, for users with even less bioinformatics experience, Nextflow and the nf-core template together offer an even more intuitive solution. The pipeline can be added to the launcher of the Seqera Platform, and one can provide users with a comprehensive and user-friendly interface that allows them to launch pipelines with ease. This platform offers a range of features, including access to datasets created from sample sheets, the ability to launch pipelines on a wide range of cloud environments as well as on HPC on-premise. A simple graphical interface simplifies the entire process.The Seqera Platform provides in this way a seamless and intuitive experience for users, allowing them to run pipelines without requiring extensive bioinformatics knowledge.\n\n### Challenge 6: Training\n\n_Challenge description: “Training my team and especially onboarding new team members is always challenging and requires documentation and good materials”_\n\nThe final challenge we often face in bioinformatics facilities is training. We all know that training is an ongoing issue, not just because of staff turnover and the need to onboard new recruits, but also because the field is constantly evolving. With new tools, techniques, and technologies emerging all the time, it can be difficult to keep up with the latest developments. However, training is crucial for ensuring that pipelines are robust, efficient, and accurate.\n\nFortunately, there are now many resources available to help with training. The Nextflow training website, for example, has been completely rebuilt recently and now offers a wealth of material suitable for everyone, from beginners to experts. Whether you're just starting out with Nextflow or are already an experienced user, you'll find plenty of resources to help you improve your skills. From introductory tutorials to advanced guides, the training website has everything you need to get the most out of this workflow manager.\n\nEveryone can access the material at their own pace, but regular training events have been scheduled during the year. Additionally, there is now a network of Nextflow Ambassadors who often organise local training events across the world. Without making comparisons with other solutions, I can easily say that the steep learning curve to get going with Nextflow is just a myth nowadays. The quality of the training material, the examples available, the frequency of events in person or online you can attend to, and more importantly a welcoming community of users, make learning Nextflow quite easy.\n\nIn my laboratory, usually in a couple of months bachelor students are reasonably confident with the code and with running pipelines and debugging common issues.\n\n### Conclusions\n\nIn conclusion, the presentation at ISMB has gathered quite some interest because I believe it has shown how Nextflow is a powerful and versatile tool that can help bioinformatics cores address those common challenges everyone has experienced. With its comprehensive tooling, extensive training materials, and active community of users, Nextflow offers a complete package that can help people streamline their workflows and improve their productivity.\nAlthough I might be biased on this, I also believe that by adopting Nextflow one also becomes part of a community of researchers and developers who are passionate about bioinformatics and committed to sharing their knowledge and expertise. Beginners not only will have access to a wealth of resources and tutorials, but more importantly to a supportive network of peers who can offer advice and guidance, and which is really fun to be part of.",
    "images": [],
    "author": "Francesco Lescai",
    "tags": "nextflow,ambassador_post"
  },
  {
    "slug": "2024/ambassador-second-call",
    "title": "Open call for new Nextflow Ambassadors closes June 14",
    "date": "2024-05-17T00:00:00.000Z",
    "content": "Nextflow Ambassadors are passionate individuals within the Nextflow community who play a more active role in fostering collaboration, knowledge sharing, and engagement. We launched this program at the Nextflow Summit in Barcelona last year, and it's been a great experience so far, so we've been recruiting more volunteers to expand the program. We’re going to close applications in June with the goal of having new ambassadors start in July, so if you’re interested in becoming an ambassador, now is your chance to apply!\n\n<!-- end-archive-description -->\n\nThe program has been off to a great start, bringing together a diverse group of 46 passionate individuals from around the globe. Our ambassadors have done a great job in their dedication to spreading the word about Nextflow, contributing significantly to the community in numerous ways, including writing insightful content, organizing impactful events, conducting training sessions, leading hackathons, and even contributing to the codebase. Their efforts have not only enhanced the Nextflow ecosystem but have also fostered a stronger, more interconnected global community.\n\nTo support their endeavors, we provide our ambassadors with exclusive swag, essential assets to facilitate their work and funding to attend events where they can promote Nextflow. With the end of the first semester fast approaching, we are excited to officially announce the second cohort of the Nextflow Ambassador program will start in July. If you are passionate about Nextflow and eager to make a meaningful impact, we invite you to [apply](http://seqera.typeform.com/ambassadors/) and join our vibrant community of ambassadors.\n\n**Application Details:**\n\n- **Call for Applications:** Open until June 14 (23h59 any timezone)\n- **Notification of Acceptance:** By June 30\n- **Program Start:** July 2024\n\n<div style=\"margin-top: 2rem; margin-bottom: 2rem;\">\n    <img src=\"/img/ambassadors-hackathon.jpeg\" alt=\"Ambassadors on action!\">\n</div>\n\nWe seek enthusiastic individuals ready to take their contribution to the next level through various initiatives such as content creation, event organization, training, hackathons, and more. As an ambassador, you will receive support and resources to help you succeed in your role, including swag, necessary assets, and funding for event participation.\n\nTo apply, please visit our [Nextflow Ambassador Program Application Page](http://seqera.typeform.com/ambassadors/) and submit your application no later than 23h59 June 14 (any timezone). The form shouldn’t take more than a few minutes to complete. We are eager to welcome a new group of ambassadors who will help support the growth and success of the Nextflow community.\n\nThanks to all our current ambassadors for their incredible work and dedication. We look forward to seeing the new ideas and initiatives that the next cohort of ambassadors will bring to the table. Together, let's continue to build a stronger, more dynamic Nextflow community.\n\n[Apply now and become a part of the Nextflow journey!](http://seqera.typeform.com/ambassadors/)\n\n---\n\nStay tuned for more updates and follow us on our [social](https://twitter.com/nextflowio) [media](https://x.com/seqeralabs) [channels](https://www.linkedin.com/company/seqera/posts/) to keep up with the latest news and events from the Nextflow community.",
    "images": [
      "/img/ambassadors-hackathon.jpeg"
    ],
    "author": "Marcel Ribeiro-Dantas",
    "tags": "nextflow,ambassador_program,ambassador_post"
  },
  {
    "slug": "2024/better-support-through-community-forum-2024",
    "title": "Moving toward better support through the Community forum",
    "date": "2024-08-28T00:00:00.000Z",
    "content": "As the Nextflow community continues to grow, fostering a space where users can easily find help and share knowledge is more important than ever. In this post, we’ll explore our ongoing efforts to enhance the community forum, transitioning from Slack as the primary platform for peer-to-peer support. By improving the forum’s usability and accessibility, we’re aiming to create a more efficient and welcoming environment for everyone. Read on to learn about the changes we’re implementing and how you can contribute to making the forum an even better resource for the community.\n\n<!-- end-archive-description -->\n\n---\n\nOne of the things that impressed me the most when I joined Seqera last year as a developer advocate for the Nextflow community, was how engaged people are, and how much peer-to-peer interaction there is across a vast range of scientific domains, cultures, and geographies. That’s wonderful for a number of reasons, not least of which is that whenever you run into a problem —or you’re trying to do something a bit complicated or new— it’s very likely that there is someone out there who is able and willing to help you figure it out.\n\nFor the past few months, our small team of developer advocates have been thinking about how to nurture that dynamism, and how to further improve the experience of peer-to-peer support as the Nextflow community continues to grow. We’ve come to the conclusion that the best thing we can do is make the [community forum](https://community.seqera.io/) an awesome place to go for help, answers, and resources.\n\n## Why focus on the forum?\n\nIf you’re familiar with the Nextflow Slack workspace, you know there’s a lot of activity there, and the #help channel is always hopping. It’s true, and that’s great, buuuuut using Slack has some important downsides that the forum doesn’t suffer from.\n\nOne of the standout features of the forum is the ability to search past questions and answers really easily. Whether you're browsing directly within the forum, or using Google or some other search engine, you can quickly find relevant information in a way that’s much harder to do on Slack. This means that solutions to common issues are readily accessible, saving you (and the resident experts who have already answered the same question a bunch of times) a whole lot of time and effort.\n\nAdditionally, the forum has no barrier to access— you can view all the content without the need to join yet another app. This open access ensures that everyone can benefit from the wealth of knowledge shared by community members.\n\n## Immediate improvements to the forum’s ease of use\n\nWe’re excited to roll out a few immediate changes to the forum that should make it easier and more pleasant to use.\n\n- We’re introducing a new, sleeker visual design to make navigation and posting more intuitive and enjoyable.\n\n- We’ve reorganized the categories to streamline the process of finding and providing help. Instead of having separate categories for various things (like Nextflow, Wave, Seqera Platform etc), there is now a single \"Ask for help\" category for all topics, eliminating any confusion about where to post your question. Simply put, if you need help, just post in the \"Ask for help\" category. Done.\n\nWe’re also planning to mirror existing categories from the Nextflow Slack workspace, such as the jobs board and shameless promo channels, to make that content more visible and searchable. This will help you find opportunities and promote your work more effectively.\n\n## What you can do to help\n\nThese changes are meant to make the forum a great place for peer-to-peer support for the Nextflow community. You can help us improve it further by giving us your feedback about the forum functionality (don’t be shy), by posting your questions in the forum, and of course, if you’re already a Nextflow expert, by answering questions there.\n\nCheck out the [community forum](https://community.seqera.io/) now!",
    "images": [],
    "author": "Geraldine Van der Auwera",
    "tags": "nextflow,community"
  },
  {
    "slug": "2024/bioinformatics-growth-in-turkiye",
    "title": "Fostering Bioinformatics Growth in Türkiye",
    "date": "2024-06-12T00:00:00.000Z",
    "content": "After diving into the Nextflow community, I've seen how it benefits bioinformatics in places like South Africa, Brazil, and France. I'm confident it can do the same for Türkiye by fostering collaboration and speeding up research. Since I became a Nextflow Ambassador, I am happy and excited because I can contribute to this development! Even though our first attempt to organize an introductory Nextflow workshop was online, it was a fruitful collaboration with RSG-Türkiye that initiated our effort to promote more Nextflow in Türkiye. We are happy to announce that we will organize a hands-on workshop soon.\n\n<!-- end-archive-description -->\n\nI am [Kübra Narcı](https://www.ghga.de/about-us/team-members/narci-kuebra), currently employed as a bioinformatician within the [German Human Genome Phenome Archive (GHGA) Workflows workstream](https://www.ghga.de/about-us/how-we-work/workstreams). Upon commencing this position nearly two years ago, I was introduced to Nextflow due to the necessity of transporting certain variant calling workflows here, and given my prior experience with other workflow managers, I was well-suited for the task. Though the initial two months were marked by challenges and moments of frustration, my strong perseverance ultimately led to the successful development of my first pipeline.\n\nSubsequently, owing much to the supportive Nextflow community, my interest, as well as my proficiency in the platform, steadily grew, culminating in my acceptance to the role of Nextflow Ambassador for the past six months. I jumped into the role since it was a great opportunity for GHGA and Nextflow to be connected even more.\n\n<div style=\"margin-top: 2rem; margin-bottom: 2rem;\">\n    <img src=\"/img/blog-2024-06-12-turkish_workshop1a.png\" alt=\"meme on bright landscape\">\n</div>\n\nTransitioning into this ambassadorial role prompted a solid realization: the absence of a dedicated Nextflow community in Türkiye. This revelation was a shock, particularly given my academic background in bioinformatics there, where the community’s live engagement in workflow development is undeniable. Witnessing Turkish contributors within Nextflow and nf-core Slack workspaces further underscored this sentiment. It became evident that what was lacking was a spark for organizing events to ignite the Turkish community, a task I gladly undertook.\n\nWhile I possessed foresight regarding the establishment of a Nextflow community, I initially faced uncertainty regarding the appropriate course of action. To address this, I sought counsel from [Marcel](https://www.twitter.com/mribeirodantas), given his pivotal role in the initiation of the Nextflow community in Brazil. Following our discussion and receipt of valuable insights, it became evident that establishing connections with the appropriate community from my base in Germany was a necessity.\n\nThis attempt led me to meet with [RSG-Türkiye](https://rsgturkey.com). RSG-Türkiye aims to create a platform for students and post-docs in computational biology and bioinformatics in Türkiye. It aims to share knowledge and experience, promote collaboration, and expand training opportunities. The organization also collaborates with universities and the Bioinformatics Council, a recently established national organization as the Turkish counterpart of the ISCB (International Society for Computational Biology) to introduce industrial and academic research. To popularize the field, they have offline and online talk series in university student centers to promote computational biology and bioinformatics.\n\nFollowing our introduction, RSG-Türkiye and I hosted a workshop focusing on workflow reproducibility, Nextflow, and nf-core. We chose Turkish as the language to make it more accessible for participants who are not fluent in English. The online session lasted a bit more than an hour and attracted nearly 50 attendees, mostly university students but also individuals from the research and industry sectors. The strong student turnout was especially gratifying as it aligned with my goal of building a vibrant Nextflow community in Türkiye. I took the opportunity to discuss Nextflow’s ambassadorship and mentorship programs, which can greatly benefit students, given Türkiye’s growing interest in bioinformatics. The whole workshop was recorded and can be viewed on [YouTube](https://www.youtube.com/watch?v=AqNmIkoQrNo&amp;ab_channel=RSG-Turkey).\n\nI am delighted to report that the workshop was a success. It was not only attracting considerable interest but also marked the commencement of a promising journey. Our collaboration with RSG-Türkiye persists, with plans underway for a more comprehensive on-site training session in Türkiye scheduled for later this year. I look forward to more engagement from Turkish participants as we work together to strengthen our community. Hopefully, this effort will lead to more Turkish-language content, new mentor relations from the core Nextflow team, and the emergence of a local Nextflow ambassador.\n\n<div style=\"margin-top: 2rem; margin-bottom: 2rem;\">\n    <img src=\"/img/blog-2024-06-12-turkish_workshop2a.png\" alt=\"meme on bright landscape\">\n</div>\n\n## How can I contact the Nextflow Türkiye community?\n\nIf you want to help grow the Nextflow community in Türkiye, join the Nextflow and nf-core Slack workspaces and connect with Turkish contributors in the #region-turkiye channel. Don't be shy—say hello, and let's build up the community together! Feel free to contact me if you're interested in helping organize local hands-on Nextflow workshops. We welcome both advanced users and beginners. By participating, you'll contribute to the growth of bioinformatics in Türkiye, collaborate with peers, and access resources to advance your research and career.",
    "images": [
      "/img/blog-2024-06-12-turkish_workshop1a.png",
      "/img/blog-2024-06-12-turkish_workshop2a.png"
    ],
    "author": "Kübra Narcı",
    "tags": "nextflow,ambassador_post"
  },
  {
    "slug": "2024/empowering-bioinformatics-mentoring",
    "title": "Empowering Bioinformatics: Mentoring Across Continents with Nextflow",
    "date": "2024-04-25T00:00:00.000Z",
    "content": "In my journey with the nf-core Mentorship Program, I've mentored individuals from Malawi, Chile, and Brazil, guiding them through Nextflow and nf-core. Despite the distances, my mentees successfully adapted their workflows, contributing to the open-source community. Witnessing the transformative impact of mentorship firsthand, I'm encouraged to continue participating in future mentorship efforts and urge others to join this rewarding experience. But how did it all start?\n\n<!-- end-archive-description -->\n\nI’m [Robert Petit](https://www.robertpetit.com/), a bioinformatician at the [Wyoming Public Health Laboratory](https://health.wyo.gov/publichealth/lab/), in [Wyoming, USA](https://en.wikipedia.org/wiki/Wyoming). If you don’t know where that is, haha that’s fine, I’m pretty sure half the people in the US don’t know either! Wyoming is the 10th largest US state (253,000 km2), but the least populated with only about 580,000 people. It’s home to some very beautiful mountains and national parks, large animals including bears, wolves and the fastest land animal in the northern hemisphere, the Pronghorn. But it’s rural, can get cold (-10 C) and the high wind speeds (somedays average 50 kmph, with gusts 100+ kmph) only make it feel colder during the winter (sometimes feeling like -60 C to -40 C). You might be wondering:\n\nHow did some random person from Wyoming get involved in the nf-core Mentorship Program, and end up being the only mentor to have participated in all three rounds?\n\nI’ve been in the Nextflow world for over 7 years now (as of 2024), when I first converted a pipeline, [Staphopia](https://staphopia.github.io/) from Ruffus to Nextflow. Eventually, I would develop [Bactopia](https://bactopia.github.io/latest/), one of the leading and longest maintained (5 years now!) Nextflow pipelines for the analysis of Bacterial genomes. Through Bactopia, I’ve had the opportunity to help people all around the world get started using Nextflow and analyzing their own bacterial sequencing. It has also allowed me to make numerous contributions to nf-core, mostly through the nf-core/modules. So, when I heard about the opportunity to be a mentor in the nf-core’s Mentorship Program, I immediately applied.\n\nRound 1! To be honest, I didn’t know what to expect from the program. Only that I would help a mentee with whatever they needed related to Nextflow and nf-core. Then at the first meeting, I learned I would be working with Phil Ashton the Lead Bioinformatcian at Malawi Liverpool Wellcome Trust, in Blantyre, Malawi, and immediately sent him a “Yo!”. Phil and I had run into each other in the past because when it comes to bacterial genomics, the field is very small! Phil’s goal was to get Nextflow pipelines running on their infrastructure in Malawi to help with their public health response. We would end up using Bactopia as the model. But this mentorship wasn’t just about “running Bactopia”, for Phil it was important we built a basic understanding of how things are working on the back-end with Nextflow. In the end, Phil was able to get Nextflow, and Bactopia running, using Singularity, but also gain a better understanding of Nextflow by writing his own Nextflow code.\n\nRound 2! When Round 2 was announced, I didn’t hesitate to apply again as a mentor. This time, I would be paired up with Juan Ugalde, an Assistant Professor at Universidad Andres Bello in Santiago, Chile. I think Juan and I were both excited by this, as similar to Phil, Juan and I had run into each other (virtually) through MetaSub, a project to sequence samples taken from public transport systems across the globe. Like many during the COVID-19 pandemic, Juan was pulled into the response, during which he began looking into Nextflow for other viruses. In particular, hantavirus, a public health concern due to it being endemic in parts of Chile. Juan had developed a pipeline for hantavirus sequence analysis, and his goal was to convert it into Nextflow. Throughout this Juan got to learn about the nf-core community and Nextflow development, which he was successful at! As he was able to convert his pipeline into Nextflow and make it publicly available as [hantaflow](https://github.com/microbialds/hantaflow).\n\nRound 3! Well Round 3 almost didn’t happen for me, but I’m glad it did happen! At the first meeting, I learned I would be paired with Ícaro Maia Santos de Castro, at the time a PhD candidate at the University of São Paulo, in São Paulo, Brazil. We quickly learned we were both fans of One Piece, as Ícaro’s GitHub picture was Luffy from One Piece, haha and my background included a poster from One Piece. With Ícaro, we were starting with the basics of Nextflow (e.g. the nf-core training materials) with the goal of writing a Nextflow pipeline for his meta-transcriptomics dissertation work. We set the goal to develop his Nextflow pipeline, before an overseas move he had a few months away. He brought so many questions, his motivation never waned, and once he was asking questions about Channel Operators, I knew he was ready to write his pipeline. While writing his pipeline he learned about the nf-core/tools and also got to submit a new recipe to Bioconda, and modules to nf-core. By the end of the mentorship, Ícaro had succeeded in writing his pipeline in Nextflow and making it publicly available at [phiflow](https://github.com/icaromsc/nf-core-phiflow).\n\n<div style=\"margin-top: 2rem; margin-bottom: 2rem;\">\n    <img src=\"/img/blog-2024-04-25-mentorship-img1a.png\" alt=\"phiflow diagram\">\n\nMetromap of the [phiflow](https://github.com/icaromsc/nf-core-phiflow) workflow\n\n</div>\n\nThrough all three rounds, I had the opportunity to work with some incredible people! But the awesomeness didn’t end with my mentees. One thing that always stuck out to me was how motivated everyone was, both mentees and mentors. There was a sense of excitement and real progress was being made by every group. After the first round ended, I remember thinking to myself, “how could it get better?” Haha, well it did, and it continued to get better and better in Rounds 2 and 3. I think this is a great testament to the organizers at nf-core that put it all together, the mentors and mentees, and the community behind Nextflow and nf-core.\n\nFor the future mentees in mentorship opportunities! Please don’t let yourself stop you from applying. Whether it’s a time issue, or a fear of not having enough experience to be productive. In each round, we’ve had people from all over the world, starting from the ground with no experience, to some mentees in which I wondered if maybe they should have been a mentor (some mentees did end up being a mentor in the last round!). As a mentee, it is a great opportunity to work directly with a mentor dedicated to seeing you grow and build confidence when it comes to Nextflow and bioinformatics. In addition, you will be introduced to the incredible community that is behind Nextflow and nf-core. I think you will quickly learn there are so many people in this community that are willing to help!\n\nFor the future mentors! It’s always awesome to be able to help others learn, but sometimes the mentor needs to learn too! For me, I found the nf-core Mentorship Program to be a great opportunity to improve my skills as a mentor. But it wasn’t just from working with my mentees. During each round I was surrounded by many great role models in the form of mentors and mentees to learn from. No two groups ever had the same goals, so you really get the chance to see so many different styles of mentorship being implemented, all producing significant results for each mentee. Like I told the mentees, if the opportunity comes up again, take the chance and apply to be a mentor!\n\nThere have now been three rounds of the nf-core Mentorship Program, and I am very proud to have been a mentor in each round! During this I have learned so much and been able to help my mentees and the community grow. I look forward to seeing what the future holds for the mentorship opportunities in the Nextflow community, and I encourage potential mentors and mentees to consider joining the program!",
    "images": [
      "/img/blog-2024-04-25-mentorship-img1a.png"
    ],
    "author": "Robert Petit",
    "tags": "nextflow,nf-core,mentorship,ambassador_post"
  },
  {
    "slug": "2024/experimental-cleanup-with-nf-boost",
    "title": "Experimental cleanup with nf-boost",
    "date": "2024-08-08T00:00:00.000Z",
    "content": "### Backstory\n\nWhen I (Ben) was in grad school, I worked on a Nextflow pipeline called [GEMmaker](https://github.com/systemsgenetics/gemmaker), an RNA-seq analysis pipeline similar to [nf-core/rnaseq](https://github.com/nf-core/rnaseq). We quickly ran into a problem, which is that on large runs, we were running out of storage! As it turns out, it wasn’t the final outputs, but the intermediate outputs (the BAM files, etc) that were taking up so much space, and we figured that if we could just delete those intermediate files sooner, we might be able to make it through a pipeline run without running out of storage. We were far from alone.\n\n<!-- end-archive-description -->\n\nAutomatic cleanup is currently the [oldest open issue](https://github.com/nextflow-io/nextflow/issues/452) on the Nextflow repository. For many users, the ability to quickly delete intermediate files makes the difference between a run being possible or impossible. [Stephen Ficklin](https://github.com/spficklin), the creator of GEMmaker, came up with a clever way to delete intermediate files and even “trick” Nextflow into skipping deleted tasks on a resumed run, which you can read about in the GitHub issue. It involved wiring the intermediate output channels to a “cleanup” process, along with a “done” signal from the relevant downstream processes to ensure that the intermediates were deleted at the right time.\n\nThis hack worked, but it required a lot of manual effort to wire up the cleanup process correctly, and it left me wondering whether it could be done automatically. Nextflow should be able to analyze the DAG, figure out when an output file can be deleted, and then delete it! During my time on the Nextflow team, I have implemented this exact idea in a [pull request](https://github.com/nextflow-io/nextflow/pull/3849), but there are still a few challenges to resolve, such as resuming from deleted runs (which is not as impossible as it sounds).\n\n### Introducing nf-boost: experimental features for Nextflow\n\nMany users have told me that they would gladly take the cleanup without the resume, so I found a way to provide the cleanup functionality in a plugin, which I call [nf-boost](https://github.com/bentsherman/nf-boost). This plugin is not just about automatic cleanup – it contains a variety of experimental features, like new operators and functions, that anyone can try today with a few extra lines of config, which is much less tedious than building Nextflow from a pull request. Not every new feature can be implemented via plugin, but for those features that can, it’s nice for the community to be able to try it out before we make it official.\n\nThe nf-boost plugin requires Nextflow v23.10.0 or later. You can enable the experimental cleanup by adding the following lines to your config file:\n\n```groovy\nplugins {\n  id 'nf-boost'\n}\n\nboost {\n  cleanup = true\n}\n```\n\n### Automatic cleanup: how it works\n\nThe strategy of automatic cleanup is simple:\n\n1. As soon as an output file can be deleted, delete it\n2. An output file can be deleted when (1) all downstream tasks that use the output file as an input have completed AND (2) the output file has been published (if it needs to be published)\n\nIn practice, the conditions for 2(a) are tricky to get right because Nextflow doesn’t know the full task graph from the start (thanks to the flexibility of Nextflow’s dataflow operators). But you don’t have to worry about any of that because we already figured out how to make it work! All you have to do is flip a switch (`boost.cleanup = true`) and enjoy the ride.\n\n### Real-world example\n\nLet’s consider a variant calling pipeline following standard best practices. Sequencing reads are mapped onto the genome, producing a BAM file which will be marked for duplicates, filtered, recalibrated using GATK, etc. This means that, for a given sample, at least four copies of the BAM file will be stored in the work directory. In other words, for an initial paired-end whole-exome sequencing (WES) sample of 12 GB, the work directory will quickly grow to 50 GB just to store the BAM files for one sample, or 100 GB for a paired sample (e.g. germline and tumor).\n\nNow suppose that we want to analyze a cohort of 100 patients – that’s ~10 TB of intermediate data, which is a real problem. For some users, it means processing only a few samples at a time, even though they might have the compute capacity to do much more. For others, it means not being able to process even one sample, because the accumulated intermediate data is simply too large. With automatic cleanup, Nextflow should be able to delete the previous BAM as soon as the next BAM is produced, for each sample independently.\n\nWe tested this use-case with a paired WES sample (total input size of 26.8 GB), by tracking the work directory size for a run with and a run without automatic cleanup. The results are shown below.\n\n<img src=\"/img/blog-2024-08-08-nfboost-img1a.png\" alt=\"disk usage with and without nf-boost\" style=\"width: 2500px;\">\n\n_Note: we also changed the `boost.cleanupInterval` config option to 180 seconds, which was more optimal for our system._\n\nAs expected, we see that without automatic cleanup, the size of the work directory reaches 110 GB when all BAM files are produced and never deleted. On the other hand, when the nf-boost cleanup is enabled, the work directory occasionally peaks at ~50 GB (i.e. no more than two BAM files are stored at the same time), but always returns to ~25 GB, since the previous BAM is deleted immediately after the next BAM is ready. There is no impact on the size of the results (since they are identical) or the total runtime (since cleanup happens in parallel with the workflow itself).\n\nIn this case, automatic cleanup reduced the total storage by 50-75% (depending on how you measure the storage). In general, the effectiveness of automatic cleanup will depend greatly on how you write your pipeline. Here are a few rules of thumb that we’ve come up with so far:\n\n- As your pipeline becomes “deeper” (i.e. more processing steps in sequence), automatic cleanup becomes more effective, because it only needs to keep two steps’ worth of data, regardless of the total number of steps\n- As your pipeline becomes “wider” (i.e. more inputs being processed in parallel), automatic cleanup should have roughly the same level of effectiveness. If some samples take longer to process than others, the peak storage should be lower with automatic cleanup, since the “peaks” for each sample will happen at different times.\n- As you add more dependencies between processes, automatic cleanup becomes less effective, because it has to wait longer before it can delete the upstream outputs. Note that each output is tracked independently, so for example, sending logs to a summary process won’t affect the cleanup of other outputs from that same process.\n\n### Closing thoughts\n\nAutomatic cleanup in nf-boost is an experimental feature, and notably does not support resumability, meaning that the deleted files will simply be re-executed on a resumed run. While we work through these last few challenges, the nf-boost plugin is a nice option for users who want to benefit from what we’ve built so far and don’t need the resumability.\n\nThe nice thing about nf-boost’s automatic cleanup is that it is just a preview of what will eventually be the “official” cleanup feature in Nextflow (when it is merged), so by using nf-boost, you are helping the future of Nextflow directly! We hope that this experimental version will help users run workloads that were previously difficult or even impossible, and we look forward to when we can bring this feature home to Nextflow.",
    "images": [
      "/img/blog-2024-08-08-nfboost-img1a.png"
    ],
    "author": "Ben Sherman",
    "tags": "nextflow,ambassador_post"
  },
  {
    "slug": "2024/how_i_became_a_nextflow_ambassador",
    "title": "How I became a Nextflow Ambassador!",
    "date": "2024-07-24T00:00:00.000Z",
    "content": "As a PhD student in bioinformatics, I aimed to build robust pipelines to analyze diverse datasets throughout my research. Initially, mastering Bash scripting was a time-consuming challenge, but this journey ultimately led me to become a Nextflow Ambassador, engaging actively with the expert Nextflow community.\n\n<!-- end-archive-description -->\n\nMy name is [Firas Zemzem](https://www.linkedin.com/in/firaszemzem/), a PhD student based in [Tunisia](https://www.google.com/search?q=things+to+do+in+tunisia&amp;sca_esv=3b07b09e3325eaa7&amp;sca_upv=1&amp;udm=15&amp;biw=1850&amp;bih=932&amp;ei=AS2eZuqnFpG-i-gPwciJyAk&amp;ved=0ahUKEwiqrOiRsbqHAxUR3wIHHUFkApkQ4dUDCBA&amp;uact=5&amp;oq=things+to+do+in+tunisia&amp;gs_lp=Egxnd3Mtd2l6LXNlcnAiF3RoaW5ncyB0byBkbyBpbiB0dW5pc2lhMgUQABiABDIGEAAYFhgeMgYQABgWGB4yBhAAGBYYHjIGEAAYFhgeMgYQABgWGB4yBhAAGBYYHjIGEAAYFhgeMgYQABgWGB4yCBAAGBYYHhgPSOIGULYDWNwEcAF4AZABAJgBfaAB9gGqAQMwLjK4AQPIAQD4AQGYAgOgAoYCwgIKEAAYsAMY1gQYR5gDAIgGAZAGCJIHAzEuMqAH_Aw&amp;sclient=gws-wiz-serp) working with the Laboratory of Cytogenetics, Molecular Genetics, and Biology of Reproduction at CHU Farhat Hached Sousse. I was specialized in human genetics, focusing on studying genomics behind neurodevelopmental disorders. Hence Developing methods for detecting SNPs and variants related to my work was crucial step for advancing medical research and improving patient outcomes. On the other hand, pipelines integration and bioinformatics tools were essential in this process, enabling efficient data analysis, accurate variant detection, and streamlined workflows that enhance the reliability and reproducibility of our findings.\n\n## The initial nightmare of Bash\n\nDuring my master's degree, I was a steadfast user of Bash scripting. Bash had been my go-to tool for automating tasks and managing workflows in my bioinformatics projects, such as variant calling. Its simplicity and versatility made it an indispensable part of my toolkit. I was writing Bash scripts for various next-generation sequencing (NGS) high-throughput analyses, including data preprocessing, quality control, alignment, and variant calling. However, as my projects grew more complex, I began to encounter the limitations of Bash. Managing dependencies, handling parallel executions, and ensuring reproducibility became increasingly challenging. Handling the vast amount of data generated by NGS and other high-throughput technologies was cumbersome. Using Bash became a nightmare for debugging and maintaining. I spent countless hours trying to make it work, only to be met with more errors and inefficiencies. It was nearly impossible to scale for larger datasets and more complex analyses. Additionally, managing different environments and versions of tools was beyond Bash's capabilities. I needed a solution that could handle these challenges more gracefully.\n\n## Game-Changing Call\n\nOne evening, I received a call from my friend, Mr. HERO, a bioinformatician. As we discussed our latest projects, I vented my frustrations with Bash. Mr. HERO, as I called him, the problem-solver, mentioned a tool called Nextflow. He described how it had revolutionized his workflow, making complex pipeline management a breeze. Intrigued, I decided to look into it.\n\n## Diving Into the process\n\nReading the [documentation](https://www.nextflow.io/docs/latest/index.html) and watching [tutorials](https://training.nextflow.io/) were my first steps. Nextflow's approach to workflow management was a revelation. Unlike Bash, Nextflow was designed to address the complexities of modern computational questions. It provided a transparent, declarative syntax for defining tasks and their dependencies and supported parallel execution out of the box. The first thing I did when I decided to convert one of my existing Bash scripts into a Nextflow pipeline was to start experimenting with simple code. Doing this was no small feat. I had to rethink my approach to workflow design and embrace a new way of defining tasks and dependencies. My learning curve was not too steep, so understanding how to translate my Bash logic into Nextflow's domain-specific language (DSL) was not that hard.\n\n## Eureka Moment: First run\n\nThe first time I ran my Nextflow pipeline, I was amazed by how smoothly and efficiently it handled tasks that previously took hours to debug and execute in Bash. Nextflow managed task dependencies, parallel execution, and error handling with ease, resulting in a faster, more reliable, and maintainable pipeline. The ability to run pipelines on different computing environments, from local machines to high-performance clusters and cloud platforms, was a game-changer. Several Nextflow features were particularly valuable: Containerization Support using Docker and Singularity ensured consistency across environments; Error Handling with automatic retry mechanisms and detailed error reporting saved countless debugging hours; Portability and scalability allowed seamless execution on various platforms; Modularity facilitated the reuse and combination of processes across different pipelines, enhancing efficiency and organization; and Reproducibility features, including versioning and traceability, ensured that workflows could be reliably reproduced and shared across different research projects and teams.\n\n<div style=\"margin-top: 2rem; margin-bottom: 2rem;\">\n    <img src=\"/img/ZemFiras-nextflowtestpipeline-Blog.png\" alt=\"meme on bright landscape\">\n</div>\n\n## New Horizons: Becoming a Nextflow Ambassador\n\nSwitching from Bash scripting to Nextflow was more than just adopting a new tool. It was about embracing a new mindset. Nextflow’s emphasis on scalability, reproducibility, and ease of use transformed how I approached bioinformatics. The initial effort to learn Nextflow paid off in spades, leading to more robust, maintainable, and scalable workflows. My enthusiasm and advocacy for Nextflow didn't go unnoticed. Recently, I became a Nextflow Ambassador. This role allows me to further contribute to the community, promote best practices, and support new users as they embark on their own Nextflow journeys.\n\n## Future Projects and Community Engagement\n\nCurrently I am working on developing a Nextflow pipeline with my team that will help in analyzing variants, providing valuable insights for medical and clinical applications. This pipeline aims to improve the accuracy and efficiency of variant detection, ultimately supporting better diagnostic for patients with various genetic conditions. As part of my ongoing efforts within the Nextflow community, I am planning a series of projects aimed at developing and sharing advanced Nextflow pipelines tailored to specific genetic rare disorder analyses. These initiative will include detailed tutorials, case studies, and collaborative efforts with other researchers to enhance the accessibility and utility of Nextflow for various bioinformatics applications. Additionally, I plan to host workshops and seminars to spread knowledge and best practices among my colleagues and other researchers. This will help foster a collaborative environment where we can all benefit from the power and flexibility of Nextflow.\n\n## Invitation for researchers over the world\n\nAs a Nextflow Ambassador, I invite you to become part of a dynamic group of experts and enthusiasts dedicated to advancing workflow automation. Whether you're just starting or looking to deepen your knowledge, our community offers invaluable resources, support, and networking opportunities. You can chat with us on the [Nextflow Slack Workspace](https://www.nextflow.io/slack-invite.html) and ask your questions at the [Seqera Community Forum](https://community.seqera.io).",
    "images": [
      "/img/ZemFiras-nextflowtestpipeline-Blog.png"
    ],
    "author": "Firas Zemzem",
    "tags": "nextflow,ambassador_post"
  },
  {
    "slug": "2024/nextflow-24.04-highlights",
    "title": "Nextflow 24.04 - Release highlights",
    "date": "2024-05-27T00:00:00.000Z",
    "content": "We release an \"edge\" version of Nextflow every month and a \"stable\" version every six months. The stable releases are recommended for production usage and represent a significant milestone. The [release changelogs](https://github.com/nextflow-io/nextflow/releases) contain a lot of detail, so we thought we'd highlight some of the goodies that have just been released in Nextflow 24.04 stable. Let's get into it!\n\n:::tip\nWe also did a podcast episode about some of these changes!\nCheck it out here: [Channels Episode 41](/podcast/2024/ep41_nextflow_2404.html).\n:::\n\n## Table of contents\n\n- [New features](#new-features)\n  - [Seqera Containers](#seqera-containers)\n  - [Workflow output definition](#workflow-output-definition)\n  - [Topic channels](#topic-channels)\n  - [Process eval outputs](#process-eval-outputs)\n  - [Resource limits](#resource-limits)\n  - [Job arrays](#job-arrays)\n- [Enhancements](#enhancements)\n  - [Colored logs](#colored-logs)\n  - [AWS Fargate support](#aws-fargate-support)\n  - [OCI auto pull mode for Singularity and Apptainer](#oci-auto-pull-mode-for-singularity-and-apptainer)\n  - [Support for GA4GH TES](#support-for-ga4gh-tes)\n- [Fusion](#fusion)\n  - [Enhanced Garbage Collection](#enhanced-garbage-collection)\n  - [Increased File Handling Capacity](#increased-file-handling-capacity)\n  - [Correct Publishing of Symbolic Links](#correct-publishing-of-symbolic-links)\n- [Other notable changes](#other-notable-changes)\n\n## New features\n\n### Seqera Containers\n\nA new flagship community offering was revealed at the Nextflow Summit 2024 Boston - **Seqera Containers**. This is a free-to-use container cache powered by [Wave](https://seqera.io/wave/), allowing anyone to request an image with a combination of packages from Conda and PyPI. The image will be built on demand and cached (for at least 5 years after creation). There is a [dedicated blog post](https://seqera.io/blog/introducing-seqera-pipelines-containers/) about this, but it's worth noting that the service can be used directly from Nextflow and not only through [https://seqera.io/containers/](https://seqera.io/containers/)\n\nIn order to use Seqera Containers in Nextflow, simply set `wave.freeze` _without_ setting `wave.build.repository` - for example, by using the following config for your pipeline:\n\n```groovy\nwave.enabled = true\nwave.freeze = true\nwave.strategy = 'conda'\n```\n\nAny processes in your pipeline specifying Conda packages will have Docker or Singularity images created on the fly (depending on whether `singularity.enabled` is set or not) and cached for immediate access in subsequent runs. These images will be publicly available. You can view all container image names with the `nextflow inspect` command.\n\n### Workflow output definition\n\nThe workflow output definition is a new syntax for defining workflow outputs:\n\n```groovy\nnextflow.preview.output = true // [!code ++]\n\nworkflow {\n  main:\n  ch_foo = foo(data)\n  bar(ch_foo)\n\n  publish:\n  ch_foo &gt;&gt; 'foo' // [!code ++]\n}\n\noutput { // [!code ++]\n  directory 'results' // [!code ++]\n  mode 'copy' // [!code ++]\n} // [!code ++]\n```\n\nIt essentially provides a DSL2-style approach for publishing, and will replace `publishDir` once it is finalized. It also provides extra flexibility as it allows you to publish _any_ channel, not just process outputs. See the [Nextflow docs](https://nextflow.io/docs/latest/workflow.html#publishing-outputs) for more information.\n\n:::info\nThis feature is still in preview and may change in a future release.\nWe hope to finalize it in version 24.10, so don't hesitate to share any feedback with us!\n:::\n\n### Topic channels\n\nTopic channels are a new channel type introduced in 23.11.0-edge. A topic channel is essentially a queue channel that can receive values from multiple sources, using a matching name or \"topic\":\n\n```groovy\nprocess foo {\n  output:\n  val('foo'), topic: 'my-topic' // [!code ++]\n}\n\nprocess bar {\n  output:\n  val('bar'), topic: 'my-topic' // [!code ++]\n}\n\nworkflow {\n  foo()\n  bar()\n\n  Channel.topic('my-topic').view() // [!code ++]\n}\n```\n\nTopic channels are particularly useful for collecting metadata from various places in the pipeline, without needing to write all of the channel logic that is normally required (e.g. using the `mix` operator). See the [Nextflow docs](https://nextflow.io/docs/latest/channel.html#topic) for more information.\n\n### Process `eval` outputs\n\nProcess `eval` outputs are a new type of process output which allows you to capture the standard output of an arbitrary shell command:\n\n```groovy\nprocess sayHello {\n  output:\n  eval('bash --version') // [!code ++]\n\n  \"\"\"\n  echo Hello world!\n  \"\"\"\n}\n\nworkflow {\n  sayHello | view\n}\n```\n\nThe shell command is executed alongside the task script. Until now, you would typically execute these supplementary commands in the main process script, save the output to a file or environment variable, and then capture it using a `path` or `env` output. The new `eval` output is a much more convenient way to capture this kind of command output directly. See the [Nextflow docs](https://nextflow.io/docs/latest/process.html#output-type-eval) for more information.\n\n#### Collecting software versions\n\nTogether, topic channels and eval outputs can be used to simplify the collection of software tool versions. For example, for FastQC:\n\n```groovy\nprocess FASTQC {\n  input:\n  tuple val(meta), path(reads)\n\n  output:\n  tuple val(meta), path('*.html'), emit: html\n  tuple val(\"${task.process}\"), val('fastqc'), eval('fastqc --version'), topic: versions // [!code ++]\n\n  \"\"\"\n  fastqc $reads\n  \"\"\"\n}\n\nworkflow {\n  Channel.topic('versions') // [!code ++]\n    | unique()\n    | map { process, name, version -&gt;\n      \"\"\"\\\n      ${process.tokenize(':').last()}:\n        ${name}: ${version}\n      \"\"\".stripIndent()\n    }\n    | collectFile(name: 'collated_versions.yml')\n    | CUSTOM_DUMPSOFTWAREVERSIONS\n}\n```\n\nThis approach will be implemented across all nf-core pipelines, and will cut down on a lot of boilerplate code. Check out the full prototypes for nf-core/rnaseq [here](https://github.com/nf-core/rnaseq/pull/1109) and [here](https://github.com/nf-core/rnaseq/pull/1115) to see them in action!\n\n### Resource limits\n\nThe **resourceLimits** directive is a new process directive which allows you to define global limits on the resources requested by individual tasks. For example, if you know that the largest node in your compute environment has 24 CPUs, 768 GB or memory, and a maximum walltime of 72 hours, you might specify the following:\n\n```groovy\nprocess.resourceLimits = [ cpus: 24, memory: 768.GB, time: 72.h ]\n```\n\nIf a task requests more than the specified limit (e.g. due to [retry with dynamic resources](https://nextflow.io/docs/latest/process.html#dynamic-computing-resources)), Nextflow will automatically reduce the task resources to satisfy the limit, whereas normally the task would be rejected by the scheduler or would simply wait in the queue forever! The nf-core community has maintained a custom workaround for this problem, the `check_max()` function, which can now be replaced with `resourceLimits`. See the [Nextflow docs](https://nextflow.io/docs/latest/process.html#resourcelimits) for more information.\n\n### Job arrays\n\n**Job arrays** are now supported in Nextflow using the `array` directive. Most HPC schedulers, and even some cloud batch services including AWS Batch and Google Batch, support a \"job array\" which allows you to submit many independent jobs with a single job script. While the individual jobs are still executed separately as normal, submitting jobs as arrays where possible puts considerably less stress on the scheduler.\n\nWith Nextflow, using job arrays is a one-liner:\n\n```groovy\nprocess.array = 100\n```\n\nYou can also enable job arrays for individual processes like any other directive. See the [Nextflow docs](https://nextflow.io/docs/latest/process.html#array) for more information.\n\n:::tip\nOn Google Batch, using job arrays also allows you to pack multiple tasks onto the same VM by using the `machineType` directive in conjunction with the `cpus` and `memory` directives.\n:::\n\n## Enhancements\n\n### Colored logs\n\n<div class=\"row\"><div class=\"col-lg-6\">\n\n**Colored logs** have come to Nextflow! Specifically, the process log which is continuously printed to the terminal while the pipeline is running. Not only is it more colorful, but it also makes better use of the available space to show you what's most important. But we already wrote an entire [blog post](https://nextflow.io/blog/2024/nextflow-colored-logs.html) about it, so go check that out for more details!\n\n</div><div class=\"col-lg-6\">\n\n![New coloured output from Nextflow](/img/blog-nextflow-colored-logs/nextflow_coloured_logs.png)\n\n</div></div>\n\n### AWS Fargate support\n\nNextflow now supports **AWS Fargate** for AWS Batch jobs. See the [Nextflow docs](https://nextflow.io/docs/latest/aws.html#aws-fargate) for details.\n\n### OCI auto pull mode for Singularity and Apptainer\n\nNextflow now supports OCI auto pull mode both Singularity and Apptainer. Historically, Singularity could run a Docker container image converting to the Singularity image file format via the Singularity pull command and using the resulting image file in the exec command. This adds extra overhead to the head node running Nextflow for converting all container images to the Singularity format.\n\nNow Nextflow allows specifying the option `ociAutoPull` both for Singularity and Apptainer. When enabling this setting Nextflow delegates the pull and conversion of the Docker image directly to the `exec` command.\n\n```groovy\nsingularity.ociAutoPull = true\n```\n\nThis results in the running of the pull and caching of the Singularity images to the compute jobs instead of the head job and removing the need to maintain a separate image files cache.\n\nSee the [Nextflow docs](https://nextflow.io/docs/latest/config.html#scope-singularity) for more information.\n\n### Support for GA4GH TES\n\nThe [Task Execution Service (TES)](https://ga4gh.github.io/task-execution-schemas/docs/) is an API specification, developed by [GA4GH](https://www.ga4gh.org/), which attempts to provide a standard way for workflow managers like Nextflow to interface with execution backends. Two noteworthy TES implementations are [Funnel](https://github.com/ohsu-comp-bio/funnel) and [TES Azure](https://github.com/microsoft/ga4gh-tes).\n\nNextflow has long supported TES as an executor, but only in a limited sense, as TES did not support some important capabilities in Nextflow such as glob and directory outputs and the `bin` directory. However, with TES 1.1 and its adoption into Nextflow, these gaps have been closed. You can use the TES executor with the following configuration:\n\n```groovy\nplugins {\n  id 'nf-ga4gh'\n}\n\nprocess.executor = 'tes'\ntes.endpoint = '...'\n```\n\nSee the [Nextflow docs](https://nextflow.io/docs/latest/executor.html#ga4gh-tes) for more information.\n\n:::note\nTo better facilitate community contributions, the nf-ga4gh plugin will soon be moved from the Nextflow repository into its own repository, `nextflow-io/nf-ga4gh`. To ensure a smooth transition with your pipelines, make sure to explicitly include the plugin in your configuration as shown above.\n:::\n\n## Fusion\n\n[Fusion](https://seqera.io/fusion/) is a distributed virtual file system for cloud-native data pipeline and optimized for Nextflow workloads. Nextflow 24.04 now works with a new release, Fusion 2.3. This brings a few notable quality-of-life improvements:\n\n### Enhanced Garbage Collection\n\nFusion 2.3 features an improved garbage collection system, enabling it to operate effectively with reduced scratch storage. This enhancement ensures that your pipelines run more efficiently, even with limited temporary storage.\n\n### Increased File Handling Capacity\n\nSupport for more concurrently open files is another significant improvement in Fusion 2.3. This means that larger directories, such as those used by Alphafold2, can now be utilized without issues, facilitating the handling of extensive datasets.\n\n### Correct Publishing of Symbolic Links\n\nIn previous versions, output files that were symbolic links were not published correctly — instead of the actual file, a text file containing the file path was published. Fusion 2.3 addresses this issue, ensuring that symbolic links are published correctly.\n\nThese enhancements in Fusion 2.3 contribute to a more robust and efficient filesystem for Nextflow users.\n\n## Other notable changes\n\n- Add native retry on spot termination for Google Batch ([`ea1c1b`](https://github.com/nextflow-io/nextflow/commit/ea1c1b70da7a9b8c90de445b8aee1ee7a7148c9b))\n- Add support for instance templates in Google Batch ([`df7ed2`](https://github.com/nextflow-io/nextflow/commit/df7ed294520ad2bfc9ad091114ae347c1e26ae96))\n- Allow secrets to be used with `includeConfig` ([`00c9f2`](https://github.com/nextflow-io/nextflow/commit/00c9f226b201c964f67d520d0404342bc33cf61d))\n- Allow secrets to be used in the pipeline script ([`df866a`](https://github.com/nextflow-io/nextflow/commit/df866a243256d5018e23b6c3237fb06d1c5a4b27))\n- Add retry strategy for publishing ([`c9c703`](https://github.com/nextflow-io/nextflow/commit/c9c7032c2e34132cf721ffabfea09d893adf3761))\n- Add `k8s.cpuLimits` config option ([`3c6e96`](https://github.com/nextflow-io/nextflow/commit/3c6e96d07c9a4fa947cf788a927699314d5e5ec7))\n- Removed `seqera` and `defaults` from the standard channels used by the nf-wave plugin. ([`ec5ebd`](https://github.com/nextflow-io/nextflow/commit/ec5ebd0bc96e986415e7bac195928b90062ed062))\n\nYou can view the full [Nextflow release notes on GitHub](https://github.com/nextflow-io/nextflow/releases/tag/v24.04.0).",
    "images": [],
    "author": "Paolo Di Tommaso",
    "tags": "nextflow"
  },
  {
    "slug": "2024/nextflow-colored-logs",
    "title": "Nextflow's colorful new console output",
    "date": "2024-03-28T00:00:00.000Z",
    "content": "Nextflow is a command-line interface (CLI) tool that runs in the terminal. Everyone who has launched Nextflow from the command line knows what it’s like to follow the console output as a pipeline runs: the excitement of watching jobs zipping off as they’re submitted, the satisfaction of the phrase _\"Pipeline completed successfully!\"_ and occasionally, the sinking feeling of seeing an error message.\n\nBecause the CLI is the primary way that people interact with Nextflow, a little bit of polish can have a big effect. In this article, I’m excited to describe an upgrade for the console output that should make monitoring workflow progress just a little easier.\n\nThe new functionality is available in `24.02-0-edge` and will be included in the next `24.04.0` stable release. You can try it out now by updating Nextflow as follows:\n\n```bash\nNXF_EDGE=1 nextflow self-update\n```\n\n## Background\n\nThe Nextflow console output hasn’t changed much over the 10 years that it’s been around. The biggest update happened in 2018 when \"ANSI logging\" was released in version `18.10.0`. This replaced the stream of log messages announcing each task submission with a view that updates dynamically, giving an overview of each process. This gives an overview of the pipeline’s progress rather than being swamped with thousands of individual task submissions.\n\n<figure>\n  <img src=\"/img/blog-nextflow-colored-logs/nextflow_log_with_without_ansi.png\" alt=\"Nextflow console output with and without ANSI logging\">\n  <figcaption>\n\nANSI console output. Nextflow log output from running the nf-core/rnaseq pipeline before (Left) and after (Right) enabling ANSI logging.\n\n  </figcaption>\n</figure>\n\nI can be a little obsessive about tool user interfaces. The nf-core template, as well as MultiQC and nf-core/tools all have coloured terminal output, mostly using the excellent [textualize/rich](https://github.com/Textualize/rich). I’ve also written a couple of general-use tools around this such as [ewels/rich-click](https://github.com/ewels/rich-click/) for Python CLI help texts, and [ewels/rich-codex](https://github.com/ewels/rich-codex) to auto-generate screenshots from code / commands in markdown. The problem with being surrounded by so much colored CLI output is that any tools _without_ colors start to stand out. Dropping hints to the Nextflow team didn’t work, so eventually I whipped up [a proposal](https://github.com/nextflow-io/nextflow/issues/3976) of what the console output could look like using the tools I knew: Python and Rich. Paolo knows me well and [offered up a bait](https://github.com/nextflow-io/nextflow/issues/3976#issuecomment-1568071479) that I couldn’t resist: _\"Phil. I think this a great opportunity to improve your Groovy skills 😆\"._\n\n## Showing what’s important\n\nThe console output shown by Nextflow describes a range of information. Much of it aligns in vertical columns, but not all. There’s also a variety of fields, some of which are more important than others to see at a glance.\n\n<figure>\n  <img src=\"/img/blog-nextflow-colored-logs/nextflow_coloured_logs.png\" alt=\"New coloured output from Nextflow\">\n  <figcaption>\n\nIntroducing: colored console output. Output from running nf-core/rnaseq with the new colors applied (nf-core header removed for clarity).\n\n  </figcaption>\n</figure>\n\nWith some judicious use of the `dim` style, we can make less important information fade into the background. For example, the \"stem\" of the fully qualified process identifiers now step back to allow the process name to stand out. Secondary information such as the number of tasks that were cached, or the executor that is being submitted to, are still there to see but take a back seat. Doing the reverse with some `bold` text helps to highlight the run name – key information for identifying and resuming pipeline runs. Using color allows different fields to be easily distinguished, such as process labels and task hashes. Greens, blues, and reds in the task statuses allow a reader to get an impression of the run progress without needing to read every number.\n\nProbably the most difficult aspect technically was the `NEXTFLOW` header line. I knew I wanted to use the _\"Nextflow Green\"_ here, or as close to it as possible. But colors in the terminal are tricky. What the ANSI standard defines as `green`, `black`, and `blue` can vary significantly across different systems and terminal themes. Some people use a light color scheme and others run in dark mode. This hadn’t mattered much for most of the colors up until this point - I could use the [Jansi](https://github.com/fusesource/jansi) library to use named colors and they should look ok. But for the specific RGB of the _\"Nextflow Green\"_ I had to [hardcode specific ANSI control characters](https://github.com/nextflow-io/nextflow/blob/c9c7032c2e34132cf721ffabfea09d893adf3761/modules/nextflow/src/main/groovy/nextflow/cli/CmdRun.groovy#L379-L389). But it got worse - it turns out that the default Terminal app that ships with macOS only supports 256 colors, so I had to find the closest match (_\"light sea green\"_ if you’re curious). Even once the green was ok, using `black` as the text color meant that it would actually render as white with some terminal color themes and be unreadable. In the end, the header text is a very dark gray.\n\n<figure>\n  <img src=\"/img/blog-nextflow-colored-logs/testing_terminal_themes.png\" alt=\"Testing many horrible terminal themes\">\n  <figcaption>\n\nTesting color rendering across a wide range of themes in the OS X Terminal app.\n\n  </figcaption>\n</figure>\n\n## More than just colors\n\nWhilst the original intent was focused on using color, it didn’t take long to come up with a shortlist of other niggles that I wanted to fix. I took this project as an opportunity to address a few of these, specifically:\n\n- Make the most of the available width in the terminal:\n  - Redundant text is now cut down when the screen is narrow. Specifically the repeated `process &gt;` text, plus other small gains such as replacing the three `...` characters with a single `…` character. The percentage-complete is removed if the window is really narrow. These changes happen dynamically every time the screen refreshes, so should update if you resize the terminal window.\n- Be more selective about which part of process names are truncated:\n  - There’s only so much width that can be saved, and fully qualified process names are long. The current Nextflow console output truncates the end of the identifier if there’s no space, but this is the part that varies most between pipeline steps. Instead, we can truncate the start and preserve the process name and label.\n- Don’t show all pending processes without tasks:\n  - The existing ANSI logging shows _all_ processes in the pipeline, even those that haven’t had any tasks submitted. If a pipeline has a lot of processes this can push the running processes out of view.\n  - Nextflow now tracks the number of available rows in the terminal and hides pending processes once we run out of space. Running processes are always printed.\n\nThe end result is console output that makes the most of the available space in your terminal window:\n\n<figure>\n  <img src=\"/img/blog-nextflow-colored-logs/nextflow_console_varying_widths.png\" alt=\"Nextflow console output at different terminal window widths\">\n  <figcaption>\n\nProgress of the nf-core/rnaseq shown across 3 different terminal-width breakpoints, with varying levels of text truncation.\n\n  </figcaption>\n</figure>\n\n## Contributing to Nextflow\n\nDespite building tools that use Nextflow for many years, I’ve spent relatively little time venturing into the main codebase myself. Just as with any contributor, part of the challenge was figuring out how to build Nextflow, how to navigate its code structure and how to write tests. I found it quite a fun experience, so I described and demoed the process in a recent nf-core Bytesize talk titled \"[Contributing to Nextflow](https://nf-co.re/events/2024/bytesize_nextflow_dev)\". You can watch the talk on [YouTube](https://www.youtube.com/watch?v=R0fqk5OS-nw), where I explain the mechanics of forking Nextflow, enhancing, compiling, and testing changes locally, and contributing enhancements back to the main code base.\n\n<div class=\"text-center\" style=\"margin: 1em 0 2em;\">\n  <iframe style=\"max-width:100%;\" width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/R0fqk5OS-nw?si=vBVE9IM8hseN3FSC&amp;start=84\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen=\"\"></iframe>\n</div>\n\n## But wait, there’s more!\n\nI’m happy with how the new console output looks, and it seems to have been well received so far. But once the warm glow of the newly merged pull request started to subside, I realized there was more to do. The console output is great for monitoring a running pipeline, but I spend most of my time these days digging through much more verbose `.nextflow.log` files. Suddenly it seemed a little unfair that these didn’t also benefit from a similar treatment.\n\nThis project was a little different because the logs are just files on the disk, meaning that I could approach the problem with whatever code stack I liked. Coincidentally, [Will McGugan](https://github.com/willmcgugan) (author of [textualize/rich](https://github.com/Textualize/rich)) was recently [writing about](https://textual.textualize.io/blog/2024/02/11/file-magic-with-the-python-standard-library/) a side project of his own: [Toolong](https://github.com/textualize/toolong). This is a terminal app built using [Textual](https://www.textualize.io/) which is specifically aimed at viewing large log files. I took it for a spin and it did a great job with Nextflow log files right out of the box, but I figured that I could take it further. At its core, Toolong uses the [Rich](https://github.com/textualize/rich) library to format text and so with a little hacking, I was able to introduce a handful of custom formatters for the Nextflow logs. And voilà, we have colored console output for log files too!\n\n<figure>\n  <img src=\"/img/blog-nextflow-colored-logs/nextflow_logs_side_by_side.png\" alt=\"Formatting .nextflow.log files with Toolong\">\n  <figcaption>\n\nThe tail end of a `.nextflow.log` file, rendered with `less` (Left) and Toolong (Right). Try finding the warning log message in both!\n\n  </figcaption>\n</figure>\n\nBy using Toolong as a viewer we get much more than just syntax highlighting too - it provides powerful file navigation and search functionality. It also supports tailing files in real time, so you can launch a pipeline in one window and tail the log in another to have the best of both worlds!\n\n<figure>\n  <video controls=\"\">\n    <source src=\"/img/blog-nextflow-colored-logs/nextflow_logs_best_both_worlds.mp4\" type=\"video/mp4\">\n    Your browser does not support the video tag.\n  </video>\n  <figcaption>\n\nRunning nf-core/rnaseq with the new Nextflow coloured console output (Left) whilst simultaneously tailing the `.nextflow.log` file using `nf-core log` (Right).\n\n  </figcaption>\n</figure>\n\nThis work with Toolong is still in two [open](https://github.com/Textualize/toolong/pull/47) [pull requests](https://github.com/nf-core/tools/pull/2895) as I write this, but hopefully you’ll soon be able to use the `nf-core log` command in a directory where you’ve run Nextflow, and it’ll launch Toolong with any log files it finds.",
    "images": [
      "/img/blog-nextflow-colored-logs/nextflow_log_with_without_ansi.png",
      "/img/blog-nextflow-colored-logs/nextflow_coloured_logs.png",
      "/img/blog-nextflow-colored-logs/testing_terminal_themes.png",
      "/img/blog-nextflow-colored-logs/nextflow_console_varying_widths.png",
      "/img/blog-nextflow-colored-logs/nextflow_logs_side_by_side.png"
    ],
    "author": "Phil Ewels",
    "tags": "nextflow"
  },
  {
    "slug": "2024/nextflow-nf-core-ancient-env-dna",
    "title": "Application of Nextflow and nf-core to ancient environmental eDNA",
    "date": "2024-04-17T00:00:00.000Z",
    "content": "Ancient environmental DNA (eDNA) is currently a hot topic in archaeological, ecological, and metagenomic research fields. Recent eDNA studies have shown that authentic ‘ancient’ DNA can be recovered from soil and sediments even as far back as 2 million years ago(1). However, as with most things metagenomics (the simultaneous analysis of the entire DNA content of a sample), there is a need to work at scale, processing the large datasets of many sequencing libraries to ‘fish’ out the tiny amounts of temporally degraded ancient DNA from amongst a huge swamp of contaminating modern biomolecules.\n\n<!-- end-archive-description -->\n\nThis need to work at scale, while also conducting reproducible analyses to demonstrate the authenticity of ancient DNA, lends itself to the processing of DNA with high-quality pipelines and open source workflow managers such as Nextflow. In this context, I was invited to the Australian Center for Ancient DNA (ACAD) at the University of Adelaide in February 2024 to co-teach a graduate-level course on ‘Hands-on bioinformatics for ancient environmental DNA’, alongside other members of the ancient eDNA community. Workshop participants included PhD students from across Australia, New Zealand, and even from as far away as Estonia.\n\n<div style=\"margin-top: 2rem; margin-bottom: 2rem;\">\n    <img src=\"/img/blog-2024-04-17-img1a.jpg\" alt=\"Mentor compliment about new module added\">\n    © Photo: Peter Mundy and Australian Center for Ancient DNA\n</div>\n\nWe began the five-day workshop with an overview of the benefits of using workflow managers and pipelines in academic research, which include efficiency, portability, reproducibility, and fault-tolerance, and we then proceeded to introduce the Ph.D. students to installing Nextflow, and configure pipelines for running on different types of computing infrastructure.\n\n<div style=\"margin-top: 2rem; margin-bottom: 2rem;\">\n    <img src=\"/img/blog-2024-04-17-img1b.jpg\" alt=\"Review comment in GitHub\">\n    © Photo: Peter Mundy and Australian Center for Ancient DNA\n</div>\n\nOver the next two days, I then introduced two well-established nf-core pipelines: [nf-core/eager](https://nf-co.re/eager) (2) and [nf-core/mag](https://nf-co.re/mag) (3), and explained to students how these pipelines can be applied to various aspects of environmental metagenomic and ancient DNA analysis:\nnf-core/eager is a dedicated ‘swiss-army-knife’ style pipeline for ancient DNA analysis that performs genetic data preprocessing, genomic alignment, variant calling, and metagenomic screening with specific tools and parameters to account for the characteristics of degraded DNA.\nnf-core/mag is a best-practice pipeline for metagenomic de novo assembly of microbial genomes that performs preprocessing, assembly, binning, bin-refinement and validation. It also contains a specific subworkflow for the authentication of ancient contigs.\nIn both cases, the students of the workshops were given practical tasks to set up and run both pipelines on real data, and time was spent exploring the extensive nf-core documentation and evaluating the outputs from MultiQC, both important components that contribute to the quality of nf-core pipelines.\n\nThe workshop was well received by students, and many were eager (pun intended) to start running Nextflow and nf-core pipelines on their own data at their own institutions.\n\nI would like to thank Vilma Pérez at ACAD for the invitation to contribute to the workshop as well as Mikkel Winther Pedersen for being my co-instructor, and the nf-core community for continued support in the development of the pipelines. Thank you also to Tina Warinner for proof-reading this blog post, and I would like to acknowledge [ACAD](https://www.adelaide.edu.au/acad/), the [University of Adelaide Environment Institute](https://www.adelaide.edu.au/environment/), the [Werner Siemens-Stiftung](https://www.wernersiemens-stiftung.ch/), [Leibniz HKI](https://www.leibniz-hki.de/), and [MPI for Evolutionary Anthropology](https://www.eva.mpg.de) for financial support to attend the workshop and support in developing nf-core pipelines.\n\n---\n\n(1) Kjær, K.H., Winther Pedersen, M., De Sanctis, B. et al. A 2-million-year-old ecosystem in Greenland uncovered by environmental DNA. Nature **612**, 283–291 (2022). [https://doi.org/10.1038/s41586-022-05453-y](https://doi.org/10.1038/s41586-022-05453-y)\n\n(2) Fellows Yates, J.A., Lamnidis, T.C., Borry, M., Andrades Valtueña, A., Fagernäs, Z., Clayton, S., Garcia, M.U., Neukamm, J., Peltzer, A.. Reproducible, portable, and efficient ancient genome reconstruction with nf-core/eager. PeerJ 9:10947 (2021) [http://doi.org/10.7717/peerj.10947](http://doi.org/10.7717/peerj.10947)\n\n(3) Krakau, S., Straub, D., Gourlé, H., Gabernet, G., Nahnsen, S., nf-core/mag: a best-practice pipeline for metagenome hybrid assembly and binning, NAR Genomics and Bioinformatics, **4**:1 (2022) [https://doi.org/10.1093/nargab/lqac007](https://doi.org/10.1093/nargab/lqac007)",
    "images": [
      "/img/blog-2024-04-17-img1a.jpg",
      "/img/blog-2024-04-17-img1b.jpg"
    ],
    "author": "James Fellows Yates",
    "tags": "nextflow,nf-core,workshop,ambassador_post"
  },
  {
    "slug": "2024/nf-schema",
    "title": "nf-schema: the new and improved nf-validation",
    "date": "2024-05-01T00:00:00.000Z",
    "content": "Check out Nextflow's newest plugin, nf-schema! It's an enhanced version of nf-validation, utilizing JSON schemas to validate parameters and sample sheets. Unlike its predecessor, it supports the latest JSON schema draft and can convert pipeline-generated files. But what's the story behind its development?\n\n<!-- end-archive-description -->\n\n`nf-validation` is a well-known Nextflow plugin that uses JSON schemas to validate parameters and sample sheets. It can also convert sample sheets to channels using a built-in channel factory. On top of that, it can create a nice summary of pipeline parameters and can even be used to generate a help message for the pipeline.\n\nAll of this has made the plugin very popular in the Nextflow community, but it wasn’t without its issues. For example, the plugin uses an older version of the JSON schema draft, namely draft `07` while the latest draft is `2020-12`. It also can’t convert any files/sample sheets created by the pipeline itself since the channel factory is only able to access values from pipeline parameters.\n\nBut then `nf-schema` came to the rescue! In this plugin we rewrote large parts of the `nf-validation` code, making the plugin way faster and more flexible while adding a lot of requested features. Let’s see what’s been changed in this new and improved version of `nf-validation`.\n\n# What a shiny new JSON schema draft\n\nTo quote the official JSON schema website:\n\n&gt; “JSON Schema is the vocabulary that enables JSON data consistency, validity, and interoperability at scale.”\n\nThis one sentence does an excellent job of explaining what JSON schema is and why it was such a great fit for `nf-validation` and `nf-schema`. By using these schemas, we can validate pipeline inputs in a way that would otherwise be impossible. The JSON schema drafts define a set of annotations that are used to set some conditions to which the data has to adhere. In our case, this can be used to determine what a parameter or sample sheet value should look like (this can range from what type of data it has to be to a specific pattern that the data has to follow).\n\nThe JSON schema draft `07` already has a lot of useful annotations, but it lacked some special annotations that could elevate our validations to the next level. That’s where the JSON schema draft `2020-12` came in. This draft contained a lot more specialized annotations, like dependent requirements of values (if one value is set, another value also has to be set). Although this example was already possible in `nf-validation`, it was poorly implemented and didn’t follow any consensus specified by the JSON schema team.\n\n<div style=\"margin-top: 2rem; margin-bottom: 2rem;\">\n    <img src=\"/img/blog-2024-05-01-nfschema-img1a.jpg\" alt=\"meme on bright landscape\">\n</div>\n\n# Bye-bye Channel Factory, hello Function\n\nOne major shortcoming in the `nf-validation` plugin was the lack of the `fromSamplesheet` channel factory to handle files created by the pipeline (or files imported from another pipeline as part of a meta pipeline). That’s why we decided to remove the `fromSamplesheet` channel factory and replace it with a function called `samplesheetToList` that can be deployed in an extremely flexible way. It takes two inputs: the sample sheet to be validated and converted, and the JSON schema used for the conversion. Both inputs can either be a `String` value containing the path to the files or a Nextflow `file` object. By converting the channel factory to a function, we also decoupled the parameter schema from the actual sample sheet conversion. This means all validation and conversion of the sample sheet is now fully done by the `samplesheetToList` function. In `nf-validation`, you could add a relative path to another JSON schema to the parameter schema so that the plugin would validate the file given with that parameter using the supplied JSON schema. It was necessary to also add this for sample sheet inputs as they would not be validated otherwise. Due to the change described earlier, the schema should no longer be given to the sample sheet inputs because they will be validated twice that way. Last, but certainly not least, this function also introduces the possibility of using nested sample sheets. This was probably one of the most requested features and it’s completely possible right now! Mind that this feature only works for YAML and JSON sample sheets since CSV and TSV do not support nesting.\n\n# Configuration sensation\n\nIn `nf-validation`, you could configure how the plugin worked by certain parameters (like `validationSchemaIgnoreParams`, which could be used to exempt certain parameters from the validation). These parameters have now been converted to proper configuration options under the `validation` scope. The `validationSchemaIgnoreParams` has even been expanded into two configuration options: `validation.ignoreParams` and `validation.defaultIgnoreParams`. The former is to be used by the pipeline user to exclude certain parameters from validation, while the latter is to be used by the pipeline developer to set which parameters should be ignored by default. The plugin combines both options so users no longer need to supply the defaults alongside their parameters that need to be ignored.\n\n# But, why not stick to nf-validation?\n\nIn February we released an earlier version of these changes as `nf-validation` version `2.0.0`. This immediately caused massive issues in quite some nf-core pipelines (I think I set a new record of how many pipelines could be broken by one release). This was due to the fact that a lot of pipelines didn’t pin the `nf-validation` version, so all these pipelines started pulling the newest version of `nf-validation`. The pipelines all started showing errors because this release contained breaking changes. For that reason we decided to remove the version `2.0.0` release until more pipelines pinned their plugin versions.\n\n<div style=\"margin-top: 2rem; margin-bottom: 2rem;\">\n    <img src=\"/img/blog-2024-05-01-nfschema-img1b.jpg\" alt=\"meme on bright landscape\">\n</div>\n\nSome discussion arose from this and we decided that version `2.0.0` would always cause issues since a lot of older versions of the nf-core pipelines didn’t pin their nf-validation version either, which would mean that all those older versions (that were probably running as production pipelines) would suddenly start breaking. That’s why there seemed to be only one sensible solution: make a new plugin with the breaking changes! And it would also need a new name. We started collecting feedback from the community and got some very nice suggestions. I made a poll with the 5 most popular suggestions and let everyone vote on their preferred options. The last place was tied between `nf-schemavalidator` and `nf-validationutils`, both with 3 votes. In third place was `nf-checker` with 4 votes. The second place belonged to `nf-validation2` with 7 votes. And with 13 votes we had a winner: `nf-schema`!\n\nSo, a fork was made of `nf-validation` that we called `nf-schema`. At this point, the only breaking change was the new JSON schema draft, but some other feature requests started pouring in. That’s the reason why the new `samplesheetToList` function and the configuration options were implemented before the first release of `nf-schema` on the 22nd of April 2024.\n\nAnd to try and mitigate the same issue from ever happening again, we added an automatic warning when the pipeline is being run with an unpinned version of nf-schema:\n\n<div style=\"margin-top: 2rem; margin-bottom: 2rem;\">\n    <img src=\"/img/blog-2024-05-01-nfschema-img1c.png\" alt=\"meme on bright landscape\">\n</div>\n\n# So, what’s next?\n\nOne of the majorly requested features is the support for nested parameters. The version `2.0.0` already was getting pretty big so I decided not to implement any extra features into it. This is, however, one of the first features that I will try to tackle in version `2.1.0`.\n\nFurthermore, I’d also like to improve the functionality of the `exists` keyword to also work for non-conventional paths (like s3 and azure paths).\n\nIt’s also a certainty that some weird bugs will pop up over time, those will, of course, also be fixed.\n\n# Useful links\n\nHere are some useful links to get you started on using `nf-schema`:\n\nIf you want to easily migrate from nf-validation to `nf-schema`, you can use the migration guide: https://nextflow-io.github.io/nf-schema/latest/migration_guide/\n\nIf you are completely new to the plugin I suggest reading through the documentation: https://nextflow-io.github.io/nf-schema/latest/\n\nIf you need some examples, look no further: https://github.com/nextflow-io/nf-schema/tree/master/examples\n\nAnd to conclude this blog post, here are some very wise words from Master Yoda himself:\n\n<div style=\"margin-top: 2rem; margin-bottom: 2rem;\">\n    <img src=\"/img/blog-2024-05-01-nfschema-img1d.jpg\" alt=\"meme on bright landscape\">\n</div>",
    "images": [
      "/img/blog-2024-05-01-nfschema-img1a.jpg",
      "/img/blog-2024-05-01-nfschema-img1b.jpg",
      "/img/blog-2024-05-01-nfschema-img1c.png",
      "/img/blog-2024-05-01-nfschema-img1d.jpg"
    ],
    "author": "Nicolas Vannieuwkerke",
    "tags": "nextflow,nf-core,ambassador_post,nf-schema"
  },
  {
    "slug": "2024/nf-test-in-nf-core",
    "title": "Leveraging nf-test for enhanced quality control in nf-core",
    "date": "2024-04-03T00:00:00.000Z",
    "content": "# The ever-changing landscape of bioinformatics\n\nReproducibility is an important attribute of all good science. This is especially true in the realm of bioinformatics, where software is **hopefully** being updated, and pipelines are **ideally** being maintained. Improvements and maintenance are great, but they also bring about an important question: Do bioinformatics tools and pipelines continue to run successfully and produce consistent results despite these changes? Fortunately for us, there is an existing approach to ensure software reproducibility: testing.\n\n<!-- end-archive-description -->\n\n# The Wonderful World of Testing\n\n&gt; \"Software testing is the process of evaluating and verifying that a software product does what it is supposed to do,\"\n&gt; Lukas Forer, co-creator of nf-test.\n\nSoftware testing has two primary purposes: determining whether an operation continues to run successfully after changes are made, and comparing outputs across runs to see if they are consistent. Testing can alert the developer that an output has changed so that an appropriate fix can be made. Admittedly, there are some instances when altered outputs are intentional (i.e., improving a tool might lead to better, and therefore different, results). However, even in these scenarios, it is important to know what has changed, so that no unintentional changes are introduced during an update.\n\n# Writing effective tests\n\nAlthough having any test is certainly better than having no tests at all, there are several considerations to keep in mind when adding tests to pipelines and/or tools to maximize their effectiveness. These considerations can be broadly categorized into two groups:\n\n1. Which inputs/functionalities should be tested?\n2. What contents should be tested?\n\n## Consideration 1: Testing inputs/functionality\n\nGenerally, software will have a default or most common use case. For instance, the nf-core [FastQC](https://nf-co.re/modules/fastqc) module is commonly used to assess the quality of paired-end reads in FastQ format. However, this is not the only way to use the FastQC module. Inputs can also be single-end/interleaved FastQ files, BAM files, or can contain reads from multiple samples. Each input type is analyzed differently by FastQC, and therefore, to increase your test coverage ([\"the degree to which a test or set of tests exercises a particular program or system\"](https://www.geeksforgeeks.org/test-design-coverage-in-software-testing/)), a test should be written for each possible input. Additionally, different settings can change how a process is executed. For example, in the [bowtie2/align](https://nf-co.re/modules/bowtie2_align) module, aside from input files, the `save_unaligned` and `sort_bam` parameters can alter how this module functions and the outputs it generates. Thus, tests should be written for each possible scenario. When writing tests, aim to consider as many variations as possible. If some are missed, don't worry! Additional tests can be added later. Discovering these different use cases and how to address/test them is part of the development process.\n\n## Consideration 2: Testing outputs\n\nOnce test cases are established, the next step is determining what specifically should be evaluated in each test. Generally, these evaluations are referred to as assertions. Assertions can range from verifying whether a job has been completed successfully to comparing the output channel/file contents between runs. Ideally, tests should incorporate all outputs, although there are scenarios where this is not feasible (for example, outputs containing timestamps or paths). In such cases, it's often best to include at least a portion of the contents from the problematic file or, at the minimum, the name of the file to ensure that it is consistently produced.\n\n# Testing in nf-core\n\nnf-core is a community-driven initiative that aims to provide high-quality, Nextflow-based bioinformatics pipelines. The community's emphasis on reproducibility makes testing an essential aspect of the nf-core ecosystem. Until recently, tests were implemented using pytest for modules/subworkflows and test profiles for pipelines. These tests ensured that nf-core components could run successfully following updates. However, at the pipeline level, they did not check file contents to evaluate output consistency. Additionally, using two different testing approaches lacked the standardization nf-core strives for. An ideal test framework would integrate tests at all Nextflow development levels (functions, modules, subworkflows, and pipelines) and comprehensively test outputs.\n\n# New and Improved Nextflow Testing with nf-test\n\nCreated by [Lukas Forer](https://github.com/lukfor) and [Sebastian Schönherr](https://github.com/seppinho), nf-test has emerged as the leading solution for testing Nextflow pipelines. Their goal was to enhance the evaluation of reproducibility in complex Nextflow pipelines. To this end, they have implemented several notable features, creating a robust testing platform:\n\n1. **Comprehensive Output Testing**: nf-test employs [snapshots](https://www.nf-test.com/docs/assertions/snapshots/) for handling complex data structures. This feature evaluates the contents of any specified output channel/file, enabling comprehensive and reliable tests that ensure data integrity following changes.\n2. **A Consistent Testing Framework for All Nextflow Components**: nf-test provides a unified framework for testing everything from individual functions to entire pipelines, ensuring consistency across all components.\n3. **A DSL for Tests**: Designed in the likeness of Nextflow, nf-test's intuitive domain-specific language (DSL) uses 'when' and 'then' blocks to describe expected behaviors in pipelines, facilitating easier test script writing.\n4. **Readable Assertions**: nf-test offers a wide range of functions for writing clear and understandable [assertions](https://www.nf-test.com/docs/assertions/assertions/), improving the clarity and maintainability of tests.\n5. **Boilerplate Code Generation**: To accelerate the testing process, nf-test and nf-core tools feature commands that generate boilerplate code, streamlining the development of new tests.\n\n# But wait… there's more!\n\nThe merits of having a consistent and comprehensive testing platform are significantly amplified with nf-test's integration into nf-core. This integration provides an abundance of resources for incorporating nf-test into your Nextflow development. Thanks to this collaboration, you can utilize common nf-test commands via nf-core tools and easily install nf-core modules/subworkflows that already have nf-test implemented. Moreover, an [expanding collection of examples](https://nf-co.re/docs/contributing/tutorials/nf-test_assertions) is available to guide you through adopting nf-test for your projects.\n\n# Adding nf-test to pipelines\n\nSeveral nf-core pipelines have begun to adopt nf-test as their testing framework. Among these, [nf-core/methylseq](https://nf-co.re/methylseq/) was the first to implement pipeline-level nf-tests as a proof-of-concept. However, since this initial implementation, nf-core maintainers have identified that the existing nf-core pipeline template needs modifications to better support nf-test. These adjustments aim to enhance compatibility with nf-test across components (modules, subworkflows, workflows) and ensure that tests are included and shipped with each component. A more detailed blog post about these changes will be published in the future.\nFollowing these insights, [nf-core/fetchngs](https://nf-co.re/fetchngs) has been at the forefront of incorporating nf-test for testing modules, subworkflows, and at the pipeline level. Currently, fetchngs serves as the best-practice example for nf-test implementation within the nf-core community. Other nf-core pipelines actively integrating nf-test include [mag](https://nf-co.re/mag), [sarek](https://nf-co.re/sarek), [readsimulator](https://nf-co.re/readsimulator), and [rnaseq](https://nf-co.re/rnaseq).\n\n# Pipeline development with nf-test\n\n**For newer nf-core pipelines, integrating nf-test as early as possible in the development process is highly recommended**. An example of a pipeline that has benefitted from the incorporation of nf-tests throughout its development is [phageannotator](https://github.com/nf-core/phageannotator). Although integrating nf-test during pipeline development has presented challenges, it has offered a unique opportunity to evaluate different testing methodologies and has been instrumental in identifying numerous development errors that might have been overlooked using the previous test profiles approach. Additionally, investing time early on has significantly simplified modifying different aspects of the pipeline, ensuring that functionality and output remain unaffected.\nFor those embarking on creating new Nextflow pipelines, here are a few key takeaways from our experience:\n\n1. **Leverage nf-core modules/subworkflows extensively**. Devoting time early to contribute modules/subworkflows to nf-core not only streamlines future development for you and your PR reviewers but also simplifies maintaining, linting, and updating pipeline components through nf-core tools. Furthermore, these modules will likely benefit others in the community with similar research interests.\n2. **Prioritize incremental changes over large overhauls**. Incremental changes are almost always preferable to large, unwieldy modifications. This approach is particularly beneficial when monitoring and updating nf-tests at the module, subworkflow, and pipeline levels. Introducing too many changes simultaneously can overwhelm both developers and reviewers, making it challenging to track what has been modified and what requires testing. Aim to keep changes straightforward and manageable.\n3. **Facilitate parallel execution of nf-test to generate and test snapshots**. By default, nf-test runs each test sequentially, which can make the process of running multiple tests to generate or updating snapshots time-consuming. Implementing scripts that allow tests to run in parallel—whether via a workload manager or in the cloud—can significantly save time and simplify the process of monitoring tests for pass or fail outcomes.\n\n# Community and contribution\n\nnf-core is a community that relies on consistent contributions, evaluation, and feedback from its members to improve and stay up-to-date. This holds true as we transition to a new testing framework as well. Currently, there are two primary ways that people have been contributing in this transition:\n\n1. **Adding nf-tests to new and existing nf-core modules/subworkflows**. There has been a recent emphasis on migrating modules/subworkflows from pytest to nf-test because of the advantages mentioned previously. Fortunately, the nf-core team has added very helpful [instructions](https://nf-co.re/docs/contributing/modules#migrating-from-pytest-to-nf-test) to the website, which has made this process much more streamlined.\n2. **Adding nf-tests to nf-core pipelines**. Another area of focus is the addition of nf-tests to nf-core pipelines. This process can be quite difficult for large, complex pipelines, but there are now several examples of pipelines with nf-tests that can be used as a blueprint for getting started ([fetchngs](https://github.com/nf-core/fetchngs/tree/master), [sarek](https://github.com/nf-core/sarek/tree/master), [rnaseq](https://github.com/nf-core/rnaseq/tree/master), [readsimulator](https://github.com/nf-core/readsimulator/tree/master), [phageannotator](https://github.com/nf-core/phageannotator)).\n\n&gt; These are great areas to work on &amp; contribute in nf-core hackathons\n\nThe nf-core community added a significant number of nf-tests during the recent [hackathon in March 2024](https://nf-co.re/events/2024/hackathon-march-2024). Yet the role of the community is not limited to adding test code. A robust testing infrastructure requires nf-core users to identify testing errors, additional test cases, and provide feedback so that the system can continually be improved. Each of us brings a different perspective, and the development-feedback loop that results from collaboration brings about a much more effective, transparent, and inclusive system than if we worked in isolation.\n\n# Future directions\n\nLooking ahead, nf-core and nf-test are poised for tighter integration and significant advancements. Anticipated developments include enhanced testing capabilities, more intuitive interfaces for writing and managing tests, and deeper integration with cloud-based resources. These improvements will further solidify the position of nf-core and nf-test at the forefront of bioinformatics workflow management.\n\n# Conclusion\n\nThe integration of nf-test within the nf-core ecosystem marks a significant leap forward in ensuring the reproducibility and reliability of bioinformatics pipelines. By adopting nf-test, developers and researchers alike can contribute to a culture of excellence and collaboration, driving forward the quality and accuracy of bioinformatics research.\n\nSpecial thanks to everyone in the #nf-test channel in the nf-core slack workspace for their invaluable contributions, feedback, and support throughout this adoption. We are immensely grateful for your commitment and look forward to continuing our productive collaboration.",
    "images": [],
    "author": "Carson Miller",
    "tags": "nextflow,nf-core,nf-test,ambassador_post"
  },
  {
    "slug": "2024/nxf-nf-core-workshop-kogo",
    "title": "Nextflow workshop at the 20th KOGO Winter Symposium",
    "date": "2024-03-14T00:00:00.000Z",
    "content": "Through a partnership between AWS Asia Pacific and Japan, and Seqera, Nextflow touched ground in South Korea for the first time with a training session at the Korea Genome Organization (KOGO) Winter Symposium. The objective was to introduce participants to Nextflow, empowering them to craft their own pipelines. Recognizing the interest among bioinformaticians, MinSung Cho from AWS Korea’s Healthcare &amp; Research Team decided to sponsor this 90-minute workshop session. This initiative covered my travel expenses and accommodations.\n\n<!-- end-archive-description -->\n\n<div style=\"margin-top: 2rem; margin-bottom: 2rem;\">\n    <img src=\"/img/blog-2024-03-14-kogo-img1a.jpg\" alt=\"Nextflow workshop at KOGO Winter Symposium 2024\">\n</div>\n\nThe training commenced with an overview of Nextflow pipelines, exemplified by the [nf-core/nanoseq](https://nf-co.re/nanoseq/3.1.0) Nextflow pipeline, highlighting the subworkflows and modules. nfcore/nanoseq is a bioinformatics analysis pipeline for Nanopore DNA/RNA sequencing data that can be used to perform base-calling, demultiplexing, QC, alignment, and downstream analysis. Following this, participants engaged in a hands-on workshop using the AWS Cloud9 environment. In 70 minutes, they constructed a basic pipeline for analyzing nanopore sequencing data, incorporating workflow templates, modules, and subworkflows from [nf-core/tools](https://github.com/nf-core/tools). If you're interested in learning more about the nf-core/nanoseq Nextflow pipeline, I recorded a video talking about it in the nf-core bytesize meeting. You can watch it [here](https://www.youtube.com/watch?v=KM1A0_GD2vQ).\n\n<div style=\"margin-top: 2rem; margin-bottom: 2rem;\">\n    <img src=\"/img/blog-2024-03-14-kogo-img1b.png\" alt=\"Slide from Nextflow workshop at KOGO Winter Symposium 2024\">\n</div>\n\nYou can find the workshop slides [here](https://docs.google.com/presentation/d/1OC4ccgbrNet4e499ShIT7S6Gm6S0xr38_OauKPa4G88/edit?usp=sharing) and the GitHub repository with source code [here](https://github.com/yuukiiwa/nf-core-koreaworkshop).\n\nThe workshop received positive feedback, with participants expressing interest in further sessions to deepen their Nextflow proficiency. Due to this feedback, AWS and the nf-core outreach team are considering organizing small-group local or Zoom training sessions in response to these requests.\n\nIt is imperative to acknowledge the invaluable contributions and support from AWS Korea’s Health Care &amp; Research Team, including MinSung Cho, HyunMin Kim, YoungUng Kim, SeungChang Kang, and Jiyoon Hwang, without whom this workshop would not have been possible. Gratitude is also extended to Charlie Lee for fostering collaboration with the nf-core/outreach team.",
    "images": [
      "/img/blog-2024-03-14-kogo-img1a.jpg",
      "/img/blog-2024-03-14-kogo-img1b.png"
    ],
    "author": "Yuk Kei Wan",
    "tags": "nextflow,nf-core,workshop"
  },
  {
    "slug": "2024/optimizing-nextflow-for-hpc-and-cloud-at-scale",
    "title": "Optimizing Nextflow for HPC and Cloud at Scale",
    "date": "2024-01-17T00:00:00.000Z",
    "content": "## Introduction\n\nA Nextflow workflow run consists of the head job (Nextflow itself) and compute tasks (defined in the pipeline script). It is common to request resources for the tasks via process directives such as `cpus` and `memory`, but the Nextflow head job also requires compute resources. Most of the time, users don’t need to explicitly define the head job resources, as Nextflow generally does a good job of allocating resources for itself. For very large workloads, however, head job resource sizing becomes much more important.\n\nIn this article, we will help you understand how the Nextflow head job works and show you how to tune head job resources such as CPUs and memory for your use case.\n\n<!-- end-archive-description -->\n\n## Head job resources\n\n### CPUs\n\nNextflow uses a thread pool to run native Groovy code (e.g. channel operators, `exec` processes), submit tasks to executors, and publish output files. The number of threads is based on the number of available CPUs, so if you want to provide more compute power to the head job, simply allocate more CPUs and Nextflow will use them. In the [Seqera Platform](https://seqera.io/platform/), you can use **Head Job CPUs** or **Head Job submit options** (depending on the compute environment) to allocate more CPUs.\n\n### Memory\n\nNextflow runs on the Java Virtual Machine (JVM), so it allocates memory based on the standard JVM options, specifically the initial and maximum heap size. You can view the default JVM options for your environment by running this command:\n\n```bash\njava -XX:+PrintFlagsFinal -version | grep 'HeapSize\\|RAM'\n```\n\nFor example, here are the JVM options for an environment with 8 GB of RAM and OpenJDK Temurin 17.0.6:\n\n```\n   size_t ErgoHeapSizeLimit                        = 0\n   size_t HeapSizePerGCThread                      = 43620760\n   size_t InitialHeapSize                          = 127926272\n    uintx InitialRAMFraction                       = 64\n   double InitialRAMPercentage                     = 1.562500\n   size_t LargePageHeapSizeThreshold               = 134217728\n   size_t MaxHeapSize                              = 2044723200\n uint64_t MaxRAM                                   = 137438953472\n    uintx MaxRAMFraction                           = 4\n   double MaxRAMPercentage                         = 25.000000\n   size_t MinHeapSize                              = 8388608\n    uintx MinRAMFraction                           = 2\n   double MinRAMPercentage                         = 50.000000\n    uintx NonNMethodCodeHeapSize                   = 5839372\n    uintx NonProfiledCodeHeapSize                  = 122909434\n    uintx ProfiledCodeHeapSize                     = 122909434\n   size_t SoftMaxHeapSize                          = 2044723200\n```\n\nThese settings (displayed in bytes) show an initial and maximum heap size of ~128MB and ~2GB, or 1/64 (1.5625%) and 1/4 (25%) of physical memory. These percentages are the typical default settings, although different environments may have different defaults. In the Seqera Platform, the default settings are 40% and 75%, respectively.\n\nYou can set these options for Nextflow at runtime, for example:\n\n```bash\n# absolute values\nexport NXF_JVM_ARGS=\"-Xms2g -Xmx6g\"\n\n# percentages\nexport NXF_JVM_ARGS=\"-XX:InitialRAMPercentage=25 -XX:MaxRAMPercentage=75\"\n```\n\nIf you need to provide more memory to Nextflow, you can (1) allocate more memory to the head job and/or (2) use `NXF_JVM_ARGS` to increase the percentage of available memory that Nextflow can use. In the Seqera Platform, you can use **Head Job memory** or **Head Job submit options** (depending on the compute environment) to allocate more memory.\n\n### Disk\n\nThe Nextflow head job is generally responsible for downloading software dependencies and transferring inputs and outputs, but the details vary depending on the environment:\n\n- In an HPC environment, the home directory is typically used to store pipeline code and container images, while the work directory is typically stored in high-performance shared storage. Within the work directory, task inputs are staged from previous tasks via symlinks. Remote inputs (e.g. from HTTP or S3) are first staged into the work directory and then symlinked into the task directory.\n- In a cloud environment like AWS Batch, each task is responsible for pulling its own container image, downloading input files from the work directory (e.g. in S3), and uploading outputs. The head job’s local storage is only used to download the pipeline code.\n\nOverall, the head job uses very little local storage, since most data is saved to shared storage (HPC) or object storage (cloud) rather than the head job itself. However, there are a few specific cases to keep in mind, which we will cover in the following section.\n\n## Common failure modes\n\n### Not enough CPUs for local tasks\n\nIf your workflow has any tasks that use the local executor, make sure the Nextflow head job has enough CPUs to execute these tasks. For example, if a local task requires 4 CPUs, the Nextflow head job should have at least 5 CPUs (the local executor reserves 1 CPU for Nextflow by default).\n\n### Not enough memory for native pipeline code\n\nNextflow pipelines are a combination of native Groovy code (channels, operators, `exec` processes) and embedded shell scripts (`script` processes). Native code is executed directly by the Nextflow head job, while tasks with shell scripts are delegated to executors. Typically, tasks are used to perform the “actual” computations, while channels and operators are used to pass data between tasks.\n\nHowever much Groovy code you write, keep in mind that the Nextflow head job needs to have enough memory to execute it at the desired scale. The simplest way to determine how much memory Nextflow needs is to iteratively allocate more memory to the head job until it succeeds (e.g. start with 1 GB, then 2 GB, then 4 GB, and so on). In general, 2-4 GB is more than enough memory for the Nextflow head job.\n\n### Not enough memory to stage and publish files\n\nIn Nextflow, input files can come from a variety of sources: local files, an HTTP or FTP server, an S3 bucket, etc. When an input file is not local, Nextflow automatically stages the file into the work directory. Similarly, when a `publishDir` directive points to a remote path, Nextflow automatically “publishes” the output files using the correct protocol. These transfers are usually performed in-memory.\n\nMany users have encountered head job errors when running large-scale workloads, where the head job runs out of memory while staging or publishing files. While you can try to give more and more memory to Nextflow as in the previous example, you might be able to fix your problem by simply updating your Nextflow version. There have been many improvements to Nextflow over the past few years around file staging, particularly with S3, and overall we have seen fewer out-of-memory errors of this kind.\n\n### Not enough disk storage to build Singularity images\n\nSingularity / Apptainer can download and convert Docker images on the fly, and it uses the head job’s local scratch storage to do so. This is a common pattern in HPC environments, since container images are usually published as Docker images but HPC environments usually require the use of a rootless container runtime like Singularity. In this case, make sure the head job has enough scratch storage to build each image, even if the image is eventually saved to shared storage.\n\nSince Nextflow version [23.10.0](https://github.com/nextflow-io/nextflow/releases/tag/v23.10.0), you can use [Wave](https://seqera.io/wave/) to build Singularity images for you. Refer to the [Nextflow documentation](https://nextflow.io/docs/latest/wave.html#build-singularity-native-images) for more details.\n\nAdditionally, Nextflow version [23.11.0-edge](https://github.com/nextflow-io/nextflow/releases/tag/v23.11.0-edge) introduced support for [Singularity OCI mode](https://docs.sylabs.io/guides/3.1/user-guide/oci_runtime.html), which allows Singularity / Apptainer to use the OCI container format (the same as Docker) instead of having to build and store a SIF container image locally.\n\n### Failures due to head job and tasks sharing local storage\n\nThere are some situations where the head job and tasks may run on the same node and thereby share the node’s local storage, for example, Kubernetes. If this storage becomes full, any one of the jobs might fail first, including the head job. You can avoid this problem by segregating the head job to its own node, or explicitly requesting disk storage for each task so that they each have sufficient storage.\n\n## Virtual threads\n\n[Virtual threads](https://www.infoq.com/articles/java-virtual-threads/) were introduced in Java 19 and finalized in Java 21. Whereas threads in Java are normally “platform” threads managed by the operating system, “virtual” threads are user-space threads that share a pool of platform threads. Virtual threads use less memory and can be context-switched faster than platform threads, so an application that uses a fixed-size pool of platform threads (e.g. one thread per CPU) could instead have thousands of virtual threads (one thread per “task”) with the same memory footprint and more flexibility – if a virtual thread is blocked (i.e. waiting on I/O), the underlying platform thread can be switched to another virtual thread that isn’t blocked.\n\nSince Nextflow [23.05.0-edge](https://github.com/nextflow-io/nextflow/releases/tag/v23.05.0-edge), you can enable virtual threads by using Java 19 or later and setting the `NXF_ENABLE_VIRTUAL_THREADS` environment variable to `true`. Since version [23.10.0](https://github.com/nextflow-io/nextflow/releases/tag/v23.10.0), when using Java 21, virtual threads are enabled by default.\n\n### Initial Benchmark: S3 Upload\n\nVirtual threads are particularly useful when there are many I/O-bound tasks, such as uploading many files to S3. So to demonstrate this benefit, we wrote a pipeline… that uploads many files to S3! Here is the core pipeline code:\n\n```groovy\nparams.upload_count = 1000\nparams.upload_size = '10M'\n\nprocess make_random_file {\n    publishDir 's3://my-bucket/data/'\n\n    input:\n    val index\n    val size\n\n    output:\n    path '*.data'\n\n    script:\n    \"\"\"\n    dd \\\n      if=/dev/random \\\n      of=upload-${size}-${index}.data \\\n      bs=1 count=0 seek=${size}\n    \"\"\"\n}\n\nworkflow {\n    index = Channel.of(1..params.upload_count)\n    make_random_file(index, params.upload_size)\n}\n```\n\nThe full source code is available on [GitHub](https://github.com/bentsherman/nf-head-job-benchmark).\n\nWe ran this pipeline across a variety of file sizes and counts, and the results are shown below. Error bars denote +/- 1 standard deviation across three independent trials.\n\nAt larger scales, virtual threads significantly reduce the total runtime, at the cost of higher CPU and memory usage. Considering that the head job resources are typically underutilized anyway, we think the lower time-to-solution is a decent trade!\n\nThe reason why virtual threads are faster in this case is that Nextflow usually spends extra time waiting for files to be published after all tasks have completed. Normally, these publishing tasks are executed by a fixed-size thread pool based on the number of CPUs, but with virtual threads there is no such limit, so Nextflow can fully utilize the available network bandwidth. In the largest case (1000x 100 MB files), virtual threads reduce the runtime by over 30%.\n\n<div style=\"margin-top: 1rem\">\n    <img src=\"/img/blog-2024-01-17--s3-upload-cpu.png\" alt=\"CPU usage\">\n    <center>Figure 1: CPU usage</center>\n</div>\n\n<div style=\"margin-top: 1rem\">\n    <img src=\"/img/blog-2024-01-17--s3-upload-memory.png\" alt=\"Memory usage\">\n    <center>Figure 2: Memory usage</center>\n</div>\n\n<div style=\"margin-top: 1rem\">\n    <img src=\"/img/blog-2024-01-17--s3-upload-walltime.png\" alt=\"Workflow runtime\">\n    <center>Figure 3: Workflow runtime</center>\n</div>\n\n### Realistic Benchmark: nf-core/rnaseq\n\nTo evaluate virtual threads on a real pipeline, we also ran [nf-core/rnaseq](https://github.com/nf-core/rnaseq) with the `test` profile. To simulate a run with many samples, we upsampled the test dataset to 1000 samples. The results are summarized below:\n\n<table class=\"table table-bordered\">\n  <thead>\n    <tr>\n      <th></th>\n      <th>Walltime</th>\n      <th>Memory</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Platform threads</td>\n      <td>2h 51m</td>\n      <td>1.5 GB</td>\n    </tr>\n    <tr>\n      <td>Virtual threads</td>\n      <td>2h 47m</td>\n      <td>1.9 GB</td>\n    </tr>\n  </tbody>\n</table>\n\nAs you can see, the benefit here is not so clear. Whereas the upload benchmark was almost entirely I/O, a typical Nextflow pipeline spends most of its time scheduling compute tasks and waiting for them to finish. These tasks are generally not I/O bound and do not block for very long, so there may be little opportunity for improvement from virtual threads.\n\nThat being said, this benchmark consisted of only two runs of nf-core/rnaseq. We didn’t perform more runs here because they were so large, so your results may vary. In particular, if your Nextflow runs spend a lot of time publishing outputs after all the compute tasks have completed, you will likely benefit the most from using virtual threads. In any case, virtual threads should perform at least as well as platform threads, albeit with higher memory usage in some cases.\n\n## Summary\n\nThe key to right-sizing the Nextflow head job is to understand which parts of a Nextflow pipeline are executed directly by Nextflow, and which parts are delegated to compute tasks. This knowledge will help prevent head job failures at scale.\n\nHere are the main takeaways:\n\n- Nextflow uses a thread pool based on the number of available CPUs.\n- Nextflow uses a maximum heap size based on the standard JVM options, which is typically 25% of physical memory (75% in the Seqera Platform).\n- You can use `NXF_JVM_ARGS` to make more system memory available to Nextflow.\n- The easiest way to figure out how much memory Nextflow needs is to iteratively double the memory allocation until the workflow succeeds (but usually 2-4 GB is enough).\n- You can enable virtual threads in Nextflow, which may reduce overall runtime for some pipelines.",
    "images": [
      "/img/blog-2024-01-17--s3-upload-cpu.png",
      "/img/blog-2024-01-17--s3-upload-memory.png",
      "/img/blog-2024-01-17--s3-upload-walltime.png"
    ],
    "author": "Ben Sherman",
    "tags": "nextflow,hpc,cloud"
  },
  {
    "slug": "2024/reflecting-ambassador-collaboration",
    "title": "Reflecting on a Six-Month Collaboration: Insights from a Nextflow Ambassador",
    "date": "2024-06-19T00:00:00.000Z",
    "content": "As a Nextflow Ambassador and a PhD student working in bioinformatics, I’ve always believed in the power of collaboration. Over the past six months, I’ve had the privilege of working with another PhD student specializing in metagenomics environmental science. This collaboration began through a simple email after the other researcher discovered my contact information on the ambassadors’ list page. It has been a journey of learning, problem-solving, and mutual growth. I’d like to share some reflections on this experience, highlighting both the challenges and the rewards.\n\n<!-- end-archive-description -->\n\n## Connecting Across Disciplines\n\nOur partnership began with a simple question about running one of nf-core’s metagenomics analysis pipelines. Despite being in different parts of Europe and coming from different academic backgrounds, we quickly found common ground. The combination of our expertise – my focus on bioinformatics workflows and their deep knowledge of microbial ecosystems – created a synergy that enriched our work.\n\n## Navigating Challenges Together\n\nLike any collaboration, ours was not without its difficulties. We faced numerous technical challenges, from optimizing computational resources to troubleshooting pipeline errors. There were moments of frustration when things didn’t work as expected. However, each challenge was an opportunity to learn and grow. Working through these challenges together made them much more manageable and even enjoyable at times. We focused on mastering Nextflow in a high-performance computing (HPC) environment, managing large datasets, and conducting comprehensive data analysis. Additionally, we explored effective data visualization techniques to better interpret and present the findings.\nWe leaned heavily on the Nextflow and nf-core community for support. The extensive documentation and guides were invaluable, and the different Slack channels provided real-time problem-solving assistance. Having the possibility of contacting the main developers of the pipeline that was troubling was a great resource that we are fortunate to have. The community’s willingness to share and offer help was a constant source of encouragement, making us feel supported every step of the way.\n\n## Learning and Growing\n\nOver the past six months, we’ve both learned a tremendous amount. The other PhD student became more adept at using and understanding Nextflow, particularly when running the nf-core/ampliseq pipeline, managing files, and handling high-performance computing (HPC) environments. I, on the other hand, gained a deeper understanding of environmental microbiomes and the specific needs of metagenomics research.\nOur sessions were highly collaborative, allowing us to share knowledge and insights freely. It was reassuring to know that we weren’t alone in our journey and that there was a whole community of researchers ready to share their wisdom and experiences. These interactions made our learning process more rewarding.\n\n## Achieving Synergy\n\nOne of the most rewarding aspects of this collaboration has been the synergy between our different backgrounds. Our combined expertise enabled us to efficiently analyze a high volume of metagenomics samples. The journey does not stop here, of course. Now that they have their samples processed, it comes the time to interpret the data, one of my favorite parts. Our work together highlighted the potential for Nextflow and the nf-core community to facilitate research across diverse fields. The collaboration has been a testament to the idea that when individuals from different disciplines come together, they can achieve more than they could alone.\nThis collaboration is poised to result in significant academic contributions. The other PhD student is preparing to publish a paper with the findings enabled by the use of the nf-core/ampliseq pipeline, which will be a key component of their thesis. This paper is going to serve as an excellent example of using Nextflow and nf-core pipelines in the field of metagenomics environmental science.\n\n## Reflecting on the Journey\n\nAs I reflect on these six months, I’m struck by the power of this community in fostering such collaborations. The support network, comprehensive resources, and culture of knowledge sharing have been essential in our success. This experience has reinforced my belief in the importance of open-source bioinformatics and data science communities for professional development and scientific advancement. Through it all, having a collaborator who understood the struggles and celebrated the successes with me made the journey all the more rewarding.\nMoving forward, I’m excited about the potential for more such collaborations. The past six months have been a journey of discovery and growth, and I’m grateful for the opportunity to work with such a dedicated and talented researcher. Our work is far from over, and I look forward to continuing this journey, learning more, and contributing to the field of environmental science.\n\n## Join the Journey!\n\nFor those of you in the Nextflow community or considering joining, I encourage you to take advantage of the resources available. Engage with the community, attend webinars, and don’t hesitate to ask questions. Whether you’re a seasoned expert or a curious newcomer, the Nextflow family is here to support you. Together, we can achieve great things.",
    "images": [],
    "author": "Cristina Tuñi i Domínguez",
    "tags": "nextflow,ambassador_post"
  },
  {
    "slug": "2024/reflections-on-nextflow-mentorship",
    "title": "One-Year Reflections on Nextflow Mentorship",
    "date": "2024-04-10T00:00:00.000Z",
    "content": "From December 2022 to March 2023, I was part of the second cohort of the Nextflow and nf-core mentorship program, which spanned four months and attracted participants globally. I could not have anticipated the extent to which my participation in this program and the associated learning experiences would positively change my professional growth.\nThe mentorship aims to foster collaboration, knowledge exchange, flexible learning, collaborative coding, and contributions to the nf-core community. It was funded by the Chan Zuckerberg Initiative and is guided by experienced mentors in the community.\nIn the upcoming paragraphs, I'll be sharing more details about the program—its structure, the valuable learning experiences it brought, and the exciting opportunities it opened up for me.\n\n<!-- end-archive-description -->\n\n# Meeting my mentor\n\nOne of the most interesting aspects of the mentorship is that the program emphasizes that mentor-mentee pairs share research interests. In addition, the mentor should have significant experience in the areas where the mentee wants to develop. I found this extremely valuable, as it makes the program very flexible while also considering individual goals and interests. My goal as a mentee was to transition from a **Nextflow user to a Nextflow developer**.\n\nI was lucky enough to have Matthias De Smet as a mentor. He is a member of the Center for Medical Genetics in Ghent and has extensive experience working with open-source projects such as nf-core and Bioconda. His experience working in clinical genomics was a common ground for us to communicate, share experiences and build effective collaboration.\n\nDuring my first days, he guided me to the most useful Nextflow resources available online, tailored to my goals. Then, I drafted a pipeline that I wanted to build and attempted to write my first lines of code in Nextflow. We communicated via Slack and Matthias reviewed and corrected my code via GitHub. He introduced me to the supportive nf-core community, to ask for help when needed, and to acknowledge every success along the way.\n\n<div style=\"margin-top: 2rem; margin-bottom: 2rem;\">\n    <img src=\"/img/blog-2024-04-10-img1a.png\" alt=\"Mentor compliment about new module added\">\n</div>\n\n# Highlights of the program\n\nWe decided to start small, setting step-by-step goals. Matthias suggested that a doable goal would be to create my first Nextflow module in the context of a broader pipeline I wanted to develop. A module is a building block that encapsulates a specific functionality or task within a workflow. We realized that the tool I wanted to modularize was not available as part of nf-core. The nf-core GitHub has a community-driven collection of Nextflow modules, subworkflows and pipelines for bioinformatics, providing standardized and well-documented modules. The goal, therefore, was to create a module for this missing tool and then submit it as a contribution to nf-core.\n\nFor those unfamiliar, contributing to nf-core requires another member of the community, usually a maintainer, to review your code. As a newcomer, I was obviously curious about how the process would be. In academia, where anonymity often prevails, feedback can occasionally be a bit stringent. Conversely, during my submission to the nf-core project, I was pleasantly surprised that reviewers look for collective improvement, providing quick, constructive and amicable reviews, leading to a positive environment.\n\n<div style=\"margin-top: 2rem; margin-bottom: 2rem;\">\n    <img src=\"/img/blog-2024-04-10-img1b.png\" alt=\"Review comment in GitHub\">\n</div>\n\nFor my final project in the mentorship program, I successfully ported a complete pipeline from Bash to Nextflow. This was a learning experience that allowed me to explore a diverse range of skills, such as modularizing content, understanding how crucial the meta map is, and creating Docker container images for software. This process not only enhanced my proficiency in Nextflow but also allowed me to interact with and contribute to related projects like Bioconda and BioContainers.\n\n# Life after the mentorship\n\nWith the skills I acquired during the mentorship as a mentee, I proposed and successfully implemented a custom solution in Nextflow for a precision medicine start-up I worked at the time that could sequentially do several diagnostics and consumer-genetics applications in the cloud, resulting in substantial cost savings and increasing flexibility for the company.\nBeyond my immediate projects, I joined a group actively developing an open-source Nextflow pipeline for genetic imputation. This project allowed me to be in close contact with members of the nf-core community working on similar projects, adding new tools to this pipeline, giving and receiving feedback, and continuing to improve my overall Nextflow skills while also contributing to the broader bioinformatics community. You can learn more about this project with the fantastic talk by Louis Le Nézet at Nextflow Summit 2023 [here](https://www.youtube.com/watch?v=GHb2Wt9VCOg).\n\nFinally, I was honored to become a Nextflow ambassador. The program’s goal is to extend the awareness of Nextflow around the world while also building a supportive community. In particular, the South American community is underrepresented, so I serve as a point of contact for any institution or newcomer who wants to implement pipelines with Nextflow.\nAs part of this program, I was invited to speak at the second Chilean Congress of Bioinformatics, where I gave a talk about how Nextflow and nf-core can support scaling bioinformatics projects in the cloud. It was incredibly rewarding to introduce Nextflow to a community for the first time and witness the genuine enthusiasm it sparks among students and attendees for the potential in their research projects.\n\n<div style=\"margin-top: 2rem; margin-bottom: 2rem;\">\n    <img src=\"/img/blog-2024-04-10-img1c.png\" alt=\"Second Chilean Congress of Bioinformatics\">\n</div>\n\n# What’s next?\n\nThe comprehensive skill set acquired in my journey proved to be incredibly valuable for my professional development and allowed me to join the ZS Discovery Team as a Senior Bioinformatician. This organization accelerates transformation in research and early development with direct contribution to impactful bioinformatics projects with a globally distributed, multidisciplinary talented team.\n\nIn addition, we organized a local site for the nf-core hackathon in March 2024, the first Nextflow Hackathon in Argentina, fostering a space to advance our skills in workflow management collectively. It was a pleasure to see how beginners got their first PRs approved and how they interacted with the nf-core community for the first time.\n\n<div style=\"margin-top: 2rem; margin-bottom: 2rem;\">\n    <img src=\"/img/blog-2024-04-10-img1d.png\" alt=\"nf-core March 2024 Hackathon site in Argentina\">\n</div>\n\nMy current (and probably future!) day-to-day work involves working and developing pipelines with Nextflow, while also mentoring younger bioinformaticians into this language. The commitment to open-source projects remains a cornerstone of my journey and I am thankful that it has provided me the opportunity to collaborate with individuals from diverse backgrounds all over the world.\n\nWhether you're interested in the mentorship program, curious about the hackathon, or simply wish to connect, feel free to reach out at the nf-core Slack!",
    "images": [
      "/img/blog-2024-04-10-img1a.png",
      "/img/blog-2024-04-10-img1b.png",
      "/img/blog-2024-04-10-img1c.png",
      "/img/blog-2024-04-10-img1d.png"
    ],
    "author": "Anabella Trigila",
    "tags": "nextflow,nf-core,workshop,ambassador_post"
  },
  {
    "slug": "2024/training-local-site",
    "title": "Nextflow Training: Bridging Online Learning with In-Person Connections",
    "date": "2024-05-08T00:00:00.000Z",
    "content": "Nextflow and nf-core provide frequent community training events to new users, which offer an opportunity to get started using and understanding Nextflow, Groovy and nf-core. These events are live-streamed and are available for on-demand viewing on YouTube, but what if you could join friends in person and watch it live?\n\n<!-- end-archive-description -->\n\nLearning something new by yourself can be a daunting task. Having colleagues and friends go through the learning and discovering process alongside you can really enrich the experience and be a lot of fun! With that in mind, we decided to host a get-together for the fundamentals training streams in person. Anybody from the scientific community in and around Heidelberg who wanted to learn Nextflow was welcome to join.\n\nThis year, [Marcel Ribeiro-Dantas](https://twitter.com/mribeirodantas) and [Chris Hakkaart](https://twitter.com/Chris_Hakk) from Seqera held the training over two days, offering the first steps into the Nextflow universe (you can watch it [here](https://www.youtube.com/playlist?list=PL3xpfTVZLcNgLBGLAiY6Rl9fizsz-DTCT)). [Kübra Narcı](https://twitter.com/kubranarci) and [Florian Wünneman](https://twitter.com/flowuenne) hosted a local training site for the recent community fundamentals training in Heidelberg. Kübra is a Nextflow ambassador, working as a bioinformatician and using Nextflow to develop pipelines for the German Human Genome Phenome Archive (GHGA) project in her daily life. At the time, Florian was a Postdoc at the Institute of Computational Biomedicine with Denis Schapiro in Heidelberg, though he has since then joined Seqera as a Bioinformatics Engineer.\n\nWe advertised the event about a month beforehand in our local communities (genomics, transcriptomics, spatial omics among others) to give people enough time to decide whether they want to join. We had quite a bit of interest and a total of 15 people participated. The event took place at the Marsilius Arkaden at the University Clinic campus in Heidelberg. Participants brought their laptops and followed along with the stream, which we projected for everyone, so people could use their laptops exclusively for coding and did not have to switch between stream and coding environment.\n\n<div style=\"margin-top: 2rem; margin-bottom: 2rem;\">\n    <img src=\"/img/blog-2024-05-06-training-img1a.jpg\" alt=\"meme on bright landscape\">\n</div>\n\n<div style=\"margin-top: 2rem; margin-bottom: 2rem;\">\n    <img src=\"/img/blog-2024-05-06-training-img2a.jpg\" alt=\"meme on bright landscape\">\n</div>\n\nThe goal of this local training site was for everyone to follow the fundamentals training sessions on their laptop and be able to ask follow-up questions in person to the room. We also had a few experienced Nextflow users be there for support. There is a dedicated nf-core Slack channel during the training events for people to ask questions, which is a great tool for help. We also found that in-person discussions around topics that remained confusing to participants were really helpful for many people, as they could provide some more context and allow quick follow-up questions. During the course of the fundamentals training, we found ourselves naturally pausing the video and taking the time to discuss with the group. It was particularly great to see new users explaining concepts they just learned to each other.\n\nThis local training site was also an excellent opportunity for new Nextflow users in Heidelberg to get to know each other and make new connections before the upcoming nf-core hackathon, for which there was also a [local site](https://nf-co.re/events/2024/hackathon-march-2024/germany-heidelberg) organized in Heidelberg. It was a great experience to organize a smaller local event to learn Nextflow with the local community. We learned some valuable lessons from this experience, that we will apply for the next local Nextflow gatherings. Advertising a bit earlier will give people more time to spread the word, we would likely aim for 2 months in advance next time. Offering coffee during breaks can go a long way to keep people awake and motivated, so we would try to serve up some hot coffee next time. Finally, having a bit more in-depth introductions (maybe via short posts on a forum) of everyone joining could be an even better ice breaker to foster contacts and collaborations for the future.\n\nThe ability to join training sessions, bytesize talks, and other events from nf-core and Nextflow online is absolutely fantastic and enables the free dissemination of knowledge. However, the opportunity to join a group in person and work through the content together can really enrich the experience and bring people closer together.\n\nIf you're looking for a training opportunity, there will be one in Basel, Switzerland, on June 25 and another one in Cambridge, UK, on September 12. These and other events will be displayed in the [Seqera Events](https://seqera.io/events/) page when it gets closer to the dates of the events.\n\nWho knows, maybe you will meet someone interested in the same topic, a new collaborator or even a new friend in your local Nextflow community!",
    "images": [
      "/img/blog-2024-05-06-training-img1a.jpg",
      "/img/blog-2024-05-06-training-img2a.jpg"
    ],
    "author": "Florian Wuennemann",
    "tags": "nextflow,nf-core,ambassador_post,training"
  },
  {
    "slug": "2024/welcome_ambassadors_20242",
    "title": "Join us in welcoming the new Nextflow Ambassadors",
    "date": "2024-07-10T00:00:00.000Z",
    "content": "As the second semester of 2024 kicks off, I am thrilled to welcome a new cohort of ambassadors to the Nextflow Ambassador Program. This vibrant group joins the dedicated ambassadors who are continuing their remarkable work from the previous semester. Together, they form a diverse and talented team, representing a variety of countries and backgrounds, encompassing both industry and academia.\n\n<!-- end-archive-description -->\n\n## A Diverse and Inclusive Cohort\n\nThis semester, I am proud to announce that our ambassadors hail from over 20 countries, reflecting the increasingly global reach and inclusive nature of the Nextflow community. There has historically been a strong presence of Nextflow in the US and Europe, so I would like to extend an especially warm welcome to all those in Asia and the global south who are joining us through the program, from countries such as Argentina, Chile, Brazil, Ghana, Tunisia, Nigeria, South Africa, India, Indonesia, Singapore, and Australia. From seasoned bioinformaticians to emerging data scientists, our ambassadors bring a wealth of expertise and unique perspectives to the program.\n\n## Industry and Academia Unite\n\nOne of the strengths of the Nextflow Ambassador Program is its ability to bridge the gap between industry and academia. This semester, we have an exciting mix of professionals from biotech companies, renowned research institutions, and leading universities. This synergy fosters a rich exchange of ideas, driving innovation and collaboration.\n\n## Spotlight on New Ambassadors\n\nI am particularly happy with this last call for ambassadors. Amazing people were selected, and I would like to highlight a few, though all of them are good additions to the team! For example, while Carson Miller, a PhD Candidate in the Department of Microbiology at the University of Washington, is new to the ambassador program, he has been making impactful contributions to the community for a long time. He hosted a local site for the nf-core Hackathon back in March, wrote a post to the Nextflow blog and has been very active in the nf-core community. The same can be said about Mahesh Binzer-Panchal, a Bioinformatician at NBIS, who has been very active in the community answering technical questions about Nextflow.\n\nThe previous round of ambassadors allowed us to achieve a broad global presence. However, some regions were more represented than others. I am especially thrilled to have new ambassadors in new regions of the globe, For example, Fadinda Shafira and Edwin Simjaya from Indonesia, AI Engineer and Head of AI at Kalbe, respectively. Prior to joining the program, they had already been strong advocates for Nextflow in Indonesia and had conducted Nextflow training sessions!\n\n## Continuing the Good Work\n\nI'm also delighted to see the continuing work of several dedicated ambassadors who have made significant contributions to the program. Abhinav Sharma, a Ph.D. Candidate at Stellenbosch University in South Africa, has been a key community contact in the African continent, and with the support we were able to provide him through the program, he was able to travel around Brazil and visit multiple research groups to advocate for Open Science, Nextflow, and nf-core. Similarly, Kübra Narcı, a bioinformatician at DKFZ in Germany, increased the awareness of [Nextflow in her home country, Türkiye](https://www.nextflow.io/blog/2024/bioinformatics-growth-in-turkiye.html), while also contributing to the [German research community](https://www.nextflow.io/blog/2024/training-local-site.html).\n\nThe program has been shown to welcome a variety of backgrounds and both new and long-time community members. Just last year, Anabella Trigila, a Senior Bioinformatician at ZS in Argentina, was a mentee in the Nextflow and nf-core mentorship program and has quickly become a [key member in Latin America](https://www.nextflow.io/blog/2024/reflections-on-nextflow-mentorship.html). Robert Petit, a Bioinformatician at the Wyoming Public Health Laboratory in the US, meanwhile, has been [a contributor for many years](https://www.nextflow.io/blog/2024/empowering-bioinformatics-mentoring.html) and keeps giving back to the community.\n\n## Where we are\n\n<div style=\"margin-top: 2rem; margin-bottom: 2rem;\">\n  <img src=\"/img/blog-2024-07-10-img1a.png\" alt=\"Map with colored countries based on ambassadors residency\">\n</div>\n\n## Looking Ahead\n\nThe upcoming semester promises to be an exciting period of growth and innovation for the Nextflow Ambassador Program. Based on current plans, our ambassadors are set to make sure people worldwide know Nextflow and have all the support they need to use it to advance the field of computational biology, among others. I look forward to seeing the incredible work that will emerge from this talented group.\n\nWelcome, new and continuing ambassadors, to another inspiring semester! Together, we will continue to help push the boundaries of what's possible with Nextflow.\n\nStay tuned for more updates and follow our ambassadors' journeys on the Nextflow blog here and the [Nextflow's Twitter/X account](https://x.com/nextflowio).\n\n<div class=\"footer-wrapper\" style=\"margin-top:40px;\">\n  <img src=\"/img/nextflow_ambassador_logo.svg\" height=\"70\" class=\"pull-right\" style=\"padding: 1rem 1rem;\">\n\n  \n\n&gt; Ambassadors are passionate individuals who support\n&gt;       the Nextflow community. Interested in becoming an ambassador? Read more about it\n&gt;       [here](https://www.nextflow.io/ambassadors.html).\n\n</div>",
    "images": [
      "/img/blog-2024-07-10-img1a.png",
      "/img/nextflow_ambassador_logo.svg"
    ],
    "author": "Marcel Ribeiro-Dantas",
    "tags": "nextflow,ambassador_post"
  }
]